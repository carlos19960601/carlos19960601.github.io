<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Carlos的废话集</title>
    <link>https://carlos19960601.github.io/</link>
    <description>Recent content on Carlos的废话集</description>
    <generator>Hugo -- 0.128.2</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 07 Jul 2024 09:01:39 +0800</lastBuildDate>
    <atom:link href="https://carlos19960601.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>各种你懂的协议</title>
      <link>https://carlos19960601.github.io/posts/%E5%90%84%E7%A7%8D%E4%BD%A0%E6%87%82%E7%9A%84%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 07 Jul 2024 09:01:39 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%90%84%E7%A7%8D%E4%BD%A0%E6%87%82%E7%9A%84%E5%8D%8F%E8%AE%AE/</guid>
      <description>Socks5协议 具体协议过程参考理解socks5协议的工作过程和协议细节。这篇文章主要是通过代码去理解socks5协议。
实验条件介绍 命令行设置proxy
export https_proxy=socks5://127.0.0.1:7891 http_proxy=socks5://127.0.0.1:7891 之后通过curl发起http请求。
curl www.baidu.com 这时候，curl这个命令就会走socks协议，并封装socks协议数据发送给socks5://127.0.0.1:7891。
协商阶段 根据参考资料，握手阶段-协商阶段发送的数据格式如下：
+----+----------+----------+ |VER | NMETHODS | METHODS | +----+----------+----------+ | 1 | 1 | 1 to 255 | +----+----------+----------+ #上方的数字表示字节数，下面的表格同理，不再赘述 VER: 协议版本，socks5为0x05
NMETHODS: 支持认证的方法数量
METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:
X’00’ NO AUTHENTICATION REQUIRED X’01’ GSSAPI X’02’ USERNAME/PASSWORD X’03’ to X’7F’ IANA ASSIGNED X’80’ to X’FE’ RESERVED FOR PRIVATE METHODS X’FF’ NO ACCEPTABLE METHODS 那么socks服务端接受到请求时，需要解析内容，选中一个METHOD返回给客户端，格式如下:
+----+--------+ |VER | METHOD | +----+--------+ | 1 | 1 | +----+--------+ func ServerHandshake(rw net.</description>
    </item>
    <item>
      <title>新机必备软件</title>
      <link>https://carlos19960601.github.io/posts/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Sat, 06 Jul 2024 08:42:02 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/</guid>
      <description>开发工具 科学上网
Clash.Verge
Apple M芯片：Clash.Verge_1.7.2_aarch64.dmg
Intel芯片：Clash.Verge_1.7.2_x64.dmg
ClashX
ClashX.dmg Homebrew
/bin/bash -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;#34; brew install git go hugo git-lfs rust bruno sequel-ace brew install --cask warp orbstack flutter losslesscut vscode
Android Studio
Dash 设计 Billfish AceMovi Video Editor Amadine Sip Pixelmator Pro 其他 Telegram DaisyDisk Permute 3 IINA brew install --cask iina Google Chrome </description>
    </item>
    <item>
      <title>怎么写Makefile</title>
      <link>https://carlos19960601.github.io/posts/%E6%80%8E%E4%B9%88%E5%86%99makefile/</link>
      <pubDate>Mon, 01 Jul 2024 17:11:40 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E6%80%8E%E4%B9%88%E5%86%99makefile/</guid>
      <description>基本语法 targets: prerequisites command command command 变量 声明变量
NAME=ClashV BINDIR=bin 使用$()来引用变量
PLATFORM_LIST = \ darwin-amd64 \ darwin-amd64-compatible \ all-arch: $(PLATFORM_LIST) 自动变量 $@: 表示target
darwin-amd64: GOARCH=amd64 GOOS=darwin $(GOBUILD) -o $(BINDIR)/$(NAME)-$@ 条件判断 ifeq ($(BRANCH),Alpha) VERSION=alpha-$(shell git rev-parse --short HEAD) else ifeq ($(BRANCH),Beta) VERSION=beta-$(shell git rev-parse --short HEAD) else ifeq ($(BRANCH),) VERSION=$(shell git describe --tags) else VERSION=$(shell git rev-parse --short HEAD) endif 函数 shell BRANCH=$(shell git branch --show-current) 相关链接 Makefile Tutorial </description>
    </item>
    <item>
      <title>开源项目推荐【持续更新】</title>
      <link>https://carlos19960601.github.io/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Mon, 01 Jul 2024 16:53:15 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/</guid>
      <description> react-rough-fiber: 渲染手绘风 SVG 的 React 渲染器，可以轻松把 SVG 转换成手绘风图片 </description>
    </item>
    <item>
      <title>工具推荐【持续更新】</title>
      <link>https://carlos19960601.github.io/posts/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Mon, 01 Jul 2024 16:52:23 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</guid>
      <description> happyhues: 网站颜色搭配神器 </description>
    </item>
    <item>
      <title>缓存驱逐策略</title>
      <link>https://carlos19960601.github.io/posts/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 26 Jun 2024 22:54:31 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/</guid>
      <description> Least Recently Used(LRU): 删除最旧的数据。基本假设是最近访问的数据可能很快会再次被需要。 Most Recently Used(MRU): 与LRU相反，删除最新的数据。常用于流处理或批处理平台，这些平台一旦使用数据就不太可能再次需要。 Least Frequently Used(LFU): 删除使用最少的数据。虽然它是一种比 LRU 更准确的方法，但它需要一种机制来记录数据访问的频率，这增加了复杂性。它通常与 LRU 等策略配合使用，以降低缓存过时数据的风险。 Time-To-Live (TTL)：数据在预设的时间段有效。常用在会话数据中。 Two-tiered caching两层缓存提供了一种更复杂的方法。可以在速度和成本之间取得平衡。在此设计中，数据被分为快速、昂贵的层（用于流行数据）和较慢、经济的层（用于较少访问的数据）。 上述五种策略是最流行的缓存方法。还有其他一些策略：
先进先出（FIFO）：最旧的数据首先被删除。 随机替换（RR）：随机选择要删除的数据。 自适应替换缓存 (ARC)：使用自调整算法跟踪新近度和频率来确定首先删除哪些数据。 </description>
    </item>
    <item>
      <title>atomic.Value存储interface的问题</title>
      <link>https://carlos19960601.github.io/posts/atomic.value%E5%AD%98%E5%82%A8interface%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 26 Jun 2024 17:39:28 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/atomic.value%E5%AD%98%E5%82%A8interface%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>先看这段代码
import ( &amp;#34;io&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;sync/atomic&amp;#34; ) func main() { var v atomic.Value var err error err = &amp;amp;http.ProtocolError{} v.Store(err) err = io.EOF v.Store(err) } 运行后会报错 panic: sync/atomic: store of inconsistently typed value into Value。
原因是atomic.Value.Store需要类型是一致的。在这里err类型发生了变化，虽然他们都是error接口类型。具体参考Issues#22550
怎么解决？包装一层就能运行了。
type tValue[T any] struct { value T } func main() { var v atomic.Value var err error err = &amp;amp;http.ProtocolError{} v.Store(tValue[error]{err}) err = io.EOF v.Store(tValue[error]{err}) } </description>
    </item>
    <item>
      <title>MySQL存储与索引原理分享</title>
      <link>https://carlos19960601.github.io/posts/mysql%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E4%BA%AB/</link>
      <pubDate>Fri, 30 Jul 2021 00:45:17 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/mysql%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E4%BA%AB/</guid>
      <description>很早之前做的一次分享，下面是PPT内容</description>
    </item>
    <item>
      <title>关于Golang GC问题的思考</title>
      <link>https://carlos19960601.github.io/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Tue, 27 Jul 2021 23:45:51 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;由于GC复杂，我也没有仔细研究过GC的源码，所以只能站在巨人的肩上学习，如果想了解GC的具体实现请移步文末的参考资料。本文只是记录我在阅读完大佬文章中自己的一些问题与思考，可能有一些不对的地方。欢迎大家一起讨论。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Timer源码阅读分享</title>
      <link>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</link>
      <pubDate>Sat, 10 Jul 2021 01:09:15 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</guid>
      <description>这是在小团队里面的一次分享，以下是PPT内容</description>
    </item>
    <item>
      <title>Timer源码阅读</title>
      <link>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 22 Apr 2021 22:50:29 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;根据&lt;a href=&#34;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/&#34;&gt;6.3 计时器&lt;/a&gt;中的描述，Golang Timer的设计经历了如下阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；&lt;/li&gt;
&lt;li&gt;Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；&lt;/li&gt;
&lt;li&gt;Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题&lt;/li&gt;
&lt;li&gt;Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO  为什么会发生P和M的绑定和解绑)&lt;/li&gt;
&lt;li&gt;Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用的是Go 1.16的版本进行分析&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java线程池</title>
      <link>https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Wed, 16 Dec 2020 12:55:05 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;h4 id=&#34;线程池是什么&#34;&gt;线程池是什么？&lt;/h4&gt;
&lt;p&gt;线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>再回首CMS垃圾回收</title>
      <link>https://carlos19960601.github.io/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Fri, 27 Nov 2020 21:50:29 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>前言 之前学习JVM垃圾回收时，主要是过了一遍垃圾收集算法，比如复制算法，标记-清除算法，标记-整理算法，在此基础上可以增加分代，每代采取不同的回收算法，以提高整体的分配和回收效率。然后过了一遍JVM中的垃圾收集器，比如Serial、Parallel Scavenge、Parallel New、CMS、G1等。
自认为垃圾收集就是根据GC Root标记所有可达的对象，然后把所有没有标记的对象清除就ok了。是不是很简单。事实上垃圾收集也就是这么一回事，但是很多时候说起来简单，做起来却会出现很多问题。这篇文章就是记录我对CMS垃圾收集器的一些疑问并学习的过程。
首先看一下CMS的整体流程(具体每个流程的详情就自行了解吧)
如何进行标记？ 最近在看Golang的GC算法实现，里面用到了三色标记法，但是在我的知识库中对三色标记法有这个概念，是的，我只知道这个概念，不知道三色标记法是怎么一个流程，也不知道三色标记法在GC中怎么与运行的。于是就开始了我的探险之旅。
在搜索了一下三色标记法（具体可以看一下文末参考文档中三色标记法与读写屏障了解详情）后，发现现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，CMS垃圾收集器也不例外。
GC Root有哪些？ 我们知道怎么进行标记了，但最初标记的时候需要一些根据才行啊，这些根据就是我们收的GC Root。GC Root有哪些？网上有很多的答案，我的理解就是
当前活跃调用栈中的指向对象的引用 一些不会发生改变的数据所指向的引用 这里我使用的是引用，而不是对象，因为R大是这样说的（具体的问题见参考文档java的gc为什么要分代？）
所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。 例如说，这些引用可能包括：
所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。 VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。 JNI handles，包括global handles和local handles （看情况）所有当前被加载的Java类 （看情况）Java类的引用类型静态变量 （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型） （看情况）String常量池（StringTable）里的引用 注意，是一组必须活跃的引用，不是对象。
现在知道了GC Root，但是我们都知道有分代的概念，新生代的gc和老年的代的gc回收的区域是不一样，那么这里的GC Root是不是应该不一样呢？肯定是不一样的。
首先看一下新生代的GC
新生代的区域一般都比较小，而且对象的存活率都比较低，所以按照前面说的GC Root在新生代的区域扫描就行了。但是会有一个问题？老年代存在引用新生代对象的可能啊？如果只扫描新生代的区域，会漏掉被老年代引用的对象，这些对象就会被清除掉，这是不允许的。
如果这样的话，那是不是扫描一下老年代的对象，看是否引用新生代的对象是不是就ok了？嗯这么做肯定是ok的，但是老年代一般很大，而且存活的对象很多，会导致扫描占用很长的时间。那这个问题如何解？JVM是如何避免Minor GC时扫描全堆的？
经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：
卡表的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。
所以新年代GC的GC Root包含2部分
新生代中满足GC Root定义的对象 卡表中老年代引用新生代的对象 老年代的GC
前面我们说了新生代的gc，我们以同样的思路来看看老年代的gc，老年代的GC Root如何来标记呢？只扫描老年代可以吗？当然是不行的，因为新生代中也可能存在老年代对象的引用，好在新生代并不大，所以老年代GC的时候还需要扫描一遍新生代。
所以老年代GC的GC Root包含2部分
老生代中满足GC Root定义的对象，如图节点1； 标记年轻代中活着的对象引用到的老年代的对象（指的是年轻代中还存活的引用类型对象，引用指向老年代中的对象）如图节点2、3； 并发标记的好坏? 标记作为垃圾回收的第一步，现在知道如何进行标记，接下来就是遍历这些对象，将所有未标记的对象清理就完成GC了。
然而事实上并没有这么简单，如果标记的时候是STW的，那就是这么简单，但是如果标记过程都STW会造成暂停时间过长，给人的感觉就是系统一卡一卡的。
于是就把标记的过程改成并发的进行，也就是CMS中并发标记的过程，然而这就是一切复杂问题的源头。虽然并发标记提升了标记的效率，但是因此却引发了一系列的问题。
因为并发标记时，gc线程和用户线程是并行的，所以在这个过程中会出现下面的情况(需要了解三色标记法与读写屏障)：
新生代晋升到老年代 黑色对象取消对灰色对象的引用(浮动垃圾) 黑色对象新增对白色对象的引用(漏标) 其实在三色标记法与读写屏障文中已经给出了解决方法&amp;ndash;添加读写屏障
写屏障 + SATB 写屏障 + 增量更新 读屏障（Load Barrier） 在CMS并发标记阶段，使用 写屏障 + 增量更新 的方法，将上面出现的情况标记为dirty，这样最后再遍历处理一下Dirty集合中的对象就ok了</description>
    </item>
  </channel>
</rss>
