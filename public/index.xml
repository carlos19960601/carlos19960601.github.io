<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>PaperMod</title>
    <link>//localhost:1313/</link>
    <description>Recent content on PaperMod</description>
    <generator>Hugo -- 0.127.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 30 Jul 2021 00:45:17 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL存储与索引原理分享</title>
      <link>//localhost:1313/posts/mysql%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E4%BA%AB/</link>
      <pubDate>Fri, 30 Jul 2021 00:45:17 +0800</pubDate>
      <guid>//localhost:1313/posts/mysql%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E4%BA%AB/</guid>
      <description>很早之前做的一次分享，下面是PPT内容</description>
    </item>
    <item>
      <title>关于Golang GC问题的思考</title>
      <link>//localhost:1313/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Tue, 27 Jul 2021 23:45:51 +0800</pubDate>
      <guid>//localhost:1313/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;由于GC复杂，我也没有仔细研究过GC的源码，所以只能站在巨人的肩上学习，如果想了解GC的具体实现请移步文末的参考资料。本文只是记录我在阅读完大佬文章中自己的一些问题与思考，可能有一些不对的地方。欢迎大家一起讨论。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Timer源码阅读分享</title>
      <link>//localhost:1313/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</link>
      <pubDate>Sat, 10 Jul 2021 01:09:15 +0800</pubDate>
      <guid>//localhost:1313/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</guid>
      <description>这是在小团队里面的一次分享，以下是PPT内容</description>
    </item>
    <item>
      <title>Timer源码阅读</title>
      <link>//localhost:1313/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 22 Apr 2021 22:50:29 +0800</pubDate>
      <guid>//localhost:1313/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;根据&lt;a href=&#34;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/&#34;&gt;6.3 计时器&lt;/a&gt;中的描述，Golang Timer的设计经历了如下阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；&lt;/li&gt;
&lt;li&gt;Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；&lt;/li&gt;
&lt;li&gt;Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题&lt;/li&gt;
&lt;li&gt;Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO  为什么会发生P和M的绑定和解绑)&lt;/li&gt;
&lt;li&gt;Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用的是Go 1.16的版本进行分析&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java线程池</title>
      <link>//localhost:1313/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Wed, 16 Dec 2020 12:55:05 +0800</pubDate>
      <guid>//localhost:1313/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;h4 id=&#34;线程池是什么&#34;&gt;线程池是什么？&lt;/h4&gt;
&lt;p&gt;线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>再回首CMS垃圾回收</title>
      <link>//localhost:1313/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Fri, 27 Nov 2020 21:50:29 +0800</pubDate>
      <guid>//localhost:1313/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;之前学习JVM垃圾回收时，主要是过了一遍垃圾收集算法，比如复制算法，标记-清除算法，标记-整理算法，在此基础上可以增加分代，每代采取不同的回收算法，以提高整体的分配和回收效率。然后过了一遍JVM中的垃圾收集器，比如Serial、Parallel Scavenge、Parallel New、CMS、G1等。&lt;/p&gt;
&lt;p&gt;自认为垃圾收集就是根据GC Root标记所有可达的对象，然后把所有没有标记的对象清除就ok了。是不是很简单。事实上垃圾收集也就是这么一回事，但是很多时候说起来简单，做起来却会出现很多问题。这篇文章就是记录我对CMS垃圾收集器的一些疑问并学习的过程。&lt;/p&gt;
&lt;p&gt;首先看一下CMS的整体流程(具体每个流程的详情就自行了解吧)&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;//localhost:1313/%e5%86%8d%e5%9b%9e%e9%a6%96CMS%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/CMS%e6%b5%81%e7%a8%8b.png&#34; alt=&#34;CMS流程&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
