<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.143.1">

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" />
  <link rel="canonical" href="https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" /><link rel="alternate" type="application/atom+xml" href="https://carlos19960601.github.io/index.xml" title="Carlos的废话集">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/carlos19960601.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "Timer源码阅读",
      "headline" : "Timer源码阅读",
      "description" : "根据6.3 计时器中的描述，Golang Timer的设计经历了如下阶段：\nGo 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发； Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题 Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M\/P切换的开销增加(TODO 为什么会发生P和M的绑定和解绑) Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发 我使用的是Go 1.16的版本进行分析\n",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2021",
      "datePublished": "2021-04-22 22:50:29 \u002b0800 \u002b0800",
      "dateModified" : "2021-04-22 22:50:29 \u002b0800 \u002b0800",
      "url" : "https:\/\/carlos19960601.github.io\/posts\/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB\/",
      "keywords" : [ "Golang", ]
  }
</script>
<title>Timer源码阅读</title>
  <meta property="og:title" content="Timer源码阅读" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="根据6.3 计时器中的描述，Golang Timer的设计经历了如下阶段：
Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发； Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题 Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO 为什么会发生P和M的绑定和解绑) Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发 我使用的是Go 1.16的版本进行分析
" />
  <meta name="description" content="根据6.3 计时器中的描述，Golang Timer的设计经历了如下阶段：
Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发； Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题 Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO 为什么会发生P和M的绑定和解绑) Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发 我使用的是Go 1.16的版本进行分析
" />
  <meta property="og:locale" content="cn" /><meta property="og:image" content="" />
  

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:6px}.post-content .post-gallery{display:flex;flex-wrap:wrap;gap:6px}.post-content .post-gallery img{margin-right:auto;margin-top:auto;width:calc(50% - 3px)}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}.post-content .post-gallery img{width:100%}}@media screen and (max-width:48em){.posts-category{display:none}}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Carlos的废话集">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  
</head>


<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >Carlos的废话集</a
    >
  </div>
  <div class="header-subtitle">Log something useless, but interesting.</div>
</header>
<div class="row end-md header-items">
  
  <div class="header-item">
    <a href="https://github.com/carlos19960601" target="_blank">Github</a>
  </div>
  
</div>
<div class="row">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Timer源码阅读</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2021-04-22 22:50:29 &#43;0800">
                22 Apr 2021
              </time>
              
            </div>
            <div class="col-xs-6">
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>根据<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/">6.3 计时器</a>中的描述，Golang Timer的设计经历了如下阶段：</p>
<ol>
<li>Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；</li>
<li>Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；</li>
<li>Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；</li>
</ol>
<ul>
<li>Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题</li>
<li>Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO  为什么会发生P和M的绑定和解绑)</li>
<li>Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发</li>
</ul>
<p>我使用的是Go 1.16的版本进行分析</p>
<h1 id="timer包的使用">timer包的使用</h1>
<p>主要分为2类，一次性触发的timer和多次触发的ticker</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestTimer</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">timer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTimer</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// for tm := range timer.C {</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 	t.Log(tm)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 	timer.Reset(time.Second)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// }</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">tm</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">timer</span>.<span style="color:#a6e22e">C</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#a6e22e">tm</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">timer</span>.<span style="color:#a6e22e">Reset</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestAfter</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">tm</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#a6e22e">tm</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestAfterFunc</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">timer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">AfterFunc</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>, <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#e6db74">&#34;我执行了&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">timer</span>.<span style="color:#a6e22e">Stop</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestTicker</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ticker</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTicker</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">tm</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">C</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#a6e22e">tm</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewTicker</span>(<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Ticker</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;non-positive interval for NewTicker&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Give the channel a 1-element time buffer.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If the client falls behind while reading, we drop ticks</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// on the floor until the client catches up.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Time</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Ticker</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">C</span>: <span style="color:#a6e22e">c</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">r</span>: <span style="color:#a6e22e">runtimeTimer</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">when</span>:   <span style="color:#a6e22e">when</span>(<span style="color:#a6e22e">d</span>),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">period</span>: int64(<span style="color:#a6e22e">d</span>),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">f</span>:      <span style="color:#a6e22e">sendTime</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">arg</span>:    <span style="color:#a6e22e">c</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">startTimer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">t</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestTick</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">tm</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Tick</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#a6e22e">tm</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，在for循环中使用的时候需要考虑是否会造成timer的泄漏；具体的示例分析可以参考 <a href="https://mp.weixin.qq.com/s/KSBdPkkvonSES9Z9iggElg">Go 内存泄露之痛，这篇把 Go timer.After 问题根因讲透了！</a></p>
<h1 id="数据结构">数据结构</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewTimer</span>(<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Timer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Time</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Timer</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">C</span>: <span style="color:#a6e22e">c</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">r</span>: <span style="color:#a6e22e">runtimeTimer</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">when</span>: <span style="color:#a6e22e">when</span>(<span style="color:#a6e22e">d</span>),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">f</span>:    <span style="color:#a6e22e">sendTime</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">arg</span>:  <span style="color:#a6e22e">c</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">startTimer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">t</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到NewTimer和NewTicker都会初始化runtimeTimer，差别在于Ticker会比Timer多了period参数。最后调用startTimer将timer添加到底层的最小四叉堆中</p>
<p>runtimeTimer和runtime/time.go#timer结构是保持一致的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">timer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If this timer is on a heap, which P&#39;s heap it is on.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// puintptr rather than *p to match uintptr in the versions</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// of this struct defined in other packages.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pp</span> <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// 当前P的指针</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// each time calling f(arg, now) in the timer goroutine, so f must be</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// a well-behaved function and not block.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// when must be positive on an active timer.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">when</span>   <span style="color:#66d9ef">int64</span>                      <span style="color:#75715e">// 当前计时器被唤醒的时间</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">period</span> <span style="color:#66d9ef">int64</span>                      <span style="color:#75715e">// 两次被唤醒的间隔</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span>      <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">uintptr</span>) <span style="color:#75715e">// 每当计时器被唤醒时都会调用的函数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arg</span>    <span style="color:#66d9ef">interface</span>{}                <span style="color:#75715e">// 计时器被唤醒时调用 f 传入的参数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">seq</span>    <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// What to set the when field to in timerModifiedXX status.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nextwhen</span> <span style="color:#66d9ef">int64</span> <span style="color:#75715e">// 计时器处于 timerModifiedXX 状态时，用于设置 when 字段；</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// The status field holds one of the values below.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">status</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// 计时器的状态</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="添加timer">添加timer</h1>
<p>前面的startTimer方法其实是runtime/time.go中的startTimer方法，通过//go:linkname关联起来的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 把 t 添加到 timer 堆</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// startTimer adds t to the timer heap.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//go:linkname startTimer time.startTimer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">startTimer</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">racerelease</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">t</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">addtimer</span>(<span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>继续调用addtimer方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// addtimer adds a timer to the current P.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This should only be called with a newly created timer.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// That avoids the risk of changing the when field of a timer in some P&#39;s heap,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// which could cause the heap to become unsorted.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addtimer</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// when must be positive. A negative value will cause runtimer to</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// overflow during its delta calculation and never expire other runtime</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// timers. Zero will cause checkTimers to fail to notice the timer.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;timer when must be positive&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">period</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;timer period must be non-negative&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">timerNoStatus</span> { <span style="color:#75715e">// 添加新的timer必须是timerNoStatus</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;addtimer called with initialized timer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">timerWaiting</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">when</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timersLock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cleantimers</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">doaddtimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timersLock</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wakeNetPoller</span>(<span style="color:#a6e22e">when</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>addtimer首先对参数进行了校验，timer的初始化status必须是timerNoStatus(计时器尚未设置状态)，然后将timer的status切换成timerWaiting(等待计时器启动)</p>
<p>然后调用cleantimers(pp)处理P中timers堆顶上已经取消(timerDeleted)或者时间发生改变(timerModifiedEarlier/timerModifiedLater的timer)，对timers进行清理</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 清理堆顶部的timer，与adjusttimers方法类似，只是adjusttimers会遍历搜索的timers</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 注意cleantimers清理的是堆顶部的timer，只要顶部是timerDeleted，timerModifiedEarlier/timerModifiedLater的timer都会处理</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 处理完后会调整堆，再处理堆顶部的timer，所以不只是处理1个timer，</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 当堆前面的timer是timerDeleted，timerModifiedEarlier/timerModifiedLater状态的时候都会进行处理</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// adjusttimers不管是什么状态的timer，都会便利处理一遍</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// cleantimers会出现下面2种状态的变化，也就是清除已经删除的，移动timer0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// timerDeleted -&gt; timerRemoving -&gt; timerRemoved</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// timerModifiedEarlier/timerModifiedLater -&gt; timerMoving -&gt; timerWaiting</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cleantimers</span>(<span style="color:#a6e22e">pp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// This loop can theoretically run for a while, and because</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// it is holding timersLock it cannot be preempted.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If someone is trying to preempt us, just return.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// We can clean the timers later.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">preemptStop</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>[<span style="color:#ae81ff">0</span>] <span style="color:#75715e">// 堆顶，when最小，最早发生的timer</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;cleantimers: bad p&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>); <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerDeleted</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerDeleted --&gt; timerRemoving --&gt; 从堆中删除timer --&gt; timerRemoved</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerRemoving</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">dodeltimer0</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerRemoved</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deletedTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifiedEarlier</span>, <span style="color:#a6e22e">timerModifiedLater</span>: <span style="color:#75715e">// TODO 如果modTimer将非timer0的when改成了比timer0更先触发的时候是怎么处理的</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerMoving --&gt; 调整 timer 的时间 --&gt; timerWaiting</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 此时 timer 被调整为更早或更晚，将原先的 timer 进行删除，再重新添加</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerMoving</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Now we can change the when field.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">nextwhen</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Move t to the right position.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 删除原来的</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">dodeltimer0</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 然后再重新添加</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">doaddtimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">timerModifiedEarlier</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">adjustTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 如果t0之前是timerModifiedEarlier，因为已经调整了t0，所以需要将adjustTimers减1</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerMoving</span>, <span style="color:#a6e22e">timerWaiting</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Head of timers does not need adjustment.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>cleantimers(pp *p)方法会循环处理堆顶部是timerDeleted，timerModifiedEarlier/timerModifiedLater的timer</p>
<ul>
<li>如果是timerDeleted，说明timer已经取消了，从timers堆中删除，重新调整timers堆</li>
<li>如果是timerModifiedEarlier/timerModifiedLater，说明timer的时间发生改变，修改timer的when字段，删除之前的timer，重新添加新的timer</li>
</ul>
<p>cleantimers(pp *p)方法只是对p中的timers堆做了一些清理调整的工作，真正添加是doaddtimer方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// doaddtimer adds t to the current P&#39;s heap.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The caller must have locked the timers for pp.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doaddtimer</span>(<span style="color:#a6e22e">pp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Timers依赖network poller，确保netpoll经初始化了</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Timers rely on the network poller, so make sure the poller</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// has started.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">netpollInited</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">netpollGenericInit</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// 创建timer时没有绑定p，如果p存在的话属于异常情况</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;doaddtimer: P already set in timer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">pp</span>) <span style="color:#75715e">// timer绑定到当前P的堆上</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span> = append(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">siftupTimer</span>(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>, <span style="color:#a6e22e">i</span>) <span style="color:#75715e">// 调整4叉堆</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>[<span style="color:#ae81ff">0</span>] {    <span style="color:#75715e">// 如果新加入的timer是当前p中最新触发的，将t.when保存到pp.timer0When</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timer0When</span>, uint64(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">numTimers</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>doaddtimer方法中判断了netpoll是否初始化了，如果没有对其进行初始化，这里我还没有理解timer和netpoll之间的关系，作为todo，后续再补充</p>
<p>后面就是p的timer之间的绑定，添加到四叉堆，然后平衡四叉堆，这里就不细说了</p>
<p>doaddtimer方法返回后，回到addtimer方法会调用wakeNetPoller方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// wakeNetPoller wakes up the thread sleeping in the network poller if it isn&#39;t</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// going to wake up before the when argument; or it wakes an idle P to service</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// timers and the network poller if there isn&#39;t one already.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">wakeNetPoller</span>(<span style="color:#a6e22e">when</span> <span style="color:#66d9ef">int64</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lastpoll</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// In findrunnable we ensure that when polling the pollUntil</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// field is either zero or the time to which the current</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// poll is expected to run. This can have a spurious wakeup</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// but should never miss a wakeup.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pollerPollUntil</span> <span style="color:#f92672">:=</span> int64(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pollUntil</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pollerPollUntil</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">pollerPollUntil</span> &gt; <span style="color:#a6e22e">when</span> { <span style="color:#75715e">// 网络轮询器poll &gt; timer的触发时间，立即唤醒netpoll</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">netpollBreak</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// There are no threads in the network poller, try to get</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// one there so it can handle new timers.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;plan9&#34;</span> { <span style="color:#75715e">// Temporary workaround - see issue #42303.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">wakep</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// netpollBreak interrupts a kevent.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">netpollBreak</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">netpollWakeSig</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">netpollBreakWr</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>), <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">_EAGAIN</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">_EINTR</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			println(<span style="color:#e6db74">&#34;runtime: netpollBreak write failed with&#34;</span>, <span style="color:#f92672">-</span><span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;runtime: netpollBreak write failed&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>wakeNetPoller方法其实就是向netpoll初始化的全局epfd文件描述符写入了数据（epfd和golang netpoll有关，想了解netpoll的请自行了解）。主要目的是为了唤醒netpoll</p>
<h1 id="停止timer">停止timer</h1>
<p>可以通过Ticker#Stop和Timer#Stop停止timer</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Stop prevents the Timer from firing.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// It returns true if the call stops the timer, false if the timer has already</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// expired or been stopped.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Stop does not close the channel, to prevent a read from the channel succeeding</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// incorrectly.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// To ensure the channel is empty after a call to Stop, check the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// return value and drain the channel.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For example, assuming the program has not received from t.C already:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 	if !t.Stop() {</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 		&lt;-t.C</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 	}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This cannot be done concurrent to other receives from the Timer&#39;s</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// channel or other calls to the Timer&#39;s Stop method.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// has already expired and the function f has been started in its own goroutine;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Stop does not wait for f to complete before returning.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If the caller needs to know whether f is completed, it must coordinate</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// with f explicitly.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Timer</span>) <span style="color:#a6e22e">Stop</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">f</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;time: Stop called on uninitialized Timer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">stopTimer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Stop turns off a ticker. After Stop, no more ticks will be sent.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Stop does not close the channel, to prevent a concurrent goroutine</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// reading from the channel from seeing an erroneous &#34;tick&#34;.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Ticker</span>) <span style="color:#a6e22e">Stop</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stopTimer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后都是调用runtime.stopTimer方法；通过//go:linkname进行关联</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// stopTimer stops a timer.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// It reports whether t was stopped before being run.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//go:linkname stopTimer time.stopTimer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">stopTimer</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">deltimer</span>(<span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 返回的是这个timer在执行前被移除的，已经执行过了就返回false，还没有执行就返回true</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// deltimer deletes the timer t. It may be on some other P, so we can&#39;t</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// actually remove it from the timers heap. We can only mark it as deleted.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// It will be removed in due course by the P whose heap it is on.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Reports whether the timer was removed before it was run.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">deltimer</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>); <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerWaiting</span>, <span style="color:#a6e22e">timerModifiedLater</span>: <span style="color:#75715e">// timer还没启动或修改为更晚的时间</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Prevent preemption while the timer is in timerModifying.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// This could lead to a self-deadlock. See #38070.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquirem</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerWaiting/timerModifiedLater --&gt; timerModifying --&gt; timerDeleted</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerModifying</span>) { <span style="color:#75715e">// TODO 为什么要先切换为timerModifying</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Must fetch t.pp before changing status,</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// as cleantimers in another goroutine</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// can clear t.pp of a timerDeleted timer.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">tpp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>, <span style="color:#a6e22e">timerDeleted</span>) { <span style="color:#75715e">// 置为timerDeleted状态</span>
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tpp</span>.<span style="color:#a6e22e">deletedTimers</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Timer was not yet run.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 修改为timerModifying失败，说明t的状态已经不再是timerWaiting, timerModifiedLater了</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>) <span style="color:#75715e">// 下一次再来处理</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifiedEarlier</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Prevent preemption while the timer is in timerModifying.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// This could lead to a self-deadlock. See #38070.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquirem</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerModifiedEarlier --&gt; timerModifying --&gt; timerDeleted</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerModifying</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Must fetch t.pp before setting status</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// to timerDeleted.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">tpp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tpp</span>.<span style="color:#a6e22e">adjustTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// timerModifiedEarlier的timer被stop了，所以需要将adjustTimers-1</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>, <span style="color:#a6e22e">timerDeleted</span>) {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tpp</span>.<span style="color:#a6e22e">deletedTimers</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Timer was not yet run.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>) <span style="color:#75715e">// 下一次再来处理</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerDeleted</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerRemoved</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Timer was already run.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Timer 已经运行</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerRunning</span>, <span style="color:#a6e22e">timerMoving</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 正在执行或被移动了，等待完成，下一次再来处理</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// The timer is being run or moved, by a different P.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Wait for it to complete.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">osyield</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerNoStatus</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Removing timer that was never added or</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// has already been run. Also see issue 21874.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifying</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 同时调用了deltimer，modtimer；等待其他调用完成，下一次再来处理</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Simultaneous calls to deltimer and modtimer.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Wait for the other call to complete.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">osyield</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从deltimer方法中可以看出，timer会发生如下的状态变化</p>
<ul>
<li>
<p>timerWaiting, timerModifiedLater → timerModifying → timerDeleted</p>
<p>如果要停止的timer状态是timerWaiting, timerModifiedLater，说明timer还没有执行，将状态切换成timerModifying改变中，最后将状态切换成timerDeleted</p>
</li>
<li>
<p>timerModifiedEarlier → timerModifying &ndash;&gt; timerDeleted</p>
<p>如果要停止的timer状态是timerModifiedEarlier，说明timer的时间被改变过，比如reset过，将状态切换成timerModifying改变中，最后将状态切换成timerDeleted</p>
</li>
<li>
<p>timerDeleted, timerRemoving, timerRemoved → 什么都不做</p>
</li>
<li>
<p>timerRunning, timerMoving → 等待操作完成</p>
</li>
<li>
<p>timerNoStatus → 直接返回</p>
</li>
<li>
<p>timerModifying → 等待操作完成</p>
</li>
</ul>
<p>我在这里有2个问题</p>
<ol>
<li>
<p>为什么timer状态变化的时候需要需要先改为timerModifying然后再修改成最后的状态？</p>
<p>答：首先声明这个只是我个人的理解可能会存在错误；在timer的status状态常量这有这么一段注释</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// We don&#39;t permit calling addtimer/deltimer/modtimer/resettimer simultaneously,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// but adjusttimers and runtimer can be called at the same time as any of those.</span>
</span></span></code></pre></div><p>为了保证addtimer/deltimer/modtimer/resettimer不能被同时调用，所以需要timerModifying这个状态</p>
</li>
<li>
<p>deltimer并没有从 四叉堆中删除timer，只是将timer的状态切换成timerDeleted，这个是为什么？</p>
<p>这个在deltimer的注释上已经说明了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// deltimer deletes the timer t. It may be on some other P, so we can&#39;t</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// actually remove it from the timers heap. We can only mark it as deleted.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// It will be removed in due course by the P whose heap it is on.</span>
</span></span></code></pre></div><p>deltimer删除的timer可能在其他P上，以为调度循环的 时候不仅会从其他P上偷G，还会偷timer，所以只是对timer进行标记，在timer所在的P中，通过 cleantimers/adjusttimers等方法来真正从堆中删除</p>
</li>
</ol>
<h1 id="其他timer的方法">其他timer的方法</h1>
<p>分析了2个timer的方法后，就不再逐个看其他的方法了，大概都差不多，都是对timers堆中的timer状态进行修改，timers的调整等</p>
<h2 id="修改timer">修改timer</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// modtimer modifies an existing timer.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Reports whether the timer was modified before it was run.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">modtimer</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>, <span style="color:#a6e22e">when</span>, <span style="color:#a6e22e">period</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">uintptr</span>), <span style="color:#a6e22e">arg</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">seq</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">when</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;timer when must be positive&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">period</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;timer period must be non-negative&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">status</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#a6e22e">timerNoStatus</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wasRemoved</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pending</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">loop</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>); <span style="color:#a6e22e">status</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerWaiting</span>, <span style="color:#a6e22e">timerModifiedEarlier</span>, <span style="color:#a6e22e">timerModifiedLater</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Prevent preemption while the timer is in timerModifying.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// This could lead to a self-deadlock. See #38070.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mp</span> = <span style="color:#a6e22e">acquirem</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerWaiting, timerModifiedEarlier, timerModifiedLater --&gt; timerModifying</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pending</span> = <span style="color:#66d9ef">true</span> <span style="color:#75715e">// timer not yet run</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loop</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerNoStatus</span>, <span style="color:#a6e22e">timerRemoved</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Prevent preemption while the timer is in timerModifying.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// This could lead to a self-deadlock. See #38070.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mp</span> = <span style="color:#a6e22e">acquirem</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Timer was already run and t is no longer in a heap.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Act like addtimer.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerNoStatus, timerRemoved --&gt; timerModifying</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">wasRemoved</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pending</span> = <span style="color:#66d9ef">false</span> <span style="color:#75715e">// timer already run or stopped</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loop</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerDeleted</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Prevent preemption while the timer is in timerModifying.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// This could lead to a self-deadlock. See #38070.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mp</span> = <span style="color:#a6e22e">acquirem</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// timerDeleted --&gt; timerModifying</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">deletedTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pending</span> = <span style="color:#66d9ef">false</span> <span style="color:#75715e">// timer already stopped</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loop</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerRunning</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerMoving</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// The timer is being run or moved, by a different P.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Wait for it to complete.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">osyield</span>() <span style="color:#75715e">// 等待状态改变</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifying</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Multiple simultaneous calls to modtimer.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Wait for the other call to complete.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">osyield</span>() <span style="color:#75715e">// 等待状态改变</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">period</span> = <span style="color:#a6e22e">period</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">f</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">arg</span> = <span style="color:#a6e22e">arg</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">seq</span> = <span style="color:#a6e22e">seq</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">wasRemoved</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> = <span style="color:#a6e22e">when</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timersLock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">doaddtimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timersLock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>, <span style="color:#a6e22e">timerWaiting</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wakeNetPoller</span>(<span style="color:#a6e22e">when</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// The timer is in some other P&#39;s heap, so we can&#39;t change</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// the when field. If we did, the other P&#39;s heap would</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// be out of order. So we put the new when value in the</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// nextwhen field, and let the other P set the when field</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// when it is prepared to resort the heap.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">nextwhen</span> = <span style="color:#a6e22e">when</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newStatus</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#a6e22e">timerModifiedLater</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">when</span> &lt; <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">newStatus</span> = <span style="color:#a6e22e">timerModifiedEarlier</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tpp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Update the adjustTimers field.  Subtract one if we</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// are removing a timerModifiedEarlier, add one if we</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// are adding a timerModifiedEarlier.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">adjust</span> <span style="color:#f92672">:=</span> int32(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">status</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">timerModifiedEarlier</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">adjust</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newStatus</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">timerModifiedEarlier</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">adjust</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">updateTimerModifiedEarliest</span>(<span style="color:#a6e22e">tpp</span>, <span style="color:#a6e22e">when</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">adjust</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tpp</span>.<span style="color:#a6e22e">adjustTimers</span>, <span style="color:#a6e22e">adjust</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Set the new status of the timer.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerModifying</span>, <span style="color:#a6e22e">newStatus</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If the new status is earlier, wake up the poller.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newStatus</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">timerModifiedEarlier</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">wakeNetPoller</span>(<span style="color:#a6e22e">when</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pending</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="调整timer">调整timer</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 与cleantimers类似，只是 cleantimers 只处理队列头部的timer</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// adjusttimers looks through the timers in the current P&#39;s heap for</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// any timers that have been modified to run earlier, and puts them in</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the correct place in the heap. While looking for those timers,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// it also moves timers that have been modified to run later,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// and removes deleted timers. The caller must have locked the timers for pp.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adjusttimers</span>(<span style="color:#a6e22e">pp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">now</span> <span style="color:#66d9ef">int64</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">adjustTimers</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">verifyTimers</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">verifyTimerHeap</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// There are no timers to adjust, so it is safe to clear</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// timerModifiedEarliest. Do so in case it is stale.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Everything will work if we don&#39;t do this,</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// but clearing here may save future calls to adjusttimers.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timerModifiedEarliest</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If we haven&#39;t yet reached the time of the first timerModifiedEarlier</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// timer, don&#39;t do anything. This speeds up programs that adjust</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// a lot of timers back and forth if the timers rarely expire.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// We&#39;ll postpone looking through all the adjusted timers until</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// one would actually expire.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">first</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timerModifiedEarliest</span>); <span style="color:#a6e22e">first</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> int64(<span style="color:#a6e22e">first</span>) &gt; <span style="color:#a6e22e">now</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">verifyTimers</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">verifyTimerHeap</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// We are going to clear all timerModifiedEarlier timers.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timerModifiedEarliest</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">moved</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">loop</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;adjusttimers: bad p&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>); <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerDeleted</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerRemoving</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">dodeltimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerRemoved</span>) {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deletedTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Look at this heap position again.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifiedEarlier</span>, <span style="color:#a6e22e">timerModifiedLater</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerMoving</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Now we can change the when field.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">nextwhen</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Take t off the heap, and hold onto it.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// We don&#39;t add it back yet because the</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// heap manipulation could cause our</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// loop to skip some other timer.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">dodeltimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">moved</span> = append(<span style="color:#a6e22e">moved</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">timerModifiedEarlier</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">adjustTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); int32(<span style="color:#a6e22e">n</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loop</span>
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Look at this heap position again.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerNoStatus</span>, <span style="color:#a6e22e">timerRunning</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerRemoved</span>, <span style="color:#a6e22e">timerMoving</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerWaiting</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// OK, nothing to do.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifying</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Check again after modification is complete.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">osyield</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">moved</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">addAdjustedTimers</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">moved</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">verifyTimers</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">verifyTimerHeap</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="运行timer">运行timer</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// runtimer 检查timers四叉堆顶部的timer</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// runtimer examines the first timer in timers. If it is ready based on now,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// it runs the timer and removes or updates it.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// when the first timer should run.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The caller must have locked the timers for pp.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If a timer is run, this will temporarily unlock the timers.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//go:systemstack</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">runtimer</span>(<span style="color:#a6e22e">pp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">now</span> <span style="color:#66d9ef">int64</span>) <span style="color:#66d9ef">int64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;runtimer: bad p&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>); <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerWaiting</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> &gt; <span style="color:#a6e22e">now</span> { <span style="color:#75715e">// 还没到时间执行</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Not ready to run.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 该执行这个timer了</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerRunning</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Note that runOneTimer may temporarily unlock</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// pp.timersLock.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">runOneTimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">now</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerDeleted</span>: <span style="color:#75715e">// 删除已经执行了的timer</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerRemoving</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">dodeltimer0</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerRemoved</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deletedTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifiedEarlier</span>, <span style="color:#a6e22e">timerModifiedLater</span>: <span style="color:#75715e">// 调整timerModifiedEarlier, timerModifiedLater timer的时间</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">timerMoving</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">when</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">nextwhen</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">dodeltimer0</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">doaddtimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">timerModifiedEarlier</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">adjustTimers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">timerMoving</span>, <span style="color:#a6e22e">timerWaiting</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerModifying</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Wait for modification to complete.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">osyield</span>() <span style="color:#75715e">// 等到其他操作结束</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerNoStatus</span>, <span style="color:#a6e22e">timerRemoved</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Should not see a new or inactive timer on the heap.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">timerRunning</span>, <span style="color:#a6e22e">timerRemoving</span>, <span style="color:#a6e22e">timerMoving</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// These should only be set when timers are locked,</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// and we didn&#39;t do it.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">badTimer</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="触发timer">触发timer</h1>
<p>前面介绍的都是将 timer加入到 堆中，从堆中删除这些，那么timer时间到了，是怎么触发的呢？</p>
<p>触发timer一定会执行前面所说的runtimer方法，可以发现runtimer是在checkTimers方法中被调用的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// checkTimers runs any timers for the P that are ready.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If now is not 0 it is the current time.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// It returns the current time or 0 if it is not known,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// and the time when the next timer should run or 0 if there is no next timer,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// and reports whether it ran any timers.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If the time when the next timer should run is not 0,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// it is always larger than the returned time.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We pass now in and out to avoid extra calls of nanotime.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//go:yeswritebarrierrec</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">checkTimers</span>(<span style="color:#a6e22e">pp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">now</span> <span style="color:#66d9ef">int64</span>) (<span style="color:#a6e22e">rnow</span>, <span style="color:#a6e22e">pollUntil</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">ran</span> <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If it&#39;s not yet time for the first timer, or the first adjusted</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// timer, then there is nothing to do.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> int64(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timer0When</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nextAdj</span> <span style="color:#f92672">:=</span> int64(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timerModifiedEarliest</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">nextAdj</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nextAdj</span> &lt; <span style="color:#a6e22e">next</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">nextAdj</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// 没有timer需要执行和调整</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// No timers to run or adjust.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">now</span>, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">now</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">now</span> = <span style="color:#a6e22e">nanotime</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">now</span> &lt; <span style="color:#a6e22e">next</span> { <span style="color:#75715e">// 最快的 timer还没到 执行的时间</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Next timer is not ready to run, but keep going</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// if we would clear deleted timers.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// This corresponds to the condition below where</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// we decide whether to call clearDeletedTimers.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pp</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">||</span> int(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deletedTimers</span>)) <span style="color:#f92672">&lt;=</span> int(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">numTimers</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">now</span>, <span style="color:#a6e22e">next</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timersLock</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">adjusttimers</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">now</span>)    <span style="color:#75715e">// 删除已经执行的timer，调整timerModifiedEarlier 和 timerModifiedLater 的计时器的时间</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>) &gt; <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// 执行所有到期的timer</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Note that runtimer may temporarily unlock</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// pp.timersLock.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tw</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runtimer</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#a6e22e">now</span>); <span style="color:#a6e22e">tw</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tw</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">pollUntil</span> = <span style="color:#a6e22e">tw</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ran</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// If this is the local P, and there are a lot of deleted timers,</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// clear them out. We only do this for the local P to reduce</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// lock contention on timersLock.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前 Goroutine 的处理器和传入的处理器相同,并且处理器中删除的计时器是堆中计时器的 1/4 以上，</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pp</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">&amp;&amp;</span> int(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deletedTimers</span>)) &gt; len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timers</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">clearDeletedTimers</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">timersLock</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">now</span>, <span style="color:#a6e22e">pollUntil</span>, <span style="color:#a6e22e">ran</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而checkTimers在findrunnable和schedule中被调用，而这2个方法都是runtime调度会执行的方法（PS：runtime调度也是一个很重要的知识点，有兴趣的可以自行了解）</p>
<p>除了runtime调度时会执行timer外，系统监控sysmon也会执行timer，其实这里我没有理解，所以这里直接用draveness大佬文章中的说明</p>
<p>系统监控函数 runtime.sysmon 也可能会触发函数的计时器，下面的代码片段中省略了大量与计时器无关的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sysmon</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">now</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nanotime</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">next</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">timeSleepUntil</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">lastpoll</span> <span style="color:#f92672">:=</span> int64(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lastpoll</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">netpollinited</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">lastpoll</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">lastpoll</span><span style="color:#f92672">+</span><span style="color:#ae81ff">10</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1000</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1000</span> &lt; <span style="color:#a6e22e">now</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lastpoll</span>, uint64(<span style="color:#a6e22e">lastpoll</span>), uint64(<span style="color:#a6e22e">now</span>))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">list</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">netpoll</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">list</span>.<span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">incidlelocked</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">injectglist</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">list</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">incidlelocked</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">next</span> &lt; <span style="color:#a6e22e">now</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">startm</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>调用 <code>[runtime.timeSleepUntil](https://draveness.me/golang/tree/runtime.timeSleepUntil)</code> 获取计时器的到期时间以及持有该计时器的堆；</li>
<li>如果超过 10ms 的时间没有轮询，调用 <code>[runtime.netpoll](https://draveness.me/golang/tree/runtime.netpoll)</code> 轮询网络；</li>
<li>如果当前有应该运行的计时器没有执行，可能存在无法被抢占的处理器，这时我们应该启动新的线程处理计时器；</li>
</ol>
<p>在上述过程中 <code>[runtime.timeSleepUntil](https://draveness.me/golang/tree/runtime.timeSleepUntil)</code> 会遍历运行时的全部处理器并查找下一个需要执行的计时器。</p>
<h1 id="遗留问题">遗留问题</h1>
<p>最后是我还存在的问题</p>
<ol>
<li>
<p>sysmon中为什么会触发timer</p>
</li>
<li>
<p>addtimer方法中调用了wakeNetPoller(when)方法唤醒netpoll，但是netpoll()方法中对netpollBreakRd的处理并没有发现与timer有啥关系</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// netpoll checks for ready network connections.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Returns list of goroutines that become runnable.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// delay &lt; 0: blocks indefinitely</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// delay == 0: does not block, just polls</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// delay &gt; 0: block for up to that many nanoseconds</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// delay &lt; 0 无限block等待</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// delay == 0 不会block</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// delay block 最多delay时间</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// runtime.netpoll 返回的 Goroutine 列表都会被 runtime.injectglist 注入到处理器或者全局的运行队列上。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为系统监控 Goroutine 直接运行在线程上，所以它获取的 Goroutine 列表会直接加入全局的运行队列，</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 其他 Goroutine 获取的列表都会加入 Goroutine 所在处理器的运行队列上。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">netpoll</span>(<span style="color:#a6e22e">delay</span> <span style="color:#66d9ef">int64</span>) <span style="color:#a6e22e">gList</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">epfd</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> { <span style="color:#75715e">// 没有epfd 相当于netpoll没有初始化</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gList</span>{}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">waitms</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delay</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">waitms</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delay</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">waitms</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delay</span> &lt; <span style="color:#ae81ff">1e6</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">waitms</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delay</span> &lt; <span style="color:#ae81ff">1e15</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">waitms</span> = int32(<span style="color:#a6e22e">delay</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">1e6</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// An arbitrary cap on how long to wait for a timer.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 1e9 ms == ~11.5 days.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">waitms</span> = <span style="color:#ae81ff">1e9</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">events</span> [<span style="color:#ae81ff">128</span>]<span style="color:#a6e22e">epollevent</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">retry</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 等待文件描述符转换成可读或者可写</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">epollwait</span>(<span style="color:#a6e22e">epfd</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">events</span>[<span style="color:#ae81ff">0</span>], int32(len(<span style="color:#a6e22e">events</span>)), <span style="color:#a6e22e">waitms</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// 如果返回了负值，可能会返回空的 Goroutine 列表或者重新调用 epollwait 陷入等待：</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">_EINTR</span> {
</span></span><span style="display:flex;"><span>			println(<span style="color:#e6db74">&#34;runtime: epollwait on fd&#34;</span>, <span style="color:#a6e22e">epfd</span>, <span style="color:#e6db74">&#34;failed with&#34;</span>, <span style="color:#f92672">-</span><span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;runtime: netpoll failed&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// If a timed sleep was interrupted, just return to</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// recalculate how long we should sleep now.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">waitms</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gList</span>{}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">retry</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当 epollwait 系统调用返回的值大于 0 时，意味着被监控的文件描述符出现了待处理的事件</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">toRun</span> <span style="color:#a6e22e">gList</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> int32(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ev</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">events</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// runtime.netpollBreak 触发的事件</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">**</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">data</span>)) <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">netpollBreakRd</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_EPOLLIN</span> {
</span></span><span style="display:flex;"><span>				println(<span style="color:#e6db74">&#34;runtime: netpoll: break fd ready for&#34;</span>, <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;runtime: netpoll: break fd ready for something unexpected&#34;</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delay</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// netpollBreak could be picked up by a</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// nonblocking poll. Only read the byte</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// if blocking.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">tmp</span> [<span style="color:#ae81ff">16</span>]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">read</span>(int32(<span style="color:#a6e22e">netpollBreakRd</span>), <span style="color:#a6e22e">noescape</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">0</span>])), int32(len(<span style="color:#a6e22e">tmp</span>)))
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">netpollWakeSig</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 另一种是其他文件描述符的正常读写事件</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mode</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span><span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">_EPOLLIN</span>|<span style="color:#a6e22e">_EPOLLRDHUP</span>|<span style="color:#a6e22e">_EPOLLHUP</span>|<span style="color:#a6e22e">_EPOLLERR</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mode</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;r&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span><span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">_EPOLLOUT</span>|<span style="color:#a6e22e">_EPOLLHUP</span>|<span style="color:#a6e22e">_EPOLLERR</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mode</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;w&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mode</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">pd</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">**</span><span style="color:#a6e22e">pollDesc</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">pd</span>.<span style="color:#a6e22e">everr</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">_EPOLLERR</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pd</span>.<span style="color:#a6e22e">everr</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">netpollready</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">toRun</span>, <span style="color:#a6e22e">pd</span>, <span style="color:#a6e22e">mode</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">toRun</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>draveness大佬文章的评论中也有人提到这个疑问，但是还是未能理解，我也加入 了<a href="https://github.com/draveness/blog-comments/issues/152#issuecomment-824642345">讨论</a>，期待后续的解答</p>
</li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/">6.3 计时器</a></li>
<li><a href="https://www.luozhiyun.com/archives/458">Go中定时器实现原理及源码解析</a></li>
<li><a href="https://mp.weixin.qq.com/s/gxX-q2EvgWZEWe-deRITSw">难以驾驭的 Go timer，一文带你参透计时器的奥秘</a></li>
<li><a href="http://xiaorui.cc/archives/6483">go1.14基于netpoll优化timer定时器实现原理</a></li>
<li><a href="https://www.youtube.com/watch?v=XJx0eTP-y9I">https://www.youtube.com/watch?v=XJx0eTP-y9I</a></li>
</ul>
        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-tags">
              <a href="/tags/golang/">
                Golang
              </a>
            </div>
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          



          
          
          <div style="height: 50px;"></div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>