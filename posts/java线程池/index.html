<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.140.0">

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" />
  <link rel="canonical" href="https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" /><link rel="alternate" type="application/atom+xml" href="https://carlos19960601.github.io/index.xml" title="Carlos的废话集">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/carlos19960601.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "Java线程池",
      "headline" : "Java线程池",
      "description" : "线程池是什么？ 线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。\n",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2020",
      "datePublished": "2020-12-16 12:55:05 \u002b0800 \u002b0800",
      "dateModified" : "2020-12-16 12:55:05 \u002b0800 \u002b0800",
      "url" : "https:\/\/carlos19960601.github.io\/posts\/java%E7%BA%BF%E7%A8%8B%E6%B1%A0\/",
      "keywords" : [ "Java", ]
  }
</script>
<title>Java线程池</title>
  <meta property="og:title" content="Java线程池" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="线程池是什么？ 线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
" />
  <meta name="description" content="线程池是什么？ 线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
" />
  <meta property="og:locale" content="cn" /><meta property="og:image" content="" />
  

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:6px}.post-content .post-gallery{display:flex;flex-wrap:wrap;gap:6px}.post-content .post-gallery img{margin-right:auto;margin-top:auto;width:calc(50% - 3px)}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}.post-content .post-gallery img{width:100%}}@media screen and (max-width:48em){.posts-category{display:none}}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Carlos的废话集">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  
</head>


<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >Carlos的废话集</a
    >
  </div>
  <div class="header-subtitle">Log something useless, but interesting.</div>
</header>
<div class="row end-md header-items">
  
  <div class="header-item">
    <a href="https://github.com/carlos19960601" target="_blank">Github</a>
  </div>
  
</div>
<div class="row">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Java线程池</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2020-12-16 12:55:05 &#43;0800">
                16 Dec 2020
              </time>
              
            </div>
            <div class="col-xs-6">
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <h4 id="线程池是什么">线程池是什么？</h4>
<p>线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p>
<h4 id="线程池的作用">线程池的作用</h4>
<p>在面向对象的编程过程中，创建对象和销毁对象是非常消耗时间和资源的。因此想要最小化这种消耗的一种思想就是『池化资源』。线程池就是这样的一种思想。我们通过重用线程池中的资源来减少创建和销毁线程所需要耗费的时间和资源。</p>
<p>线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用；另一个作用是可根据系统情况调整执行的线程数量，防止消耗过多内存。另外，通过线程池，能有效的控制线程的最大并发数，提高系统资源利用率，同时避免过多的资源竞争，避免堵塞。</p>
<p>线程池的优点总结如下几个方面：</p>
<ul>
<li>线程复用</li>
<li>控制最大并发数</li>
<li>管理线程</li>
</ul>
<h4 id="线程池的组成">线程池的组成</h4>
<p>一般的线程池主要分为以下4个组成部分：</p>
<ol>
<li>线程池管理器：用于创建并管理线程池</li>
<li>工作线程：线程池中的线程</li>
<li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li>
<li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li>
</ol>
<h4 id="线程池的常见应用场景">线程池的常见应用场景</h4>
<p>许多服务器应用常常需要处理大量而短小的请求（例如，Web 服务器，数据库服务器等等），通常它们收到的请求数量很大，一个简单的模型是，当服务器收到来自远程的请求时，为每一个请求开启一个线程，在请求完毕之后再对线程进行销毁。这样处理带来的问题是，创建和销毁线程所消耗的时间往往比任务本身所需消耗的资源要大得多。那么应该怎么办呢？</p>
<p>线程池为线程生命周期开销问题和资源不足问题提供了解决方案。我们可以通过线程池做到线程复用，不需要频繁的创建和销毁线程，让线程池中的线程一直存在于线程池中，然后线程从任务队列中取得任务来执行。而且这样做的另一个好处有，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。</p>
<h4 id="java线程池的简介">Java线程池的简介</h4>
<p>Java中提供了实现线程池的框架Executor，并且提供了许多种类的线程池，接下来的文章中将会做详细介绍。</p>
<h4 id="java线程池框架">Java线程池框架</h4>
<p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask这几个类。</p>
<p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/p798.jpg" alt="Java线程池框架"></p>
<ul>
<li>Executor：所有线程池的接口，只有一个方法</li>
<li>Executors：Executor 的工厂类，提供了创建各种不同线程池的方法，返回的线程池都实现了ExecutorService 接口</li>
<li>ThreadPoolExecutor：线程池的具体实现类，一般所有的线程池都是基于这个类实现的</li>
</ul>
<p>其中ThreadPoolExecutor的构造方法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize,
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">int</span> maximumPoolSize,
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">long</span> keepAliveTime,
</span></span><span style="display:flex;"><span>                              TimeUnit unit,
</span></span><span style="display:flex;"><span>                              BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
</span></span><span style="display:flex;"><span>             Executors.<span style="color:#a6e22e">defaultThreadFactory</span>(), defaultHandler);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>corePoolSize：线程池的核心线程数</li>
<li>maximumPoolSize：线程池中允许的最大线程数</li>
<li>keepAliveTime：空闲线程结束的超时时间</li>
<li>unit：是一个枚举，它表示的是 keepAliveTime 的单位</li>
<li>workQueue：工作队列，用于任务的存放</li>
</ul>
<h4 id="java线程池的工作过程">Java线程池的工作过程</h4>
<p>Java线程池的工作过程如下：</p>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>
</ul>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
<h4 id="常见的java线程池">常见的Java线程池</h4>
<p>生成线程池使用的是Executors的工厂方法，以下是常见的 Java 线程池：</p>
<h5 id="singlethreadexecutor">SingleThreadExecutor</h5>
<p>SingleThreadExecutor是单个线程的线程池，即线程池中每次只有一个线程在运行，单线程串行执行任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newSingleThreadExecutor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> FinalizableDelegatedExecutorService
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">new</span> ThreadPoolExecutor(1, 1,
</span></span><span style="display:flex;"><span>                                0L, TimeUnit.<span style="color:#a6e22e">MILLISECONDS</span>,
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span>()));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="fixedthreadpool">FixedThreadPool</h5>
<p>FixedThreadPool是固定数量的线程池，只有核心线程，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列，直到前面的任务完成才继续执行。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newFixedThreadPool</span>(<span style="color:#66d9ef">int</span> nThreads) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor(nThreads, nThreads,
</span></span><span style="display:flex;"><span>                                  0L, TimeUnit.<span style="color:#a6e22e">MILLISECONDS</span>,
</span></span><span style="display:flex;"><span>                                  <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="cachedthreadpool">CachedThreadPool</h4>
<p>CachedThreadPool是可缓存线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。其中，SynchronousQueue是一个是缓冲区为1的阻塞队列。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newCachedThreadPool</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor(0, Integer.<span style="color:#a6e22e">MAX_VALUE</span>,
</span></span><span style="display:flex;"><span>                                  60L, TimeUnit.<span style="color:#a6e22e">SECONDS</span>,
</span></span><span style="display:flex;"><span>                                  <span style="color:#66d9ef">new</span> SynchronousQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="scheduledthreadpool">ScheduledThreadPool</h4>
<p>ScheduledThreadPool是核心线程池固定，大小无限制的线程池，支持定时和周期性的执行线程。创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>(corePoolSize, Integer.<span style="color:#a6e22e">MAX_VALUE</span>, 0, NANOSECONDS,
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">new</span> DelayedWorkQueue());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="java-线程池的创建和使用">Java 线程池的创建和使用</h4>
<p>我们可以通过Executors的工厂方法来创建一个线程池。但是我们该如何让线程池执行任务呢？</p>
<p>线程池最常用的提交任务的方法有两种：</p>
<ul>
<li>execute：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ExecutorService.<span style="color:#a6e22e">execute</span>(Runnable runable)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></div><ul>
<li>submit：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FutureTask task <span style="color:#f92672">=</span> ExecutorService.<span style="color:#a6e22e">submit</span>(Runnable runnable);
</span></span><span style="display:flex;"><span>FutureTask<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> task <span style="color:#f92672">=</span> ExecutorService.<span style="color:#a6e22e">submit</span>(Runnable runnable,T Result);
</span></span><span style="display:flex;"><span>FutureTask<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> task <span style="color:#f92672">=</span> ExecutorService.<span style="color:#a6e22e">submit</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> callable);
</span></span></code></pre></div><p>可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到结果。submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。</p>
<p>下面的示例代码演示了如何创建一个线程池，并且使用它管理线程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">extends</span> Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getName</span>() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is running.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestSingleThreadExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//创建一个可重用固定线程数的线程池</span>
</span></span><span style="display:flex;"><span>        ExecutorService pool <span style="color:#f92672">=</span> Executors.<span style="color:#a6e22e">newFixedThreadPool</span>(2);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//创建实现了Runnable接口对象</span>
</span></span><span style="display:flex;"><span>        Thread tt1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        Thread tt2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        Thread tt3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        Thread tt4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        Thread tt5 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将线程放入池中并执行</span>
</span></span><span style="display:flex;"><span>        pool.<span style="color:#a6e22e">execute</span>(tt1);
</span></span><span style="display:flex;"><span>        pool.<span style="color:#a6e22e">execute</span>(tt2);
</span></span><span style="display:flex;"><span>        pool.<span style="color:#a6e22e">execute</span>(tt3);
</span></span><span style="display:flex;"><span>        pool.<span style="color:#a6e22e">execute</span>(tt4);
</span></span><span style="display:flex;"><span>        pool.<span style="color:#a6e22e">execute</span>(tt5);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//关闭</span>
</span></span><span style="display:flex;"><span>        pool.<span style="color:#a6e22e">shutdown</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>运行结果：</p>
<pre tabindex="0"><code>pool-1-thread-1 is running.
pool-1-thread-2 is running.
pool-1-thread-1 is running.
pool-1-thread-2 is running.
pool-1-thread-1 is running.
</code></pre><h3 id="java线程池原理">Java线程池原理</h3>
<p>这篇文章会分别从这三个方面，结合具体的代码实现来剖析 Java 线程池的原理以及它的具体实现。</p>
<h4 id="线程复用">线程复用</h4>
<p>我们知道线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用。这个功能就是线程复用。想要了解 Java 线程池是如何进行线程复用的，我们首先需要了解线程的生命周期。</p>
<h4 id="线程生命周期">线程生命周期</h4>
<p>下图描述了线程完整的生命周期：</p>
<p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/p799.jpg" alt="线程生命周期"></p>
<p>在一个线程完整的生命周期中，它可能经历五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、终止（Zombie）。</p>
<p>在 Java中，Thread 通过new来新建一个线程，这个过程是是初始化一些线程信息，如线程名、id、线程所属group等，可以认为只是个普通的对象。调用Thread的start()后Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true，之后如果再次调用start()方法就会有异常。</p>
<p>处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于 JVM 里线程调度器的调度。当线程获取CPU后，run()方法会被调用。不要自己去调用Thread的run()方法。之后根据CPU的调度，线程就会在就绪—运行—阻塞间切换，直到run()方法结束或其他方式停止线程，进入终止状态。</p>
<p>因此，如果要实现线程的复用，我们必须要保证线程池中的线程保持存活状态（就绪、运行、阻塞）。接下来，我们就来看看ThreadPoolExecutor是如何实现线程复用的。</p>
<h4 id="worker-类">Worker 类</h4>
<p>ThreadPoolExecutor主要是通过一个类来控制线程复用的：Worker 类。</p>
<p>我们来看一下简化后的 Worker 类代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Worker</span> <span style="color:#66d9ef">implements</span> Runnable {
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread thread;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    Runnable firstTask;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    Worker(Runnable firstTask) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> firstTask;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> getThreadFactory().<span style="color:#a6e22e">newThread</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        runWorker(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runWorker</span>(Worker w) {
</span></span><span style="display:flex;"><span>        Runnable task <span style="color:#f92672">=</span> w.<span style="color:#a6e22e">firstTask</span>;
</span></span><span style="display:flex;"><span>        w.<span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (task <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> (task <span style="color:#f92672">=</span> getTask()) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>             task.<span style="color:#a6e22e">run</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从代码中，我们可以看到 Worker 实现了 Runnable 接口，并且它还有一个 Thread成员变量 thread，这个 thread 就是要开启运行的线程。我们看到 Worker 的构造方法中传递了一个 Runnable 参数，同时它把自己作为参数传入 newThread()，这样的话，当 Thread 的start()方法得到调用时，执行的其实是 Worker 的run()方法，即runWorker()方法。</p>
<p>runWorker()方法之中有一个 while 循环，使用 getTask()来获取任务，并执行。接下来，我们将会看到getTask()是如何获取到 Runnable 对象的。</p>
<h4 id="gettask">getTask()</h4>
<p>我们来看一下简化后的getTask()代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Runnable <span style="color:#a6e22e">getTask</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(一些特殊情况) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  Runnable r <span style="color:#f92672">=</span> workQueue.<span style="color:#a6e22e">take</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以看到任务是从 workQueue中获取的，这个 workQueue 就是我们初始化 ThreadPoolExecutor 时存放任务的 BlockingQueue队列，这个队列里的存放的都是将要执行的 Runnable任务。因为 BlockingQueue 是个阻塞队列，BlockingQueue.take()返回的是空，则进入等待状态直到 BlockingQueue 有新的对象被加入时唤醒阻塞的线程。所以一般情况下，Thread的run()方法不会结束，而是不断执行workQueue里的Runnable任务，这就达到了线程复用的目的了。</p>
<h4 id="控制最大并发数">控制最大并发数</h4>
<p>我们现在已经知道了 Java 线程池是如何做到线程复用的了，但是Runnable 是什么时候被放入 workQueue 队列中的呢，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？从上面的分析中我们可以看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？它又是如何做到控制最大并发数的呢？</p>
<h4 id="execute">execute()</h4>
<p>通过查看 execute()就能解答上述的一些问题，同样是简化后的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span>(Runnable command) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (command <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当前线程数 &lt; corePoolSize</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (workerCountOf(c) <span style="color:#f92672">&lt;</span> corePoolSize) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 直接启动新的线程。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (addWorker(command, <span style="color:#66d9ef">true</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> ctl.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 活动线程数 &gt;= corePoolSize</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// runState为RUNNING &amp;&amp; 队列未满</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (isRunning(c) <span style="color:#f92672">&amp;&amp;</span> workQueue.<span style="color:#a6e22e">offer</span>(command)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> recheck <span style="color:#f92672">=</span> ctl.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 再次检验是否为RUNNING状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRunning(recheck) <span style="color:#f92672">&amp;&amp;</span> remove(command))
</span></span><span style="display:flex;"><span>      reject(command);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 采用线程池指定的策略拒绝任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 两种情况：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1.非RUNNING状态拒绝新的任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>addWorker(command, <span style="color:#66d9ef">false</span>))
</span></span><span style="display:flex;"><span>        reject(command);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="addworker">addWorker()</h4>
<p>我们再来看一下addWorker()的简化代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">addWorker</span>(Runnable firstTask, <span style="color:#66d9ef">boolean</span> core) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf(c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (wc <span style="color:#f92672">&gt;=</span> (core <span style="color:#f92672">?</span> corePoolSize : maximumPoolSize)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Worker(firstTask);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread t <span style="color:#f92672">=</span> w.<span style="color:#a6e22e">thread</span>;
</span></span><span style="display:flex;"><span>    t.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据上面的代码，线程池工作过程中是如何添加任务的就很清晰了：</p>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException</li>
</ul>
<p>如果通过addWorker()成功创建新的线程，则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以可以根据corePoolSize和maximumPoolSize来控制最大并发数。</p>
<p>过程如下图所示：</p>
<p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/p797.jpg" alt="线程池执行过程"></p>
<h4 id="管理线程">管理线程</h4>
<p>上边的文章已经讲了，通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程，而线程的管理过程已经穿插在其中了，也很好理解。</p>
<p>在 ThreadPoolExecutor 有个AtomicInteger变量 ctl，这一个变量保存了两个内容：</p>
<ul>
<li>所有线程的数量</li>
<li>每个线程所处的状态</li>
</ul>
<p>其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger ctl <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger(ctlOf(RUNNING, 0));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//得到线程的状态</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">runStateOf</span>(<span style="color:#66d9ef">int</span> c) { <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>CAPACITY; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//得到Worker的的数量</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">workerCountOf</span>(<span style="color:#66d9ef">int</span> c) { <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> CAPACITY; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断线程是否在运行</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isRunning</span>(<span style="color:#66d9ef">int</span> c) { <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&lt;</span> SHUTDOWN; }
</span></span></code></pre></div><p>这里主要通过shutdown和shutdownNow()来分析线程池的关闭过程。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：</p>
<ul>
<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>
<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>
<li>STOP状态：不再接受新任务，不处理队列中的任务</li>
</ul>
<p>shutdown()这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务人会被执行；shutdownNow()方法将runState置为STOP。和shutdown()方法的区别是，这个方法会终止所有的线程，所以队列中的任务也不会被执行了。</p>
<h3 id="java线程池框架源码分析">Java线程池框架源码分析</h3>
<p>前面的文章中已经给出了Java线程池框架中几个重要类的关系图:</p>
<p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/p798.jpg" alt="Java线程池框架"></p>
<p>现在我们基于这张图来逐步分析。</p>
<h4 id="executor">Executor</h4>
<pre tabindex="0"><code>public interface Executor {
    void execute(Runnable command);
}
</code></pre><p>这个接口表示向线程池中提交一个任务。</p>
<h4 id="executorservice">ExecutorService</h4>
<pre tabindex="0"><code>public interface ExecutorService extends Executor {
    void shutdown();
    List&lt;Runnable&gt; shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit)
       throws InterruptedException;
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
    Future&lt;?&gt; submit(Runnable task);
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException;
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                      long timeout, TimeUnit unit)
            throws InterruptedException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
                throws InterruptedException, ExecutionException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                long timeout, TimeUnit unit)
                    throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre><p>可以看到 ExecutorService 扩展了 Executor 接口，在 Executor 基础上提供了更多的提交任务的方式和管理线程池的一些方法。</p>
<h4 id="abstractexecutorservice">AbstractExecutorService</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractExecutorService</span> <span style="color:#66d9ef">implements</span> ExecutorService {
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="threadpoolexecutor">ThreadPoolExecutor</h4>
<p>ThreadPoolExecutor 是线程池框架的关键类. 首先来看一下 ThreadPoolExecutor 中几个重要的属性.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutor</span> <span style="color:#66d9ef">extends</span> AbstractExecutorService {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 整个线程池的状态控制类 ctl, 是一个 AtomicInteger ，封装了下面2个部分:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * workerCount 表示有效的线程数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * runState 表示线程池当前状态，是running, shutdown还是其他状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * runState表示了线程池的整个整个生命周期，可以取以下值:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * RUNNING: 接受新的task，处理队列中的task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * SHUTDOWN: 不接受新的 task 但会处理队列中的 task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * STOP: 不接受新的 task, 不处理队列中的 task, 中断正在执行的 task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * TIDYING: 所有 task 执行结束, workerCount 是 0, 线程过渡到TIDYING会调用 terminated()钩子方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * TERMINATED: terminated()执行完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 状态转换关系:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * RUNNING -&gt; SHUTDOWN(调用shutdown())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * On invocation of shutdown(), perhaps implicitly in finalize()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * (RUNNING or SHUTDOWN) -&gt; STOP(调用shutdownNow())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * On invocation of shutdownNow()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * SHUTDOWN -&gt; TIDYING(queue和pool均empty)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * When both queue and pool are empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * TIDYING -&gt; TERMINATED(调用terminated())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * When the terminated() hook method has completed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger ctl <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger(ctlOf(RUNNING, 0));
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * task 的队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * worker 线程的 Set, 只有持有 mainlock 时才能访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> HashSet<span style="color:#f92672">&lt;</span>Worker<span style="color:#f92672">&gt;</span> workers <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;</span>Worker<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Condition termination <span style="color:#f92672">=</span> mainLock.<span style="color:#a6e22e">newCondition</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> largestPoolSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">long</span> completedTaskCount;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> ThreadFactory threadFactory;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> RejectedExecutionHandler handler;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * idle 线程waiting for work的超时时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> keepAliveTime;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 如果是 false,core threads将会保持 alive 即使处于 idel 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 如果是 true,core threads会keepAliveTime作为超时时间 wait for work
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">boolean</span> allowCoreThreadTimeOut;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> corePoolSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> maximumPoolSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> RejectedExecutionHandler defaultHandler <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> AbortPolicy();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>workerCount, runState 使用一个 AtomicInteger 进行了封装, runState用 int 的高3位标书,低位表示 workerCount, 所以我们能看到 ThreadPoolExecutor 中和 ctl 相关的常量和解析方法.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> COUNT_BITS <span style="color:#f92672">=</span> Integer.<span style="color:#a6e22e">SIZE</span> <span style="color:#f92672">-</span> 3;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CAPACITY   <span style="color:#f92672">=</span> (1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS) <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// runState is stored in the high-order bits</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> RUNNING    <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SHUTDOWN   <span style="color:#f92672">=</span>  0 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> STOP       <span style="color:#f92672">=</span>  1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TIDYING    <span style="color:#f92672">=</span>  2 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TERMINATED <span style="color:#f92672">=</span>  3 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Packing and unpacking ctl</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">runStateOf</span>(<span style="color:#66d9ef">int</span> c)     { <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>CAPACITY; }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">workerCountOf</span>(<span style="color:#66d9ef">int</span> c)  { <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> CAPACITY; }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ctlOf</span>(<span style="color:#66d9ef">int</span> rs, <span style="color:#66d9ef">int</span> wc) { <span style="color:#66d9ef">return</span> rs <span style="color:#f92672">|</span> wc; }
</span></span></code></pre></div><p>ThreadPoolExecutor 最主要的构造函数,设置上面说的重要属性.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span>(<span style="color:#66d9ef">int</span> corePoolSize,
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">int</span> maximumPoolSize,
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">long</span> keepAliveTime,
</span></span><span style="display:flex;"><span>                          TimeUnit unit,
</span></span><span style="display:flex;"><span>                          BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue,
</span></span><span style="display:flex;"><span>                          ThreadFactory threadFactory,
</span></span><span style="display:flex;"><span>                          RejectedExecutionHandler handler) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (corePoolSize <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        maximumPoolSize <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        maximumPoolSize <span style="color:#f92672">&lt;</span> corePoolSize <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        keepAliveTime <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (workQueue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> threadFactory <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> handler <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">corePoolSize</span> <span style="color:#f92672">=</span> corePoolSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">maximumPoolSize</span> <span style="color:#f92672">=</span> maximumPoolSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">workQueue</span> <span style="color:#f92672">=</span> workQueue;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">keepAliveTime</span> <span style="color:#f92672">=</span> unit.<span style="color:#a6e22e">toNanos</span>(keepAliveTime);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">threadFactory</span> <span style="color:#f92672">=</span> threadFactory;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> handler;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在来看一下 execute() 方法, execute()方法有3个处理步骤:</p>
<ol>
<li>线程数小于 corePoolSize 时,则试图创建一个新的 worker 线程</li>
<li>如果上面一步失败了，则试图将任务添加到阻塞队列中，并且要再一次判断需要不需要回滚队列，或者说创建线程</li>
<li>如果上面两步都失败了，则会试图强行创建一个线程来执行这个任务，如果还是失败，扔掉这个任务</li>
</ol>
<pre tabindex="0"><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    // 1.判断有效线程数是否小于核心线程数
    if (workerCountOf(c) &lt; corePoolSize) {
        //创建新线程
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 2.分开来看，首先判断当前的池子是否是处于 running 状态
    // 因为只有 running 状态才可以接收新任务
    // 接下来判断能否成功添加到队列中，如果队列满了或者其他情况则会跳到下一步
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        // 再次检查池子的状态，如果进入了非 running 状态，回滚队列，扔掉这个任务
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        //如果处于 running 状态则检查当前的有效线程，如果没有则创建一个线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 3.前两步失败了，就强行创建线程，成功会返回true，如果失败扔掉这个任务
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre><p>解释一下第二步，为什么要recheck</p>
<p>当这个任务被添加到了阻塞队列前，池子处于 RUNNING 状态，但如果在添加到队列成功后，池子进入了 SHUTDOWN 状态或者其他状态，这时候是不应该再接收新的任务的，所以需要把这个任务从队列中移除，并且 reject</p>
<p>同样，在没有添加到队列前，可能有一个有效线程，但添加完任务后，这个线程闲置超时或者因为异常被干掉了，这时候需要创建一个新的线程来执行任务</p>
<p>为了更直观的理解一个任务的执行过程，可以参考下面这张图</p>
<p><img src="/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/p796.jpg" alt="任务的执行过程"></p>
<h4 id="addworker-1">addWorker()</h4>
<p>前一步把 execute 的流程捋了一遍，里面多次出现了 addWorker() 方法，前文说到这是个创建线程的方法，来看看 addWorker 做了些什么，这个方法代码比较长，我们拆开来一点一点看.</p>
<ul>
<li>第一部分 — 判断各种基础异常</li>
</ul>
<pre tabindex="0"><code>private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
 
        // Check if queue empty only if necessary.
        // 检查线程池状态，队列状态，以及 firstask ，拆开来看
        // 这段代码看起来异常的蛋疼,转换一下逻辑即
        // rs&gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null ||workQueue.isEmpty())
        // 总结起来就是 当前处于非 Running 状态,并且这三种情况
        // 1. 不是处于 SHUTDOWN 状态，不能再创建线程
        // 2. 有新的任务 (因为不能再接收新的任务)
        // 3. 阻塞队列中已经没有任务 (不需要再创建线程)
        if (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;
 
        for (;;) {
            //当前有效线程数目
            int wc = workerCountOf(c);
            // 根据传入的参数确定以核心线程数还是最大线程数作为判断条件
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))
                // 大于容量 或者指定的线程数，不允许创建
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
}
</code></pre><ul>
<li>第二部分 — 试图创建线程</li>
</ul>
<p>创建一个Worker</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">//标记 worker 开启状态</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">//标记 worker 添加状态</span>
</span></span><span style="display:flex;"><span>Worker w <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Worker(firstTask); <span style="color:#75715e">//将这个任务作为 worker 的第一个任务传入</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread t <span style="color:#f92672">=</span> w.<span style="color:#a6e22e">thread</span>; <span style="color:#75715e">//通过 worker 获取到一个线程</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">mainLock</span>;
</span></span><span style="display:flex;"><span>        mainLock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Recheck while holding lock.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Back out on ThreadFactory failure or if</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// shut down before lock acquired.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf(ctl.<span style="color:#a6e22e">get</span>());
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// running状态，或者 shutdown 状态但是没有新的任务</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (rs <span style="color:#f92672">&lt;</span> SHUTDOWN <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                (rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (t.<span style="color:#a6e22e">isAlive</span>()) <span style="color:#75715e">// precheck that t is startable</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalThreadStateException();
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将这个 worker 添加到线程池中</span>
</span></span><span style="display:flex;"><span>                workers.<span style="color:#a6e22e">add</span>(w);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> workers.<span style="color:#a6e22e">size</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">&gt;</span> largestPoolSize)
</span></span><span style="display:flex;"><span>                    largestPoolSize <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 标记worker添加成功</span>
</span></span><span style="display:flex;"><span>                workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            mainLock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果 worker 创建成功，开启线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (workerAdded) {
</span></span><span style="display:flex;"><span>            t.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> workerStarted)
</span></span><span style="display:flex;"><span>        addWorkerFailed(w);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> workerStarted;
</span></span></code></pre></div><p>上面代码从逻辑层面来看不算难懂，到这里一个任务到达后，ThreadPoolExecutor 的处理就结束了，那么任务又是怎么被添加到阻塞队列中，线程是如何从队列中取出任务，上文中的 Worker 又是什么东西？</p>
<p>一个一个来，先来看看 Worker 到底是什么.</p>
<h4 id="worker">Worker</h4>
<p>Worker 是 ThreadPoolExecutor 的一个内部类，实现了 Runnable 接口，继承自 AbstractQueuedSynchronizer,这又是个什么鬼？？? 这个就是经常见到的 AQS 的全称,这个暂时还没有研究.~~~~</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Worker</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">implements</span> Runnable {
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread thread;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Initial task to run. Possibly null. */</span>
</span></span><span style="display:flex;"><span>    Runnable firstTask;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Per-thread task counter */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> completedTasks;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>简单来说，Worker实现了 lock 和 unLock 方法来标示当前线程的状态是否为闲置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// Lock methods</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The value 0 represents the unlocked state.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The value 1 represents the locked state.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>()        { acquire(1); }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span>()  { <span style="color:#66d9ef">return</span> tryAcquire(1); }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>()      { release(1); }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isLocked</span>() { <span style="color:#66d9ef">return</span> isHeldExclusively(); }
</span></span></code></pre></div><p>上一节创建线程成功后调用 t.start() 而这个线程又是 Worker 的成员变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Worker(Runnable firstTask) {
</span></span><span style="display:flex;"><span>    setState(<span style="color:#f92672">-</span>1); <span style="color:#75715e">// inhibit interrupts until runWorker</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> firstTask;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> getThreadFactory().<span style="color:#a6e22e">newThread</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到这里将 Worker 作为 Runnable 参数创建了一个新的线程，我们知道 Thread 接收一个 Runnable 对象后 start 运行的是 Runnable 的 run 方法，Worker 的 run 方法调用了 runWorker ,这个方法里面就是取出任务执行的逻辑</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>    runWorker(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runWorker</span>(Worker w) {
</span></span><span style="display:flex;"><span>    Thread wt <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();
</span></span><span style="display:flex;"><span>    Runnable task <span style="color:#f92672">=</span> w.<span style="color:#a6e22e">firstTask</span>; <span style="color:#75715e">// 获取到 worker 的第一个任务</span>
</span></span><span style="display:flex;"><span>    w.<span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    w.<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// 标记为闲置，还没有开始任务 允许打断</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> completedAbruptly <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// 异常退出标记</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 循环取出任务，如果第一个任务不为空，或者从队列中拿到了任务</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 只要这两个条件满足，会一直循环，直到没有任务，正常退出，或者异常退出</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (task <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> (task <span style="color:#f92672">=</span> getTask()) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            w.<span style="color:#a6e22e">lock</span>();<span style="color:#75715e">// 该线程标记为非闲置</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If pool is stopping, ensure thread is interrupted;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// if not, ensure thread is not interrupted. This</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// requires a recheck in second case to deal with</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// shutdownNow race while clearing interrupt</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 翻译注释：1.如果线程池STOPPING状态，需要中断线程</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 2.Thread.interrupted()是一个native方法，返回当前线程是否有被等待中断的请求</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 3.第二个条件成立时，检查线程池状态，如果为STOP，并且没有被中断，则中断线程</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((runStateAtLeast(ctl.<span style="color:#a6e22e">get</span>(), STOP) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                 (Thread.<span style="color:#a6e22e">interrupted</span>() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                  runStateAtLeast(ctl.<span style="color:#a6e22e">get</span>(), STOP))) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">!</span>wt.<span style="color:#a6e22e">isInterrupted</span>())
</span></span><span style="display:flex;"><span>                wt.<span style="color:#a6e22e">interrupt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 执行任务</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                beforeExecute(wt, task);<span style="color:#75715e">// 执行前</span>
</span></span><span style="display:flex;"><span>                Throwable thrown <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    task.<span style="color:#a6e22e">run</span>(); <span style="color:#75715e">// 执行任务</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (RuntimeException x) {
</span></span><span style="display:flex;"><span>                    thrown <span style="color:#f92672">=</span> x; <span style="color:#66d9ef">throw</span> x;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (Error x) {
</span></span><span style="display:flex;"><span>                    thrown <span style="color:#f92672">=</span> x; <span style="color:#66d9ef">throw</span> x;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (Throwable x) {
</span></span><span style="display:flex;"><span>                    thrown <span style="color:#f92672">=</span> x; <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(x);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>                    afterExecute(task, thrown); <span style="color:#75715e">// 执行结束</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>                task <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// 将 worker 的任务置空</span>
</span></span><span style="display:flex;"><span>                w.<span style="color:#a6e22e">completedTasks</span><span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                w.<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// 释放锁，进入闲置状态</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }<span style="color:#75715e">// 循环结束</span>
</span></span><span style="display:flex;"><span>        completedAbruptly <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// 标记为正常退出</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 干掉 worker</span>
</span></span><span style="display:flex;"><span>        processWorkerExit(w, completedAbruptly);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里弄清楚了一件事情，进入循环准备执行任务时，worker 加锁标记为非闲置，任务执行完毕或者出现异常，worker 释放锁，进入闲置状态。</p>
<p>也就是当一个 worker 执行任务前或者执行完任务，到取出下一个任务期间，都是闲置状态可以被打断</p>
<p>上面取出任务调用了 getTask() ，诶～为什么有一个死循环，别着急，慢慢看来。上面的代码可以知道如果 getTask 返回任务则执行，如果返回为 null 则 worker 需要被回收</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Runnable <span style="color:#a6e22e">getTask</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 标记取任务是否超时</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// Did the last poll() time out?</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf(c);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if queue empty only if necessary.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果线程池状态为 STOP 或者 SHUTDOWN 并且队列已经为空，回收 wroker</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rs <span style="color:#f92672">&gt;=</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> (rs <span style="color:#f92672">&gt;=</span> STOP <span style="color:#f92672">||</span> workQueue.<span style="color:#a6e22e">isEmpty</span>())) {
</span></span><span style="display:flex;"><span>            decrementWorkerCount();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取当前有效线程数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf(c);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Are workers subject to culling?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// timed 用来标记当前的 worker 是否设置超时时间，</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 还记得获取线程池的时候 可以设置核心线程超时时间</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.允许核心线程超时回收(即所有线程) 2.当前有效线程超过核心线程数(需要回收)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果timed == false 则该worker不会被回收，如果没有取到任务 会一直阻塞</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> timed <span style="color:#f92672">=</span> allowCoreThreadTimeOut <span style="color:#f92672">||</span> wc <span style="color:#f92672">&gt;</span> corePoolSize;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 回收线程条件</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 有效线程数已经大于了线程池的最大线程数或者设置了超时回收并且已经超时</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 有效线程数大于1或者队列任务已经为空</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 只有当上面1和2 同时满足时 则试图回收线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((wc <span style="color:#f92672">&gt;</span> maximumPoolSize <span style="color:#f92672">||</span> (timed <span style="color:#f92672">&amp;&amp;</span> timedOut))
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> (wc <span style="color:#f92672">&gt;</span> 1 <span style="color:#f92672">||</span> workQueue.<span style="color:#a6e22e">isEmpty</span>())) {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 如果减少workercount成功 直接回收</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndDecrementWorkerCount(c))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 否则重走循环，从第一个判断条件处回收</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 取任务</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 根据是否设置超时回收来选择不同的取任务的方式</span>
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// poll 方法取任务会有超时时间，超过时间则返回null</span>
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// take 方法没有超时时间，阻塞式方法</span>
</span></span><span style="display:flex;"><span>            Runnable r <span style="color:#f92672">=</span> timed <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                workQueue.<span style="color:#a6e22e">poll</span>(keepAliveTime, TimeUnit.<span style="color:#a6e22e">NANOSECONDS</span>) :
</span></span><span style="display:flex;"><span>                workQueue.<span style="color:#a6e22e">take</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 如果任务不为空返回任务</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 否则标记超时 进入下一次循环等待回收</span>
</span></span><span style="display:flex;"><span>            timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException retry) {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 如果出现异常，试图重试</span>
</span></span><span style="display:flex;"><span>            timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>getTask() 方法逻辑也捋得差不多了，这里又出现了两个新的方法，workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 和 workQueue.take() ，这两个都是阻塞队列的方法，来看看它们又各自是怎么实现的</p>
<h4 id="linkedblockingqueue--阻塞队列">LinkedBlockingQueue — 阻塞队列</h4>
<p>ThreadPoolExecutor 使用的是链表结构的阻塞队列，实现了 BlockingQueue 接口，而 BlockingQueue 则是继承自 Queue 接口，再上层就是 Collection 接口。</p>
<p>因为本篇笔记主要是分析 ThreadPoolExecutor 的原理，所以不会详细介绍 LinkedBlockingQueue 中的其它代码，主要介绍这里所用的方法，首先来看一下上文所提到的 take()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">take</span>() <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    E x; <span style="color:#75715e">// 任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1; <span style="color:#75715e">// 取出任务后的剩余任务数量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> AtomicInteger count <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span>; <span style="color:#75715e">// 当前任务数量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock takeLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">takeLock</span>; <span style="color:#75715e">// 加锁防止并发</span>
</span></span><span style="display:flex;"><span>    takeLock.<span style="color:#a6e22e">lockInterruptibly</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果队列数量为空，则一直循环，阻塞线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (count.<span style="color:#a6e22e">get</span>() <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>            notEmpty.<span style="color:#a6e22e">await</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 取出任务</span>
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> dequeue();
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 任务数量减一</span>
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> count.<span style="color:#a6e22e">getAndDecrement</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&gt;</span> 1)
</span></span><span style="display:flex;"><span>            notEmpty.<span style="color:#a6e22e">signal</span>();<span style="color:#75715e">// 标记队列非空</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        takeLock.<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// 释放锁</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> capacity)
</span></span><span style="display:flex;"><span>        signalNotFull();<span style="color:#75715e">//标记队列已满</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;<span style="color:#75715e">// 返回任务</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码可以知道 take 方法会一直阻塞直到队列有新的任务为止</p>
<p>接下来是 poll 方法，可以看到几乎与 take 方法相同，唯一的区别是在阻塞的循环代码块里面加了时间判断，如果超时则直接返回为空，不会一直阻塞下去</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">long</span> timeout, TimeUnit unit) <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    E x <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// 存放的任务</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> nanos <span style="color:#f92672">=</span> unit.<span style="color:#a6e22e">toNanos</span>(timeout); <span style="color:#75715e">// 超时时间</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> AtomicInteger count <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span>; <span style="color:#75715e">// 队列中的数量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock takeLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">takeLock</span>; <span style="color:#75715e">// 加锁防止并发</span>
</span></span><span style="display:flex;"><span>    takeLock.<span style="color:#a6e22e">lockInterruptibly</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果队列为空，则不断的循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (count.<span style="color:#a6e22e">get</span>() <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果当倒计时小于0 即超时时间到 则返回空</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nanos <span style="color:#f92672">&lt;=</span> 0)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 让线程等待</span>
</span></span><span style="display:flex;"><span>            nanos <span style="color:#f92672">=</span> notEmpty.<span style="color:#a6e22e">awaitNanos</span>(nanos);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> dequeue(); <span style="color:#75715e">// 取出一个任务</span>
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> count.<span style="color:#a6e22e">getAndDecrement</span>(); <span style="color:#75715e">// 取出后的队列数量</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&gt;</span> 1)
</span></span><span style="display:flex;"><span>            notEmpty.<span style="color:#a6e22e">signal</span>(); <span style="color:#75715e">// 标记非空</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        takeLock.<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// 释放锁</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> capacity)
</span></span><span style="display:flex;"><span>        signalNotFull(); <span style="color:#75715e">// 标记队列已满</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x; <span style="color:#75715e">// 返回任务</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="线程池的回收及终止">线程池的回收及终止</h4>
<p>前一节分析了任务的执行流程及原理，也留下了一个问题，worker 是如何被回收的呢？线程池该如何管理呢？回到上一节的 runWorker() 方法中，还记得最后调用了一个方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>processWorkerExit(w, completedAbruptly);
</span></span></code></pre></div><p>这个方法传入了两个参数，第一个是当前的 Woker ,第二个是标记异常退出的标识</p>
<p>首先判断是否为异常退出，如果是异常退出的话需要手动调整线程数量，如果是正常回收的，getTask 方法里面已经手动调整过了，不记得的小伙伴可以看看前文的代码，找找 decrementWorkerCount(),</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processWorkerExit</span>(Worker w, <span style="color:#66d9ef">boolean</span> completedAbruptly) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (completedAbruptly) <span style="color:#75715e">// If abrupt, then workerCount wasn&#39;t adjusted</span>
</span></span><span style="display:flex;"><span>        decrementWorkerCount();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 加锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">mainLock</span>;
</span></span><span style="display:flex;"><span>    mainLock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录线程池完成的任务总数，从 workers 中移除该 worker</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        completedTaskCount <span style="color:#f92672">+=</span> w.<span style="color:#a6e22e">completedTasks</span>;
</span></span><span style="display:flex;"><span>        workers.<span style="color:#a6e22e">remove</span>(w);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        mainLock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    tryTerminate(); <span style="color:#75715e">// 尝试关闭池子</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 以下的代码是判断需不需要给线程池创建一个新的线程</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果线程池的状态是 RUNNING 或者 SHUTDOWN 进一步判断需不需要创建</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (runStateLessThan(c, STOP)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果为异常退出直接创建，如果不是异常退出进入判断</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>completedAbruptly) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取线程池应该存在的最小线程数 如果设置了超时 则是0，否则是核心线程数</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> allowCoreThreadTimeOut <span style="color:#f92672">?</span> 0 : corePoolSize;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果 min 是0 但是队列又不为空，则 min 应该是1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (min <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> workQueue.<span style="color:#a6e22e">isEmpty</span>())
</span></span><span style="display:flex;"><span>                min <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果当前池中的有效线程数大于等于最小线程数 则不需要创建</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (workerCountOf(c) <span style="color:#f92672">&gt;=</span> min)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// replacement not needed</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建线程</span>
</span></span><span style="display:flex;"><span>        addWorker(<span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码中调用了 tryTerminate() 方法，这个方法是用于终止线程池的，又是一个 for 循环，从代码结构来看是异常情况的重试机制。还是老方法，慢慢来看总共做了几件事情</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tryTerminate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果处于这三种情况不需要关闭线程池</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 1. Running 状态</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 2. SHUTDOWN 状态并且任务队列不为空，不能终止</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 3. TIDYING 或者 TERMINATE 状态，说明已经在关闭了 不需要重复关闭</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (isRunning(c) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            runStateAtLeast(c, TIDYING) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            (runStateOf(c) <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> workQueue.<span style="color:#a6e22e">isEmpty</span>()))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 进入到关闭线程池的代码，如果线程池中还有线程，则需要打断线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (workerCountOf(c) <span style="color:#f92672">!=</span> 0) { <span style="color:#75715e">// Eligible to terminate 可以关闭池子</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 打断闲置线程，只打断一个</span>
</span></span><span style="display:flex;"><span>            interruptIdleWorkers(ONLY_ONE);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果有两个以上怎么办？只打断一个？</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 这里只打断一个是因为 worker 回收的时候都会进入到该方法中来，可以回去再看看</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// runWorker方法最后的代码</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 线程已经回收完毕，准备关闭线程池</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">mainLock</span>;
</span></span><span style="display:flex;"><span>        mainLock.<span style="color:#a6e22e">lock</span>();<span style="color:#75715e">// 加锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将状态改变为 TIDYING 并且即将调用 terminated</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ctl.<span style="color:#a6e22e">compareAndSet</span>(c, ctlOf(TIDYING, 0))) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    terminated(); <span style="color:#75715e">// 终止线程池</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>                    ctl.<span style="color:#a6e22e">set</span>(ctlOf(TERMINATED, 0)); <span style="color:#75715e">// 改变状态</span>
</span></span><span style="display:flex;"><span>                    termination.<span style="color:#a6e22e">signalAll</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            mainLock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果终止失败会重试</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// else retry on failed CAS</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>尝试终止线程池的代码分析完了，好像就结束了～但作为好奇宝宝，我们是不是应该看看如何打断闲置线程，以及 terminated 中做了什么呢？来吧，继续装逼</p>
<p>先来看打断线程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interruptIdleWorkers</span>(<span style="color:#66d9ef">boolean</span> onlyOne) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">mainLock</span>;
</span></span><span style="display:flex;"><span>    mainLock.<span style="color:#a6e22e">lock</span>();<span style="color:#75715e">//加锁～</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 遍历线程池中的 wroker</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Worker w : workers) {
</span></span><span style="display:flex;"><span>            Thread t <span style="color:#f92672">=</span> w.<span style="color:#a6e22e">thread</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 如果线程没有被中断，并且能够获取到 worker的锁(说明是闲置线程)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t.<span style="color:#a6e22e">isInterrupted</span>() <span style="color:#f92672">&amp;&amp;</span> w.<span style="color:#a6e22e">tryLock</span>()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    t.<span style="color:#a6e22e">interrupt</span>();<span style="color:#75715e">// 中断线程</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (SecurityException ignore) {
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>                    w.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 只中断一个 worker 跳出循环，否则会将所有的闲置线程都中断</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (onlyOne)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        mainLock.<span style="color:#a6e22e">unlock</span>();<span style="color:#75715e">// 释放锁</span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>有同学开始装逼了，说我们是好奇宝宝，t.interrupt() 方法也应该看，嗯～没错，但这里是调用了 native 方法，会 c 的可以去看看装逼，我就算了～</p>
<p>好了，再来看看 terminate, 是不是很坑爹？ terminated 里面神！马！也！没！干！。。。淡定，其实这个方法类似于 Activity 的生命周期方法，允许你在被终止时做一些事情，默认的线程池没有什么要做的事情，当然什么也没写啦～</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Method invoked when the Executor has terminated. Default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * implementation does nothing. Note: To properly nest multiple
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * overridings, subclasses should generally invoke
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * {@code super.terminated} within this method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">terminated</span>() { }
</span></span></code></pre></div><h4 id="异常处理">异常处理</h4>
<p>还记得前面讲到，出现各种异常情况，添加队列失败等等，只是笼统的说了一句扔掉，当然代码实现不可能是简单一句扔掉就完了。回到 execute() 方法中找到 reject() 任务，看看究竟是怎么处理的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reject</span>(Runnable command) {
</span></span><span style="display:flex;"><span>    handler.<span style="color:#a6e22e">rejectedExecution</span>(command, <span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>还记得在创建线程池的时候，初始化了一个 handler — RejectedExecutionHandler</p>
<p>这是一个接口，只有一个方法,接收两个参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rejectedExecution</span>(Runnable r, ThreadPoolExecutor executor);
</span></span></code></pre></div><p>既然是一个接口，那么肯定有他的实现类，我们先不急着看所有实现类，先来看看这里的 handler 可能是什么，记得在使用 Executors 获取线程池调用构造方法的时候并没有传入 handler 参数，那么 ThreadPoolExecutor 应该会有一个默认的 handler</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> RejectedExecutionHandler defaultHandler <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> AbortPolicy();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbortPolicy</span> <span style="color:#66d9ef">implements</span> RejectedExecutionHandler {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AbortPolicy</span>() { }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RejectedExecutionException(<span style="color:#e6db74">&#34;Task &#34;</span> <span style="color:#f92672">+</span> r.<span style="color:#a6e22e">toString</span>() <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                                             <span style="color:#e6db74">&#34; rejected from &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                                             e.<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>默认 handler 是 AbortPolicy ,这个类实现了 rejectedExecution() 方法，抛了一个 Runtime 异常，也就是说当任务添加失败，就会抛出异常。这个类在 AsyncTask 引发了一场血案～所以在 API19 以后修改了 AsyncTask 的部分代码逻辑，这里就不细说啦.</p>
<p>实际上，在 ThreadPoolExecutor 中除了 AbortPolicy 外还实现了三种不同类型的 handler</p>
<ul>
<li>CallerRunsPolicy — 在 线程池没有 shutdown 的前提下，会直接在执行 execute 方法的线程里执行这个任务</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>e.<span style="color:#a6e22e">isShutdown</span>()) {
</span></span><span style="display:flex;"><span>        r.<span style="color:#a6e22e">run</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>DiscardPolicy — 啥也不干，默默地丢掉任务～不信你看</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>DiscardOldestPolicy — 丢弃掉队列中未执行的，最老的任务，也就是任务队列排头的任务，然后再试图在执行一次</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>e.<span style="color:#a6e22e">isShutdown</span>()) {
</span></span><span style="display:flex;"><span>        e.<span style="color:#a6e22e">getQueue</span>().<span style="color:#a6e22e">poll</span>();
</span></span><span style="display:flex;"><span>        e.<span style="color:#a6e22e">execute</span>(r);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-tags">
              <a href="/tags/java/">
                Java
              </a>
            </div>
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          

<div class="related-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">再回首CMS垃圾回收</a></li>
    
  </ul>
</div>



          
          
          <div style="height: 50px;"></div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>