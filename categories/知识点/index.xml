<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>知识点 on Carlos的废话集</title>
    <link>https://carlos19960601.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
    <description>Recent content in 知识点 on Carlos的废话集</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Wed, 09 Oct 2024 11:30:42 +0800</lastBuildDate>
    <atom:link href="https://carlos19960601.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面试</title>
      <link>https://carlos19960601.github.io/posts/%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Wed, 09 Oct 2024 11:30:42 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E9%9D%A2%E8%AF%95/</guid>
      <description>&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;&#xA;&lt;h4 id=&#34;countcount1count0countidcountname之间的区别&#34;&gt;Count(*)、Count(1)、Count(0)、Count(id)、Count(name)之间的区别?&lt;/h4&gt;&#xA;&lt;p&gt;Count都会进行一次全表便利，Count(*)、Count(1)、Count(0)不会从底层获取数据，直接进行count++。但是id和name会从底层获取数据进行判断是否为null才进行count++。此外MySQL会借助占用页最小的索引进行遍历。&lt;/p&gt;&#xA;&lt;h3 id=&#34;系统设计&#34;&gt;系统设计&lt;/h3&gt;&#xA;&lt;h4 id=&#34;怎么避免单点故障spofsingle-point-of-failure&#34;&gt;怎么避免单点故障(SPOF、Single Point of Failure)？&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Redundancy(冗余): Primary vs Standby，比如流量入口，load banlaner进行主备&lt;/li&gt;&#xA;&lt;li&gt;Load Balancing(负载均衡)&lt;/li&gt;&#xA;&lt;li&gt;Data Replication(数据复制): 数据库、缓存的主从&lt;/li&gt;&#xA;&lt;li&gt;Geographic Distributio(异地多活)：异地多集群的数据复制（同步或异步）&lt;/li&gt;&#xA;&lt;li&gt;Graceful Handling of Failures&lt;/li&gt;&#xA;&lt;li&gt;Monitoring and Alerting&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;技术选型&#34;&gt;技术选型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;sql-vs-nosql&#34;&gt;SQL vs NoSQL&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据模型: schema vs schema-less(Key-Value Model, Document Model, Column-Family Model, Graph Model )&lt;/li&gt;&#xA;&lt;li&gt;扩展性: 垂直扩展 vs 水平扩展&lt;/li&gt;&#xA;&lt;li&gt;查询语言：SQL vs 无固定标准&lt;/li&gt;&#xA;&lt;li&gt;事务：ACID vs BASE&lt;/li&gt;&#xA;&lt;li&gt;性能：对Schema明确，查询模式固定的方式，SQL查询效率高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://carlos19960601.github.io/%E9%9D%A2%E8%AF%95/SQLvsNoSQL.png&#34; alt=&#34;SQL vs NoSQL&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;具体系统设计blog&#34;&gt;具体系统设计Blog&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.algomaster.io/p/design-spotify-system-design-interview&#34;&gt;Design Spotify - System Design Interview&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.algomaster.io/p/design-a-scalable-notification-service&#34;&gt;Design a Scalable Notification Service - System Design Interview&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7397410962847039525&#34;&gt;麻烦不要再问我count(*)、count(1)、count(id)、count(name)之间的区别了&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.algomaster.io/p/system-design-how-to-avoid-single-point-of-failures&#34;&gt;System Design: How to Avoid Single Point of Failures?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.algomaster.io/p/sql-vs-nosql-7-key-differences&#34;&gt;SQL vs NoSQL - 7 Key Differences You Must Know&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;网络协议&#34;&gt;网络协议&lt;/h3&gt;&#xA;&lt;h4 id=&#34;dns-完整查询过程&#34;&gt;DNS 完整查询过程?&lt;/h4&gt;&#xA;&lt;p&gt;DNS 查询请求过程和域名缓存结合起来，完整查询过程👇：&lt;/p&gt;</description>
    </item>
    <item>
      <title>缓存驱逐策略</title>
      <link>https://carlos19960601.github.io/posts/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 26 Jun 2024 22:54:31 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://carlos19960601.github.io/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/Cache%20Eviction%20Strtegies.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Least Recently Used(LRU)&lt;/strong&gt;: 删除最旧的数据。基本假设是最近访问的数据可能很快会再次被需要。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Most Recently Used(MRU)&lt;/strong&gt;: 与&lt;strong&gt;LRU&lt;/strong&gt;相反，删除最新的数据。常用于流处理或批处理平台，这些平台一旦使用数据就不太可能再次需要。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Least Frequently Used(LFU)&lt;/strong&gt;: 删除使用最少的数据。虽然它是一种比 &lt;strong&gt;LRU&lt;/strong&gt; 更准确的方法，但它需要一种机制来记录数据访问的频率，这增加了复杂性。它通常与 &lt;strong&gt;LRU&lt;/strong&gt; 等策略配合使用，以降低缓存过时数据的风险。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Time-To-Live (TTL)&lt;/strong&gt;：数据在预设的时间段有效。常用在会话数据中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Two-tiered caching&lt;/strong&gt;两层缓存提供了一种更复杂的方法。可以在速度和成本之间取得平衡。在此设计中，数据被分为快速、昂贵的层（用于流行数据）和较慢、经济的层（用于较少访问的数据）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;上述五种策略是最流行的缓存方法。还有其他一些策略：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;先进先出（FIFO&lt;/strong&gt;）：最旧的数据首先被删除。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;随机替换（RR）&lt;/strong&gt;：随机选择要删除的数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;自适应替换缓存 (ARC)&lt;/strong&gt;：使用自调整算法跟踪新近度和频率来确定首先删除哪些数据。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
