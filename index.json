[{"content":"Context的作用 Context可以让我们在组件树中传递数据，而不需要通过props一层层传递。\n但是有一些需要注意的点。\nContext consumers will re-render when the value on the Provider changes. All of them will re-render, even if they don\u0026rsquo;t use the part of the value that actually changed. Those re-renders can\u0026rsquo;t be prevented with memoization (easily). Context的value改变 const NavigationController = ({ children }) =\u0026gt; { const [isNavExpanded, setIsNavExpanded] = useState(); const toggle = () =\u0026gt; setIsNavExpanded(!isNavExpanded); const value = { isNavExpanded, toggle }; return ( \u0026lt;Context.Provider value={value}\u0026gt; {children} \u0026lt;/Context.Provider\u0026gt; ); }; const useNavigation = () =\u0026gt; useContext(Context); 每次value改变的时候， 使用useNavigation的组件都会重新渲染。这很正常，但是如果是因为其他原因，导致value改变呢？比如\nconst Layout = ({ children }) =\u0026gt; { const [scroll, setScroll] = useState(); useEffect(() =\u0026gt; { window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { setScroll(window.scrollY);}); },[]); return ( \u0026lt;NavigationController\u0026gt; \u0026lt;div className=\u0026#34;layout\u0026#34;\u0026gt;{children}\u0026lt;/div\u0026gt; \u0026lt;/NavigationController\u0026gt; ); }; 现在，只要window滚动，就会造成NavigationController重新渲染, NavigationController重新渲染导致value重新创建，导致依赖value的组件重新渲染。\n其实value里面的isNavExpanded和toggle并没有发生变化，为了解决这个问题，可以使用useMemo来缓存value。\nconst NavigationController = ({ children }) =\u0026gt; { const [isNavExpanded, setIsNavExpanded] = useState(); const toggle = useCallback(() =\u0026gt; { setIsNavExpanded(!isNavExpanded); }, [isNavExpanded]); const value = useMemo(() =\u0026gt; { return { isNavExpanded, toggle }; }, [isNavExpanded, toggle]); return ( \u0026lt;Context.Provider value={value}\u0026gt; {children} \u0026lt;/Context.Provider\u0026gt; ); }; 接下来再来看一个场景，代码如下：\nimport React, { ReactNode, useCallback, useContext, useEffect, useMemo, useState } from \u0026#39;react\u0026#39;; import { AnotherVerySlowComponent, VerySlowComponent } from \u0026#39;./components/very-slow-component\u0026#39;; import \u0026#39;./styles.scss\u0026#39;; const Context = React.createContext({ isNavExpanded: false, toggle: () =\u0026gt; {}, close: () =\u0026gt; {}, open: () =\u0026gt; {}, }); const NavigationController = ({ children }: { children: ReactNode }) =\u0026gt; { const [isNavExpanded, setIsNavExpanded] = useState(false); const toggle = useCallback(() =\u0026gt; { setIsNavExpanded(!isNavExpanded); }, [isNavExpanded]); const open = useCallback(() =\u0026gt; { setIsNavExpanded(true); }, []); const close = useCallback(() =\u0026gt; { setIsNavExpanded(false); }, []); const value = useMemo(() =\u0026gt; { return { isNavExpanded, toggle, close, open }; }, [isNavExpanded, toggle, close, open]); return \u0026lt;Context.Provider value={value}\u0026gt;{children}\u0026lt;/Context.Provider\u0026gt;; }; const useNavigation = () =\u0026gt; useContext(Context); const AdjustableColumnsBlock = () =\u0026gt; { const { isNavExpanded } = useNavigation(); return isNavExpanded ? \u0026lt;div\u0026gt;two block items here\u0026lt;/div\u0026gt; : \u0026lt;div\u0026gt;three block items here\u0026lt;/div\u0026gt;; }; const withNavigationOpen = (AnyComponent: any) =\u0026gt; { // wrap the component from the arguments in React.memo here const AnyComponentMemo = React.memo(AnyComponent); return (props: any) =\u0026gt; { const { open } = useContext(Context); // return memoized component here // now it won\u0026#39;t re-render because of Context changes // make sure that whatever is passed as props here don\u0026#39;t change between re-renders! return \u0026lt;AnyComponentMemo {...props} openNav={open} /\u0026gt;; }; }; const MainPart = withNavigationOpen(({ openNav }: { openNav: () =\u0026gt; void }) =\u0026gt; { useEffect(() =\u0026gt; { // won\u0026#39;t be triggered when context value changes // because toggleNav is coming from memoized HOC console.info(\u0026#39;Main part re-render\u0026#39;); }); return ( \u0026lt;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={openNav}\u0026gt;click to expand nav - inside heavy component\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;VerySlowComponent /\u0026gt; \u0026lt;AnotherVerySlowComponent /\u0026gt; \u0026lt;AdjustableColumnsBlock /\u0026gt; \u0026lt;/\u0026gt; ); }); const ExpandButton = () =\u0026gt; { const { isNavExpanded, toggle } = useNavigation(); useEffect(() =\u0026gt; { console.info(\u0026#39;Button that uses Context re-renders\u0026#39;); }); return \u0026lt;button onClick={toggle}\u0026gt;{isNavExpanded ? \u0026#39;collapse \u0026lt;\u0026#39; : \u0026#39;expand \u0026gt;\u0026#39;}\u0026lt;/button\u0026gt;; }; const SidebarLayout = ({ children }: { children: ReactNode }) =\u0026gt; { const { isNavExpanded } = useNavigation(); return ( \u0026lt;div className=\u0026#34;left\u0026#34; style={{ flexBasis: isNavExpanded ? \u0026#39;50%\u0026#39; : \u0026#39;20%\u0026#39; }}\u0026gt; {children} \u0026lt;/div\u0026gt; ); }; const Sidebar = () =\u0026gt; { return ( \u0026lt;SidebarLayout\u0026gt; {/* this one will control the expand/collapse */} \u0026lt;ExpandButton /\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;some links\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/SidebarLayout\u0026gt; ); }; const Layout = ({ children }: { children: ReactNode }) =\u0026gt; { const [scroll, setScroll] = useState(0); useEffect(() =\u0026gt; { window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { setScroll(window.scrollY); }); }, []); return ( \u0026lt;NavigationController\u0026gt; \u0026lt;div className=\u0026#34;three-layout\u0026#34;\u0026gt;{children}\u0026lt;/div\u0026gt; \u0026lt;/NavigationController\u0026gt; ); }; const Page = () =\u0026gt; { return ( \u0026lt;Layout\u0026gt; \u0026lt;Sidebar /\u0026gt; \u0026lt;MainPart /\u0026gt; \u0026lt;/Layout\u0026gt; ); }; export default function App() { return ( \u0026lt;\u0026gt; \u0026lt;h3\u0026gt;Very slow \u0026#34;Page\u0026#34; component - click on expand/collapse to toggle nav\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;Scrolling causes re-render of everything that uses Context\u0026lt;/p\u0026gt; \u0026lt;Page /\u0026gt; \u0026lt;/\u0026gt; ); } 上面的代码实现了一个Sidebar和MainPart2个部分，Sidebar中有个button可以控制折叠，MainPart中根据Sidebar是否折叠展示不同的layout。\nMainPart中有些slow的组件。在withNavigationOpen中使用了meme,如果没有meme，每次MainPart都是在Sidebar折叠的时候重新渲染。但是MainPart中的slow的组件并不依赖于Sidebar是否折叠。\n造成这个问题的原因是withNavigationOpen中使用了useContext(Context), 由于isNavExpanded改变，导致Context的value变化，AnyComponent就会重新渲染，但是open其实是不依赖于isNavExpanded，所以AnyComponent加上memo后，props和openNav没有变化，就不会重新渲染了。\nconst withNavigationOpen = (AnyComponent: any) =\u0026gt; { // wrap the component from the arguments in React.memo here const AnyComponentMemo = React.memo(AnyComponent); return (props: any) =\u0026gt; { const { open } = useContext(Context); // return memoized component here // now it won\u0026#39;t re-render because of Context changes // make sure that whatever is passed as props here don\u0026#39;t change between re-renders! return \u0026lt;AnyComponentMemo {...props} openNav={open} /\u0026gt;; }; }; ","permalink":"https://carlos19960601.github.io/posts/react-rerender-context/","summary":"\u003ch3 id=\"context的作用\"\u003eContext的作用\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e5%85%b3%e4%ba%8eReact%e7%9a%84rerender/react-context.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eContext可以让我们在组件树中传递数据，而不需要通过props一层层传递。\u003c/p\u003e\n\u003cp\u003e但是有一些需要注意的点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eContext consumers will re-render when the value on the Provider changes.\u003c/li\u003e\n\u003cli\u003eAll of them will re-render, even if they don\u0026rsquo;t use the part of the value that actually changed.\u003c/li\u003e\n\u003cli\u003eThose re-renders can\u0026rsquo;t be prevented with memoization (easily).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"context的value改变\"\u003eContext的value改变\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eNavigationController\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e ({ \u003cspan style=\"color:#a6e22e\"\u003echildren\u003c/span\u003e }) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e [\u003cspan style=\"color:#a6e22e\"\u003eisNavExpanded\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003esetIsNavExpanded\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etoggle\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003esetIsNavExpanded\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eisNavExpanded\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eisNavExpanded\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003etoggle\u003c/span\u003e };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003eContext.Provider\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e}\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        {\u003cspan style=\"color:#a6e22e\"\u003echildren\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003eContext.Provider\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseNavigation\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003euseContext\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eContext\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e每次value改变的时候， 使用\u003ccode\u003euseNavigation\u003c/code\u003e的组件都会重新渲染。这很正常，但是如果是因为其他原因，导致value改变呢？比如\u003c/p\u003e","title":"React Rerender Context"},{"content":"现在需要创建一个Block组件，需要根据scroll value来控制其显示的位置。\nconst MainScrollableArea = () =\u0026gt; { const [position, setPosition] = useState(300); const onScroll = (e) =\u0026gt; { // calculate position based on the scrolled value const calculated = getPosition(e.target.scrollTop); // save it to state setPosition(calculated); }; return ( \u0026lt;div className=\u0026#34;scrollable-block\u0026#34; onScroll={onScroll}\u0026gt; {/* pass position value to the new movable component */} \u0026lt;MovingBlock position={position} /\u0026gt; \u0026lt;VerySlowComponent /\u0026gt; \u0026lt;BunchOfStuff /\u0026gt; \u0026lt;OtherStuffAlsoComplicated /\u0026gt; \u0026lt;/div\u0026gt; ); 根据 React Rerender-Move State Down模式我们了解到这会导致整个MainScrollableArea都会重新渲染。\n于是我们可以将不依赖于position的组件提取出来。\nconst ScrollableWithMovingBlock = ({children}) =\u0026gt; { const [position, setPosition] = useState(300); const onScroll = (e) =\u0026gt; { const calculated = getPosition(e.target.scrollTop); setPosition(calculated); }; return ( \u0026lt;div className=\u0026#34;scrollable-block\u0026#34; onScroll={onScroll}\u0026gt; \u0026lt;MovingBlock position={position} /\u0026gt; {/* slow bunch of stuff used to be here, but not anymore */} {children} \u0026lt;/div\u0026gt; ); }; const App = () =\u0026gt; { return ( \u0026lt;ScrollableWithMovingBlock\u0026gt; \u0026lt;VerySlowComponent /\u0026gt; \u0026lt;BunchOfStuff /\u0026gt; \u0026lt;OtherStuffAlsoComplicated /\u0026gt; \u0026lt;/ScrollableWithMovingBlock\u0026gt; ); }; 这样VerySlowComponent、BunchOfStuff、OtherStuffAlsoComplicated这些组件就不会重新渲染了。有人可能会疑惑，为什么这样就不会重新渲染了呢？VerySlowComponent、BunchOfStuff、OtherStuffAlsoComplicated这些组件仍然在ScrollableWithMovingBlock中，position发生改变了，为啥它们不会重新渲染呢？\n这就需要了解Rerender的机制了。Rerender的时候，React会重新执行创建组件的函数，然后通过Object.is来判断是否有变化来判断是否重新创建。以上面的ScrollableWithMovingBlock为例，看看Rerender的过程。\nconst ScrollableWithMovingBlock = ({children}) =\u0026gt; { const [position, setPosition] = useState(300); const onScroll = (e) =\u0026gt; { const calculated = getPosition(e.target.scrollTop); setPosition(calculated); }; return ( \u0026lt;div className=\u0026#34;scrollable-block\u0026#34; onScroll={onScroll}\u0026gt; \u0026lt;MovingBlock position={position} /\u0026gt; {/* slow bunch of stuff used to be here, but not anymore */} {children} \u0026lt;/div\u0026gt; ); }; 当position发生变化的时候，会重新执行ScrollableWithMovingBlock函数，判断其返回值中所有的Object是否有变化。MovingBlock是在本地创建的，所以每次都是新创建的，Object.is判断为false。所有MovingBlock会重新创建。对于children由于是外部创建的，所以Object.is判断为true，children不会重新渲染。\n","permalink":"https://carlos19960601.github.io/posts/react-rerender-children-as-props%E6%A8%A1%E5%BC%8F/","summary":"\u003cp\u003e现在需要创建一个Block组件，需要根据scroll value来控制其显示的位置。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMainScrollableArea\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e [\u003cspan style=\"color:#a6e22e\"\u003eposition\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003esetPosition\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e300\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonScroll\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// calculate position based on the scrolled value \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecalculated\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egetPosition\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003escrollTop\u003c/span\u003e); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// save it to state\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003esetPosition\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecalculated\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclassName\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;scrollable-block\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonScroll\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eonScroll\u003c/span\u003e}\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#75715e\"\u003e/* pass position value to the new movable component */\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eMovingBlock\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eposition\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eposition\u003c/span\u003e} /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eVerySlowComponent\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eBunchOfStuff\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eOtherStuffAlsoComplicated\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  );\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e根据 \u003ca href=\"/posts/react-rerender-move-state-down%E6%A8%A1%E5%BC%8F/\"\u003eReact Rerender-Move State Down模式\u003c/a\u003e我们了解到这会导致整个\u003ccode\u003eMainScrollableArea\u003c/code\u003e都会重新渲染。\u003c/p\u003e\n\u003cp\u003e于是我们可以将不依赖于\u003ccode\u003eposition\u003c/code\u003e的组件提取出来。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eScrollableWithMovingBlock\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e ({\u003cspan style=\"color:#a6e22e\"\u003echildren\u003c/span\u003e}) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e [\u003cspan style=\"color:#a6e22e\"\u003eposition\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003esetPosition\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e300\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonScroll\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecalculated\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egetPosition\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ee\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003escrollTop\u003c/span\u003e); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003esetPosition\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecalculated\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclassName\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;scrollable-block\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonScroll\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eonScroll\u003c/span\u003e}\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eMovingBlock\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eposition\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eposition\u003c/span\u003e} /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#75715e\"\u003e/* slow bunch of stuff used to be here, but not anymore */\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#a6e22e\"\u003echildren\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eApp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; { \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003eScrollableWithMovingBlock\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eVerySlowComponent\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eBunchOfStuff\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eOtherStuffAlsoComplicated\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003eScrollableWithMovingBlock\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这样\u003ccode\u003eVerySlowComponent\u003c/code\u003e、\u003ccode\u003eBunchOfStuff\u003c/code\u003e、\u003ccode\u003eOtherStuffAlsoComplicated\u003c/code\u003e这些组件就不会重新渲染了。有人可能会疑惑，为什么这样就不会重新渲染了呢？\u003ccode\u003eVerySlowComponent\u003c/code\u003e、\u003ccode\u003eBunchOfStuff\u003c/code\u003e、\u003ccode\u003eOtherStuffAlsoComplicated\u003c/code\u003e这些组件仍然在\u003ccode\u003eScrollableWithMovingBlock\u003c/code\u003e中，\u003ccode\u003eposition\u003c/code\u003e发生改变了，为啥它们不会重新渲染呢？\u003c/p\u003e","title":"React Rerender-Children as Props模式"},{"content":"作为一个React初学者，在写React程序的时候经常遇到rerender的问题。由于写的都比较简单，也没有关注rerender带来的问题。但是遇到问题了又到处Google找问题，还是比较浪费时间的。所以这次下定决心学习一下React的Rerender的机制。\n当Component第一次出现在屏幕上，我们称之为mounting。React会初始化Component的state, 运行hooks，添加element到dom中。\n当React检测到Component不再需要时，我们称之为unmounting。React会执行clean-up，销毁组件及其相关的state，最后从dom中移除element。\nrerender是在已经存在的Component的基础上，一些state发生了变化，导致Component重新渲染。相比于mounting会更加轻量。\n每次rerender都始于state的改变。你可以把React App想象成1棵树。state变化的那个节点会导致这个节点下面的所有分支节点都重新渲染。\n你可能听说过props改变了也会导致Component rerender。但这是个误解，出现这个根本原因还是因为state发生了变化。来看下面这个例子\nconst App = () =\u0026gt; { // local variable won\u0026#39;t work let isOpen = false; return ( \u0026lt;div className=\u0026#34;layout\u0026#34;\u0026gt; {/* nothing will happen */} \u0026lt;Button onClick={() =\u0026gt; (isOpen = true)}\u0026gt; Open dialog \u0026lt;/Button\u0026gt; {/* will never show up */} {isOpen ? ( \u0026lt;ModalDialog onClose={() =\u0026gt; (isOpen = false)} /\u0026gt; ) : null} \u0026lt;/div\u0026gt; ); }; 当点击Button的时候，isOpen会被改变，但是ModalDialog并没有重新渲染。local variable不会被React追踪，所以ModalDialog不会重新渲染。\n再看看下面的代码。isOpen的值发生改变，会导致整个App都会重新渲染。VerySlowComponent、BunchOfStuff、OtherStuffAlsoComplicated这些组件并不依赖isOpen，但是都进行了rerender。\nconst App = () =\u0026gt; { // our state is declared here const [isOpen, setIsOpen] = useState(false); return ( \u0026lt;div className=\u0026#34;layout\u0026#34;\u0026gt; {/* state is used here */} \u0026lt;Button onClick={() =\u0026gt; setIsOpen(true)}\u0026gt; Open dialog \u0026lt;/Button\u0026gt; {/* state is used here */} {isOpen ? ( \u0026lt;ModalDialog onClose={() =\u0026gt; setIsOpen(false)} /\u0026gt; ) : null} \u0026lt;VerySlowComponent /\u0026gt; \u0026lt;BunchOfStuff /\u0026gt; \u0026lt;OtherStuffAlsoComplicated /\u0026gt; \u0026lt;/div\u0026gt; ); }; 一种方式是React.memo进行包装。React.memo会对props进行浅比较，如果props没有改变，就不会重新渲染。\n但是这个例子中，并不需要使用memo，有更好的方式就是将state下沉下去。\nconst ButtonWithModalDialog = () =\u0026gt; { const [isOpen, setIsOpen] = useState(false); // render only Button and ModalDialog here return ( \u0026lt;\u0026gt; \u0026lt;Button onClick={() =\u0026gt; setIsOpen(true)}\u0026gt; Open dialog \u0026lt;/Button\u0026gt; {isOpen ? ( \u0026lt;ModalDialog onClose={() =\u0026gt; setIsOpen(false)} /\u0026gt; ) : null} \u0026lt;/\u0026gt; ); }; const App = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;layout\u0026#34;\u0026gt; {/* here it goes, component with the state inside */} \u0026lt;ButtonWithModalDialog /\u0026gt; \u0026lt;VerySlowComponent /\u0026gt; \u0026lt;BunchOfStuff /\u0026gt; \u0026lt;OtherStuffAlsoComplicated /\u0026gt; \u0026lt;/div\u0026gt; ); }; 现在点击Button的时候，只会重新渲染ButtonWithModalDialog，不会重新渲染其他组件。\n自定义hook的注意事项\n在上面这个例子中，可以简单的定义一个自定义hook -\u0026gt; useModalDialog\nconst useModalDialog = () =\u0026gt; { const [isOpen, setIsOpen] = useState(false); return { isOpen, open: () =\u0026gt; setIsOpen(true), close: () =\u0026gt; setIsOpen(false), }; }; const App = () =\u0026gt; { // state is in the hook now const { isOpen, open, close } = useModalDialog(); return ( \u0026lt;div className=\u0026#34;layout\u0026#34;\u0026gt; {/* just use \u0026#34;open\u0026#34; method from the hook */} \u0026lt;Button onClick={open}\u0026gt;Open dialog\u0026lt;/Button\u0026gt; {/* just use \u0026#34;close\u0026#34; method from the hook */} {isOpen ? \u0026lt;ModalDialog onClose={close} /\u0026gt; : null} \u0026lt;VerySlowComponent /\u0026gt; \u0026lt;BunchOfStuff /\u0026gt; \u0026lt;OtherStuffAlsoComplicated /\u0026gt; \u0026lt;/div\u0026gt; ); }; 自定义hook隐藏了在App中有state。所以当state发生变化会导致整个App重新渲染。尽管不在App中使用，或者自定义hook没有返回什么，也会导致整个App重新渲染。比如下面这样。\nconst useModalDialog = () =\u0026gt; { const [width, setWidth] = useState(0); useEffect(() =\u0026gt; { const listener = () =\u0026gt; { setWidth(window.innerWidth); } window.addEventListener(\u0026#39;resize\u0026#39;, listener); return () =\u0026gt; window.removeEventListener(\u0026#39;resize\u0026#39;, listener); }, []); // return is the same return ... } 整个App都会在resize的时候重新渲染。即使这个width没有返回。\nHooks就像裤子上面的口袋，你手举10kg的哑铃，将哑铃放在口袋里面并不能改变你携带10kg重物的事实。你需要将哑铃放置在手推车里面。\n即使hook依赖另外一个hook，也会导致整个App重新渲染。\nconst useResizeDetector = () =\u0026gt; { const [width, setWidth] = useState(0); useEffect(() =\u0026gt; { const listener = () =\u0026gt; { setWidth(window.innerWidth); }; window.addEventListener(\u0026#39;resize\u0026#39;, listener); return () =\u0026gt; window.removeEventListener(\u0026#39;resize\u0026#39;, listener); }, []); return null; } const useModalDialog = () =\u0026gt; { // I don\u0026#39;t even use it, just call it here useResizeDetector(); // return is the same return ... } const App = () =\u0026gt; { // this hook uses useResizeDetector underneath that triggers // state update on resize // the entire App will re-render on every resize! const { isOpen, open, close } = useModalDialog(); return // same return } 为了解决这个问题，还是需要将state下沉下去。\nconst ButtonWithModalDialog = () =\u0026gt; { const { isOpen, open, close } = useModalDialog(); // render only Button and ModalDialog here return ( \u0026lt;\u0026gt; \u0026lt;Button onClick={open}\u0026gt;Open dialog\u0026lt;/Button\u0026gt; {isOpen ? \u0026lt;ModalDialog onClose={close} /\u0026gt; : null} \u0026lt;/\u0026gt; ); }; 参考资料 React re-render 完全指南 Advanced React deep dives, investigations, performance patterns and techniques (Nadia Makarevich).pdf ","permalink":"https://carlos19960601.github.io/posts/react-rerender-move-state-down%E6%A8%A1%E5%BC%8F/","summary":"\u003cp\u003e作为一个React初学者，在写React程序的时候经常遇到rerender的问题。由于写的都比较简单，也没有关注rerender带来的问题。但是遇到问题了又到处Google找问题，还是比较浪费时间的。所以这次下定决心学习一下React的Rerender的机制。\u003c/p\u003e\n\u003cp\u003e当Component第一次出现在屏幕上，我们称之为\u003ccode\u003emounting\u003c/code\u003e。React会初始化Component的state, 运行hooks，添加element到dom中。\u003c/p\u003e\n\u003cp\u003e当React检测到Component不再需要时，我们称之为\u003ccode\u003eunmounting\u003c/code\u003e。React会执行clean-up，销毁组件及其相关的state，最后从dom中移除element。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ererender\u003c/code\u003e是在已经存在的Component的基础上，一些state发生了变化，导致Component重新渲染。相比于\u003ccode\u003emounting\u003c/code\u003e会更加轻量。\u003c/p\u003e\n\u003cp\u003e每次rerender都始于state的改变。你可以把React App想象成1棵树。state变化的那个节点会导致这个节点下面的所有分支节点都重新渲染。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e5%85%b3%e4%ba%8eReact%e7%9a%84rerender/rerender-state.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e你可能听说过props改变了也会导致Component rerender。但这是个误解，出现这个根本原因还是因为state发生了变化。来看下面这个例子\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eApp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// local variable won\u0026#39;t work \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eisOpen\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclassName\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;layout\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#75715e\"\u003e/* nothing will happen */\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eButton\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonClick\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{() =\u0026gt; (\u003cspan style=\"color:#a6e22e\"\u003eisOpen\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e)}\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eOpen\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edialog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;/\u003cspan style=\"color:#f92672\"\u003eButton\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#75715e\"\u003e/* will never show up */\u003c/span\u003e} \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#a6e22e\"\u003eisOpen\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;\u003cspan style=\"color:#f92672\"\u003eModalDialog\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonClose\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{() =\u0026gt; (\u003cspan style=\"color:#a6e22e\"\u003eisOpen\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e)} /\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      ) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当点击Button的时候，isOpen会被改变，但是ModalDialog并没有重新渲染。local variable不会被React追踪，所以ModalDialog不会重新渲染。\u003c/p\u003e\n\u003cp\u003e再看看下面的代码。isOpen的值发生改变，会导致整个App都会重新渲染。\u003ccode\u003eVerySlowComponent\u003c/code\u003e、\u003ccode\u003eBunchOfStuff\u003c/code\u003e、\u003ccode\u003eOtherStuffAlsoComplicated\u003c/code\u003e这些组件并不依赖isOpen，但是都进行了rerender。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eApp\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e () =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// our state is declared here\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e [\u003cspan style=\"color:#a6e22e\"\u003eisOpen\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003esetIsOpen\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclassName\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;layout\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#75715e\"\u003e/* state is used here */\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eButton\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonClick\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{() =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003esetIsOpen\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e)}\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eOpen\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edialog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;/\u003cspan style=\"color:#f92672\"\u003eButton\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#75715e\"\u003e/* state is used here */\u003c/span\u003e} \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#a6e22e\"\u003eisOpen\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;\u003cspan style=\"color:#f92672\"\u003eModalDialog\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonClose\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{() =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003esetIsOpen\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e)} /\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      ) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eVerySlowComponent\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eBunchOfStuff\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003eOtherStuffAlsoComplicated\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e一种方式是\u003ccode\u003eReact.memo\u003c/code\u003e进行包装。\u003ccode\u003eReact.memo\u003c/code\u003e会对props进行浅比较，如果props没有改变，就不会重新渲染。\u003c/p\u003e","title":"React Rerender-Move State Down模式"},{"content":"tailwindcss Arbitrary values 在使用tailwind的时候，如果遇到没有预定值的样式，就可以使用arbitrary values。\n比如：\nbg-[#ff8906] 就可以设置背景色为橙色。 w-[300px] 就可以设置宽度为300px。 还有一些，就是没有定义类型的，最常见的就是svg的属性。stroke-dasharray在tailwind中就没有定义类型，所以就可以使用arbitrary values。\n[stroke-dasharray:450,0]: 设置stroke-dasharray为450,0。 styling-based-on-parent-state 这种是在子元素依赖于父元素hover等状态时使用的。\n\u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;group block max-w-xs mx-auto rounded-lg p-6 bg-white ring-1 ring-slate-900/5 shadow-lg space-y-3 hover:bg-sky-500 hover:ring-sky-500\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex items-center space-x-3\u0026#34;\u0026gt; \u0026lt;svg class=\u0026#34;h-6 w-6 stroke-sky-500 group-hover:stroke-white\u0026#34; fill=\u0026#34;none\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34;\u0026gt;\u0026lt;!-- ... --\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;h3 class=\u0026#34;text-slate-900 group-hover:text-white text-sm font-semibold\u0026#34;\u0026gt;New project\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;text-slate-500 group-hover:text-white text-sm\u0026#34;\u0026gt;Create a new project from a variety of starting templates.\u0026lt;/p\u0026gt; \u0026lt;/a\u0026gt; 设置group，然后在子元素上使用group-hover。\nstroke-dasharray属性 首先这个是给svg使用的属性。控制stroke的dash长度和间隔长度。\nstroke-dasharray: 2; 表示dash的长度为2，间隔长度为2。 stroke-dasharray: 2 4; 表示dash的长度为2，间隔长度为4。 stroke-dasharray: 5 10 15; 表示dash的长度为5，间隔长度为10，dash的长度为15，间隔长度为5。 ","permalink":"https://carlos19960601.github.io/posts/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch3 id=\"tailwindcss\"\u003etailwindcss\u003c/h3\u003e\n\u003ch4 id=\"arbitrary-values\"\u003eArbitrary values\u003c/h4\u003e\n\u003cp\u003e在使用tailwind的时候，如果遇到没有预定值的样式，就可以使用arbitrary values。\u003c/p\u003e\n\u003cp\u003e比如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebg-[#ff8906]\u003c/code\u003e 就可以设置背景色为橙色。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ew-[300px]\u003c/code\u003e 就可以设置宽度为300px。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e还有一些，就是没有定义类型的，最常见的就是svg的属性。\u003ccode\u003estroke-dasharray\u003c/code\u003e在tailwind中就没有定义类型，所以就可以使用arbitrary values。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e[stroke-dasharray:450,0]\u003c/code\u003e: 设置stroke-dasharray为450,0。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"styling-based-on-parent-statehttpstailwindcsscomdocshover-focus-and-other-statesstyling-based-on-parent-state\"\u003e\u003ca href=\"https://tailwindcss.com/docs/hover-focus-and-other-states#styling-based-on-parent-state\"\u003estyling-based-on-parent-state\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这种是在子元素依赖于父元素hover等状态时使用的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003ea\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehref\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;#\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;group block max-w-xs mx-auto rounded-lg p-6 bg-white ring-1 ring-slate-900/5 shadow-lg space-y-3 hover:bg-sky-500 hover:ring-sky-500\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;flex items-center space-x-3\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003esvg\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;h-6 w-6 stroke-sky-500 group-hover:stroke-white\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efill\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviewBox\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;0 0 24 24\u0026#34;\u003c/span\u003e\u0026gt;\u003cspan style=\"color:#75715e\"\u003e\u0026lt;!-- ... --\u0026gt;\u003c/span\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003esvg\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003eh3\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text-slate-900 group-hover:text-white text-sm font-semibold\u0026#34;\u003c/span\u003e\u0026gt;New project\u0026lt;/\u003cspan style=\"color:#f92672\"\u003eh3\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;text-slate-500 group-hover:text-white text-sm\u0026#34;\u003c/span\u003e\u0026gt;Create a new project from a variety of starting templates.\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ep\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ea\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e设置\u003ccode\u003egroup\u003c/code\u003e，然后在子元素上使用\u003ccode\u003egroup-hover\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"stroke-dasharray属性httpscss-trickscomalmanacpropertiessstroke-dasharray\"\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/s/stroke-dasharray/\"\u003estroke-dasharray属性\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e首先这个是给svg使用的属性。控制stroke的dash长度和间隔长度。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estroke-dasharray: 2; 表示dash的长度为2，间隔长度为2。\u003c/li\u003e\n\u003cli\u003estroke-dasharray: 2 4; 表示dash的长度为2，间隔长度为4。\u003c/li\u003e\n\u003cli\u003estroke-dasharray: 5 10 15; 表示dash的长度为5，间隔长度为10，dash的长度为15，间隔长度为5。\u003c/li\u003e\n\u003c/ul\u003e","title":"Css学习笔记"},{"content":"npx 怎么用pnpm替代 Running executables inside your downloaded dependencies npx jest -\u0026gt; pnpm exec jest\nRunning executable commands in packages you want to download transiently npx create-react-app my-app -\u0026gt; pnpm dlx create-react-app my-app\npnpm 全局的公共依赖包\npnpm install react -w pnpm install rollup -wD 给某个package单独安装指定依赖\npnpm add axios --filter @qftjs/monorepo1 pnpm build --filter @qftjs/monorepo1 pnpm build --filter \u0026#34;./packages/**\u0026#34; 模块之间的相互依赖\npnpm install @qftjs/monorepo2 -r --filter @qftjs/monorepo1 参考资料\nCan I use npx with pnpm? 五险一金 养老保险：\n个人: 8% 单位: 16% typescripe 别名 開發環境下，我們使用 nodemon，而 nodemon 又是使用 ts-node，所以我們的目標便是讓 ts-node 套件可以解析路徑別名\npnpm i -D tsconfig-paths { // 引入 tsconfig-paths/register // 注意 ts-node 的層級與 compilerOptions 相同 \u0026#34;ts-node\u0026#34;: { \u0026#34;require\u0026#34;: [\u0026#34;tsconfig-paths/register\u0026#34;] }, \u0026#34;compilerOptions\u0026#34;: { // ... // 配置需要的 alias \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@middleware/*\u0026#34;: [\u0026#34;middleware/*\u0026#34;], }, // ... } } npm install --save-dev tsc-alias typescript express 設定路徑別名 (alias) tsc - doesn\u0026rsquo;t compile alias paths ubuntu默认会启动53端口 我们可以修改/etc/systemd/resolved.conf中DNSStubListener的注释行，它将不再打开dns服务\n","permalink":"https://carlos19960601.github.io/posts/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/","summary":"\u003ch3 id=\"npx-怎么用pnpm替代\"\u003enpx 怎么用pnpm替代\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRunning executables inside your downloaded dependencies\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003enpx jest\u003c/code\u003e -\u0026gt; \u003ccode\u003epnpm exec jest\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRunning executable commands in packages you want to download transiently\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003enpx create-react-app my-app\u003c/code\u003e -\u0026gt; \u003ccode\u003epnpm dlx create-react-app my-app\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"pnpm\"\u003epnpm\u003c/h3\u003e\n\u003cp\u003e全局的公共依赖包\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epnpm install react -w\n\npnpm install rollup -wD\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e给某个package单独安装指定依赖\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epnpm add axios --filter @qftjs/monorepo1\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epnpm build --filter @qftjs/monorepo1\n\npnpm build --filter \u0026#34;./packages/**\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e模块之间的相互依赖\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epnpm install @qftjs/monorepo2 -r --filter @qftjs/monorepo1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e参考资料\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/75413361/can-i-use-npx-with-pnpm\"\u003eCan I use npx with pnpm?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"五险一金\"\u003e五险一金\u003c/h3\u003e\n\u003cp\u003e养老保险：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e个人: 8% 单位: 16%\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"typescripe-别名\"\u003etypescripe 别名\u003c/h3\u003e\n\u003cp\u003e開發環境下，我們使用 nodemon，而 nodemon 又是使用 ts-node，所以我們的目標便是讓 ts-node 套件可以解析路徑別名\u003c/p\u003e","title":"杂七杂八"},{"content":"HTTP协议 明文传输 -\u0026gt; 导致 内容会被篡改（中间人攻击）-\u0026gt; 解决方案：加密 加密方式\n对称加密：加密和解密使用的同一个密钥 非对称加密: 公钥和私钥有个特别的单向性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。 结合这2种加密方式就能完成密钥互换 -\u0026gt; 破解方式: 中间人模拟服务器行为 -\u0026gt; HTTPS\n简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。\nHTTPS协议 中间人模拟服务器行为主要原因是 中间人不被信任，那么HTTPS有CA 认证体系，\nCA 签发证书的过程，如上图左边部分：\n⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值； 然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名； 最后将 Certificate Signature 添加在⽂件证书上，形成数字证书； 客户端校验服务端的数字证书的过程，如上图右边部分：\n⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1； 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate Signature 内容，得到⼀个 Hash 值 H2 ； 最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 HTTPS抓包：\n抓包出来都是加密的数据，抓包工具模拟中间人，伪造证书，客户端会提示证书不被信任，如果客户端同意，请求就会被抓包工具拦截，转发给服务端。\nHTTP2 HTTP/1.1 协议的性能缺陷：\n高延迟：页面访问速度下降 -\u0026gt; 主要由于队头阻塞 HTTP/1.1 版引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求，进一步改进了 HTTP 协议的效率\n但这要求服务端必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 (Head-Of-Line Blocking)\n明文传输：不安全 无状态：头部巨大切重复 不支持服务器推送 HTTP/2 新特性\n二进制传输 多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装\nHeader 压缩（HPACK） 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n多路复用 服务端 Push 提高安全性 HTTP2解决了HTTP1.X的队头阻塞，但是TCP的的队头阻塞仍然存在。如果出现TCP丢包，可能还更严重。\nHTTP3 参考说一下 HTTP/3 新特性，为什么选择使用 UDP 协议？\n参考资料 为什么说HTTPS比HTTP安全呢 HTTP/2对比HTTP/1.1，特性是什么？是如何解决队头阻塞与压缩头部的？ 说一下 HTTP/3 新特性，为什么选择使用 UDP 协议？ 面渣逆袭：三万字，七十图详解计算机网络六十二问（建议收藏) HTTP和TCP协议的队头阻塞 ","permalink":"https://carlos19960601.github.io/posts/http%E5%8D%8F%E8%AE%AE/","summary":"\u003ch3 id=\"http协议\"\u003eHTTP协议\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e明文传输 -\u0026gt; 导致 内容会被篡改（中间人攻击）-\u0026gt; 解决方案：加密\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e加密方式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对称加密：加密和解密使用的同一个密钥\u003c/li\u003e\n\u003cli\u003e非对称加密: 公钥和私钥有个特别的单向性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e结合这2种加密方式就能完成密钥互换 -\u0026gt; 破解方式: 中间人模拟服务器行为 -\u0026gt; HTTPS\u003c/p\u003e\n\u003cp\u003e简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。\u003c/p\u003e\n\u003ch3 id=\"https协议\"\u003eHTTPS协议\u003c/h3\u003e\n\u003cp\u003e中间人模拟服务器行为主要原因是 中间人不被信任，那么HTTPS有\u003cstrong\u003eCA 认证体系\u003c/strong\u003e，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/http%e5%8d%8f%e8%ae%ae/CA%e7%ad%be%e5%8f%91%e8%af%81%e4%b9%a6.png\" alt=\"CA签发证书\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eCA 签发证书的过程，如上图左边部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；\u003c/li\u003e\n\u003cli\u003e然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；\u003c/li\u003e\n\u003cli\u003e最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e客户端校验服务端的数字证书的过程，如上图右边部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；\u003c/li\u003e\n\u003cli\u003e通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate\u003c/li\u003e\n\u003cli\u003eSignature 内容，得到⼀个 Hash 值 H2 ；\u003c/li\u003e\n\u003cli\u003e最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHTTPS抓包：\u003c/p\u003e\n\u003cp\u003e抓包出来都是加密的数据，抓包工具模拟中间人，伪造证书，客户端会提示证书不被信任，如果客户端同意，请求就会被抓包工具拦截，转发给服务端。\u003c/p\u003e","title":"HTTP协议"},{"content":"标记重要的代码点 在阅读代码的时候，有一些关键代码(比如核心逻辑、代码入口等)需要经常找，所以我想要够标记一下，这样就能快速定位。\n可以借助TODO Tree插件标记todo一样。自定义一个IMPORTANT\n\u0026#34;todo-tree.highlights.customHighlight\u0026#34;: { ... \u0026#34;IMPORTANT\u0026#34;: { \u0026#34;background\u0026#34;: \u0026#34;#ff000080\u0026#34; } }, 使用的时候像这样就能够在TODO tree里面看到了。\n// IMPORTANT: 本地流量入口 listener.ReCreateHTTP(general.Port, tunnel.Tunnel) 光标移动更加顺滑 { \u0026#34;editor.smoothScrolling\u0026#34;: true, \u0026#34;editor.cursorBlinking\u0026#34;: \u0026#34;smooth\u0026#34;, } ","permalink":"https://carlos19960601.github.io/posts/vscode%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","summary":"\u003ch3 id=\"标记重要的代码点\"\u003e标记重要的代码点\u003c/h3\u003e\n\u003cp\u003e在阅读代码的时候，有一些关键代码(比如核心逻辑、代码入口等)需要经常找，所以我想要够标记一下，这样就能快速定位。\u003c/p\u003e\n\u003cp\u003e可以借助\u003ccode\u003eTODO Tree\u003c/code\u003e插件标记todo一样。自定义一个\u003ccode\u003eIMPORTANT\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;todo-tree.highlights.customHighlight\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e\u0026#34;IMPORTANT\u0026#34;\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;background\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;#ff000080\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用的时候像这样就能够在\u003ccode\u003eTODO tree\u003c/code\u003e里面看到了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// IMPORTANT: 本地流量入口\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003elistener\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eReCreateHTTP\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003egeneral\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePort\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003etunnel\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eTunnel\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"光标移动更加顺滑\"\u003e光标移动更加顺滑\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;editor.smoothScrolling\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;editor.cursorBlinking\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;smooth\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Vscode使用小技巧"},{"content":"Chapter 1: The Machine Learning Landscape 机器学习分类：\n是否监督\n监督学习(Supervised learning) 非监督学习(Unsupervised learning) 半监督学习(Semi-supervised learning) 自监督学习(Self-supervised learning) 强化学习(Reinforcement learning) 批量vs在线学习\nBatch learning Online learning Instance-Based Versus Model-Based Learning\nInstance-based learning Model-based learning and a typical machine learning workflow 机器学习的主要挑战\n训练数据量不足(Insufficient Quantity of Training Data) 非代表性训练数据(Nonrepresentative Training Data) 劣质数据(Poor-Quality Data) 不相关特征(Irrelevant Features) 过拟合(Overfitting the Training Data) 欠拟合(Underfitting the Training Data) Chapter 2: End-to-End Machine Learning Project 通过一个预测房价的实例介绍机器学习实践流程。\n前提是明确需求的情况下，现在手里有一份数据。怎么开始进行机器学习。\n首先了解数据，整体熟悉数据结构。 panda查看数据统计 matplotlib绘制图标 创建测试集 分层抽样 测试集不要在训练阶段使用 抽样要随机 结果要保持一致，不要多次创建测试集后，让模型学习了所有数据 看看数据分布 看看相关性(Correlations) 尝试组合特征 数据预处理 缺失值补齐 处理分类数据 特征缩放 选择和训练模型 尝试不同的模型 交叉验证不同模型的效果 微调模型 Grid Search Randomized Search 分析模型和错误 在测试集上评估模型 上线模型 Chapter 3: Classification 通过一个识别手写数字的实例介绍分类。\n识别手写数字和预测房价不同的地方在于Performance Measures。预测房价使用是通哟RMSE(root mean squred error)。识别手写数字这里使用这种方式就会有误导。\n混淆矩阵(Confusion Matrices) 准确率和召回率(Precision and Recall) ROC缺陷(The ROC Curve) 分类又可以分为多种\nMulticlass Classification Multilabel Classification Multioutput Classification Chapter 4: Training Models ","permalink":"https://carlos19960601.github.io/posts/hands-on-machine-learning-with-scikit-learn-keras-and-tensorflow-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"chapter-1-the-machine-learning-landscape\"\u003eChapter 1: The Machine Learning Landscape\u003c/h1\u003e\n\u003cp\u003e机器学习分类：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e是否监督\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e监督学习(Supervised learning)\u003c/li\u003e\n\u003cli\u003e非监督学习(Unsupervised learning)\u003c/li\u003e\n\u003cli\u003e半监督学习(Semi-supervised learning)\u003c/li\u003e\n\u003cli\u003e自监督学习(Self-supervised learning)\u003c/li\u003e\n\u003cli\u003e强化学习(Reinforcement learning)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e批量vs在线学习\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBatch learning\u003c/li\u003e\n\u003cli\u003eOnline learning\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eInstance-Based Versus Model-Based Learning\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstance-based learning\u003c/li\u003e\n\u003cli\u003eModel-based learning and a typical machine learning workflow\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e机器学习的主要挑战\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e训练数据量不足(Insufficient Quantity of Training Data)\u003c/li\u003e\n\u003cli\u003e非代表性训练数据(Nonrepresentative Training Data)\u003c/li\u003e\n\u003cli\u003e劣质数据(Poor-Quality Data)\u003c/li\u003e\n\u003cli\u003e不相关特征(Irrelevant Features)\u003c/li\u003e\n\u003cli\u003e过拟合(Overfitting the Training Data)\u003c/li\u003e\n\u003cli\u003e欠拟合(Underfitting the Training Data)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"chapter-2-end-to-end-machine-learning-project\"\u003eChapter 2: End-to-End Machine Learning Project\u003c/h1\u003e\n\u003cp\u003e通过一个预测房价的实例介绍机器学习实践流程。\u003c/p\u003e\n\u003cp\u003e前提是明确需求的情况下，现在手里有一份数据。怎么开始进行机器学习。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先了解数据，整体熟悉数据结构。\n\u003col\u003e\n\u003cli\u003epanda查看数据统计\u003c/li\u003e\n\u003cli\u003ematplotlib绘制图标\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e创建测试集\n\u003col\u003e\n\u003cli\u003e分层抽样\u003c/li\u003e\n\u003cli\u003e测试集不要在训练阶段使用\u003c/li\u003e\n\u003cli\u003e抽样要随机\u003c/li\u003e\n\u003cli\u003e结果要保持一致，不要多次创建测试集后，让模型学习了所有数据\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e看看数据分布\n\u003col\u003e\n\u003cli\u003e看看相关性(Correlations)\u003c/li\u003e\n\u003cli\u003e尝试组合特征\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e数据预处理\n\u003col\u003e\n\u003cli\u003e缺失值补齐\u003c/li\u003e\n\u003cli\u003e处理分类数据\u003c/li\u003e\n\u003cli\u003e特征缩放\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e选择和训练模型\n\u003col\u003e\n\u003cli\u003e尝试不同的模型\u003c/li\u003e\n\u003cli\u003e交叉验证不同模型的效果\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e微调模型\n\u003col\u003e\n\u003cli\u003eGrid Search\u003c/li\u003e\n\u003cli\u003eRandomized Search\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e分析模型和错误\u003c/li\u003e\n\u003cli\u003e在测试集上评估模型\u003c/li\u003e\n\u003cli\u003e上线模型\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"chapter-3-classification\"\u003eChapter 3: Classification\u003c/h1\u003e\n\u003cp\u003e通过一个识别手写数字的实例介绍分类。\u003c/p\u003e","title":"Hands on Machine Learning With Scikit Learn, Keras, and TensorFlow 学习笔记"},{"content":"背景 最近在写项目的时候，发现如果后端没有处理CORS的问题，前端使用Axios请求数据的时候，会直接报Axios Network Error。影响了开发。\n解决 一般情况下后端服务都会有CORS middleware。能够直接解决CORS的问题。但是如果每个服务都这样，我觉得麻烦。所以尝试使用Nginx来同样处理。\n跨域相关的响应头\nAccess-Control-Allow-Origin: Used to set the source address that allows cross-domain requests (preflight requests and formal requests will be verified when cross-domain) Access-Control-Allow-Headers: Special header information fields allowed to be carried across domains (only verified in preflight requests) Access-Control-Allow-Methods: Cross-domain allowed request methods or HTTP verbs (only in preflight request verification) Access-Control-Allow-Credentials: Whether to allow the use of cookies across domains. If you want to use cookies across domains, you can add this request response header and set the value to true (setting it or not setting it will not affect the sending of the request, but will only affect whether cookies should be carried across domains. , but if set, both preflight requests and formal requests need to be set). However, it is not recommended to use it cross-domain (it has been used in the project, but it is unstable and cannot be carried by some browsers) unless necessary, because there are many alternatives. 如果出现跨域，直接在前端请求会报错\nAccess to XMLHttpRequest at \u0026#39;http://localhost:22222/api/Login/TestGet\u0026#39; from origin \u0026#39;http://localhost:8080\u0026#39; has been blocked by CORS policy: Response to preflight request doesn\u0026#39;t pass access control check: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. 跨域机制会让浏览器发送一个OPTIONS的preflight请求，只有这个请求成功后，后续才会发送正常的请求。\n从报错信息种可以看出 preflight 请求种缺少\u0026rsquo;Access-Control-Allow-Origin\u0026rsquo;这个header。我们在Nginx中添加上这个header\nlocation / { add_header Access-Control-Allow-Origin $http_origin; } 但是加上后仍然报相同的错误。\n参考add_header Directives的文档。只有返回对应的http status code的时候，才会执行add_header指令。如果想直接添加需要添加always。\nlocation / { add_header Access-Control-Allow-Origin $http_origin always; } 这次错误不再是之前的错误了，但是出现了新的错误\nAccess to XMLHttpRequest at \u0026#39;http://api.admin.collie.io/v1/vocabulary/search?keyword=\u0026#39; from origin \u0026#39;http://localhost:3000\u0026#39; has been blocked by CORS policy: Response to preflight request doesn\u0026#39;t pass access control check: It does not have HTTP ok status. 从错误信息种可以知道preflight请求没有收到HTTP ok status. 所以修改一下配置\nlocation / { add_header Access-Control-Allow-Origin $http_origin always; if ($request_method = \u0026#39;OPTIONS\u0026#39;) { return 204; } } 加上之后，错误又发生变化了。authorization这个header没有添加到Access-Control-Allow-Headers里面。这个是跨域机制保证安全，在preflight请求中收到的Access-Control-Allow-Headers中设置的header才能后续正常的请求中发送给服务器。\nccess to XMLHttpRequest at \u0026#39;http://api.admin.collie.io/v1/vocabulary/search?keyword=\u0026#39; from origin \u0026#39;http://localhost:3000\u0026#39; has been blocked by CORS policy: Request header field authorization is not allowed by Access-Control-Allow-Headers in preflight response. 继续修改一下配置\nlocation / { add_header Access-Control-Allow-Origin $http_origin always; if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header Access-Control-Allow-Headers \u0026#39;*\u0026#39;; #为什么写在if里面而不是接着Access-Control-Allow-Origin往下写？因为这里只有预检请求才会检查 return 204; } } 如果这么配置你会发现，有会出现最开始的那个错误\nAccess to XMLHttpRequest at \u0026#39;http://api.admin.collie.io/v1/vocabulary/search?keyword=\u0026#39; from origin \u0026#39;http://localhost:3000\u0026#39; has been blocked by CORS policy: Response to preflight request doesn\u0026#39;t pass access control check: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. 在Nginx的文档中是这么描述的\nThere could be several add_header directives. These directives are inherited from the previous configuration level if and only if there are no add_header directives defined on the current level.\n所以如果在同一级下有了add_header指令，就不会继承上一级的add_header指令了，也就是说，如果按照上面这样配置Access-Control-Allow-Origin就会没有，出现最开始的这个错误。\n后续还是会出现其他错误，基本上就是添加Access-Control-Allow-Methods、Access-Control-Allow-Headers这些问题就不再继续下去了。\n最后就是我最后的Nginx的配置\nlocation / { add_header Access-Control-Allow-Origin $http_origin always; add_header Access-Control-Allow-Credentials \u0026#39;true\u0026#39;; add_header Access-Control-Allow-Methods \u0026#39;*\u0026#39;; add_header Access-Control-Allow-Headers \u0026#39;*\u0026#39;; if ($request_method = \u0026#39;OPTIONS\u0026#39;) { return 204; } } 参考文档 Nginx easily solves cross-domain issues ","permalink":"https://carlos19960601.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/","summary":"\u003ch3 id=\"背景\"\u003e背景\u003c/h3\u003e\n\u003cp\u003e最近在写项目的时候，发现如果后端没有处理CORS的问题，前端使用Axios请求数据的时候，会直接报Axios Network Error。影响了开发。\u003c/p\u003e\n\u003ch3 id=\"解决\"\u003e解决\u003c/h3\u003e\n\u003cp\u003e一般情况下后端服务都会有CORS middleware。能够直接解决CORS的问题。但是如果每个服务都这样，我觉得麻烦。所以尝试使用Nginx来同样处理。\u003c/p\u003e\n\u003cp\u003e跨域相关的响应头\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAccess-Control-Allow-Origin\u003c/strong\u003e: Used to set the source address that allows cross-domain requests (preflight requests and formal requests will be verified when cross-domain)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccess-Control-Allow-Headers\u003c/strong\u003e: Special header information fields allowed to be carried across domains (only verified in preflight requests)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccess-Control-Allow-Methods\u003c/strong\u003e: Cross-domain allowed request methods or HTTP verbs (only in preflight request verification)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccess-Control-Allow-Credentials\u003c/strong\u003e: Whether to allow the use of cookies across domains. If you want to use cookies across domains, you can add this request response header and set the value to true (setting it or not setting it will not affect the sending of the request, but will only affect whether cookies should be carried across domains. , but if set, both preflight requests and formal requests need to be set). However, it is not recommended to use it cross-domain (it has been used in the project, but it is unstable and cannot be carried by some browsers) unless necessary, because there are many alternatives.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果出现跨域，直接在前端请求会报错\u003c/p\u003e","title":"浏览器跨域"},{"content":"数据库 Count(*)、Count(1)、Count(0)、Count(id)、Count(name)之间的区别? Count都会进行一次全表便利，Count(*)、Count(1)、Count(0)不会从底层获取数据，直接进行count++。但是id和name会从底层获取数据进行判断是否为null才进行count++。此外MySQL会借助占用页最小的索引进行遍历。\n系统设计 怎么避免单点故障(SPOF、Single Point of Failure)？ Redundancy(冗余): Primary vs Standby，比如流量入口，load banlaner进行主备 Load Balancing(负载均衡) Data Replication(数据复制): 数据库、缓存的主从 Geographic Distributio(异地多活)：异地多集群的数据复制（同步或异步） Graceful Handling of Failures Monitoring and Alerting 技术选型 SQL vs NoSQL 数据模型: schema vs schema-less(Key-Value Model, Document Model, Column-Family Model, Graph Model ) 扩展性: 垂直扩展 vs 水平扩展 查询语言：SQL vs 无固定标准 事务：ACID vs BASE 性能：对Schema明确，查询模式固定的方式，SQL查询效率高 具体系统设计Blog Design Spotify - System Design Interview Design a Scalable Notification Service - System Design Interview 参考资料 麻烦不要再问我count(*)、count(1)、count(id)、count(name)之间的区别了 System Design: How to Avoid Single Point of Failures? SQL vs NoSQL - 7 Key Differences You Must Know 网络协议 DNS 完整查询过程? DNS 查询请求过程和域名缓存结合起来，完整查询过程👇：\n首先搜索 浏览器的 DNS 缓存 ，缓存中维护一张域名与 IP 地址的对应表 如果没有命中😢，则继续搜索 操作系统的 DNS 缓存 如果依然没有命中🤦‍♀️，则操作系统将域名发送至 本地域名服务器 ，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是 递归查询 ） 若本地域名服务器的 DNS 缓存没有命中🤦‍，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行 迭代查询 （注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）： 首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址 本地域名服务器 将得到的 IP 地址返回给操作系统，同时自己将 IP 地址 缓存 起来📝 操作系统 将 IP 地址返回给浏览器，同时自己也将 IP 地址 缓存 起来📝 至此， 浏览器 就得到了域名对应的 IP 地址，并将 IP 地址 缓存 起来📝 TCP建立连接(3次握手)流程 为什么需要3次？ 为了防止服务器端开启一些无用的连接增加服务器开销 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 TCP断开连接(4次挥手)流程 为什么客户端在TIME-WAIT阶段要等2MSL？ 为的是确认服务器端是否收到客户端发出的 ACK 确认报文\n参考资料 DNS 协议是什么？完整查询过程？为什么选择使用 UDP 协议发起 DNS 查询？ “三次握手，四次挥手”这么讲，保证你忘不了 ","permalink":"https://carlos19960601.github.io/posts/%E9%9D%A2%E8%AF%95/","summary":"\u003ch3 id=\"数据库\"\u003e数据库\u003c/h3\u003e\n\u003ch4 id=\"countcount1count0countidcountname之间的区别\"\u003eCount(*)、Count(1)、Count(0)、Count(id)、Count(name)之间的区别?\u003c/h4\u003e\n\u003cp\u003eCount都会进行一次全表便利，Count(*)、Count(1)、Count(0)不会从底层获取数据，直接进行count++。但是id和name会从底层获取数据进行判断是否为null才进行count++。此外MySQL会借助占用页最小的索引进行遍历。\u003c/p\u003e\n\u003ch3 id=\"系统设计\"\u003e系统设计\u003c/h3\u003e\n\u003ch4 id=\"怎么避免单点故障spofsingle-point-of-failure\"\u003e怎么避免单点故障(SPOF、Single Point of Failure)？\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eRedundancy(冗余): Primary vs Standby，比如流量入口，load banlaner进行主备\u003c/li\u003e\n\u003cli\u003eLoad Balancing(负载均衡)\u003c/li\u003e\n\u003cli\u003eData Replication(数据复制): 数据库、缓存的主从\u003c/li\u003e\n\u003cli\u003eGeographic Distributio(异地多活)：异地多集群的数据复制（同步或异步）\u003c/li\u003e\n\u003cli\u003eGraceful Handling of Failures\u003c/li\u003e\n\u003cli\u003eMonitoring and Alerting\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"技术选型\"\u003e技术选型\u003c/h3\u003e\n\u003ch4 id=\"sql-vs-nosql\"\u003eSQL vs NoSQL\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e数据模型: schema vs schema-less(Key-Value Model, Document Model, Column-Family Model, Graph Model )\u003c/li\u003e\n\u003cli\u003e扩展性: 垂直扩展 vs 水平扩展\u003c/li\u003e\n\u003cli\u003e查询语言：SQL vs 无固定标准\u003c/li\u003e\n\u003cli\u003e事务：ACID vs BASE\u003c/li\u003e\n\u003cli\u003e性能：对Schema明确，查询模式固定的方式，SQL查询效率高\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e9%9d%a2%e8%af%95/SQLvsNoSQL.png\" alt=\"SQL vs NoSQL\"  /\u003e\n\u003c/p\u003e\n\u003ch4 id=\"具体系统设计blog\"\u003e具体系统设计Blog\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.algomaster.io/p/design-spotify-system-design-interview\"\u003eDesign Spotify - System Design Interview\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.algomaster.io/p/design-a-scalable-notification-service\"\u003eDesign a Scalable Notification Service - System Design Interview\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"参考资料\"\u003e参考资料\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7397410962847039525\"\u003e麻烦不要再问我count(*)、count(1)、count(id)、count(name)之间的区别了\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.algomaster.io/p/system-design-how-to-avoid-single-point-of-failures\"\u003eSystem Design: How to Avoid Single Point of Failures?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.algomaster.io/p/sql-vs-nosql-7-key-differences\"\u003eSQL vs NoSQL - 7 Key Differences You Must Know\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"网络协议\"\u003e网络协议\u003c/h3\u003e\n\u003ch4 id=\"dns-完整查询过程\"\u003eDNS 完整查询过程?\u003c/h4\u003e\n\u003cp\u003eDNS 查询请求过程和域名缓存结合起来，完整查询过程👇：\u003c/p\u003e","title":"面试"},{"content":"commit 消息提交规范 feat: 新功能（feature）\n用于提交新功能。 例如：feat: 增加用户注册功能 fix: 修复 bug\n用于提交 bug 修复。 例如：fix: 修复登录页面崩溃的问题 docs: 文档变更\n用于提交仅文档相关的修改。 例如：docs: 更新README文件 style: 代码风格变动（不影响代码逻辑）\n用于提交仅格式化、标点符号、空白等不影响代码运行的变更。 例如：style: 删除多余的空行 refactor: 代码重构（既不是新增功能也不是修复bug的代码更改）\n用于提交代码重构。 例如：refactor: 重构用户验证逻辑 perf: 性能优化\n用于提交提升性能的代码修改。 例如：perf: 优化图片加载速度 test: 添加或修改测试\n用于提交测试相关的内容。 例如：test: 增加用户模块的单元测试 chore: 杂项（构建过程或辅助工具的变动）\n用于提交构建过程、辅助工具等相关的内容修改。 例如：chore: 更新依赖库 build: 构建系统或外部依赖项的变更\n用于提交影响构建系统的更改。 例如：build: 升级webpack到版本5 ci: 持续集成配置的变更\n用于提交CI配置文件和脚本的修改。 例如：ci: 修改GitHub Actions配置文件 revert: 回滚\n用于提交回滚之前的提交。 例如：revert: 回滚feat: 增加用户注册功能 ","permalink":"https://carlos19960601.github.io/posts/git%E5%AD%A6%E4%B9%A0/","summary":"\u003ch3 id=\"commit-消息提交规范\"\u003ecommit 消息提交规范\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003efeat: 新功能（feature）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交新功能。\u003c/li\u003e\n\u003cli\u003e例如：feat: 增加用户注册功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003efix: 修复 bug\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交 bug 修复。\u003c/li\u003e\n\u003cli\u003e例如：fix: 修复登录页面崩溃的问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003edocs: 文档变更\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交仅文档相关的修改。\u003c/li\u003e\n\u003cli\u003e例如：docs: 更新README文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003estyle: 代码风格变动（不影响代码逻辑）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交仅格式化、标点符号、空白等不影响代码运行的变更。\u003c/li\u003e\n\u003cli\u003e例如：style: 删除多余的空行\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003erefactor: 代码重构（既不是新增功能也不是修复bug的代码更改）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交代码重构。\u003c/li\u003e\n\u003cli\u003e例如：refactor: 重构用户验证逻辑\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eperf: 性能优化\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交提升性能的代码修改。\u003c/li\u003e\n\u003cli\u003e例如：perf: 优化图片加载速度\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003etest: 添加或修改测试\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交测试相关的内容。\u003c/li\u003e\n\u003cli\u003e例如：test: 增加用户模块的单元测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003echore: 杂项（构建过程或辅助工具的变动）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交构建过程、辅助工具等相关的内容修改。\u003c/li\u003e\n\u003cli\u003e例如：chore: 更新依赖库\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ebuild: 构建系统或外部依赖项的变更\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交影响构建系统的更改。\u003c/li\u003e\n\u003cli\u003e例如：build: 升级webpack到版本5\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eci: 持续集成配置的变更\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交CI配置文件和脚本的修改。\u003c/li\u003e\n\u003cli\u003e例如：ci: 修改GitHub Actions配置文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003erevert: 回滚\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用于提交回滚之前的提交。\u003c/li\u003e\n\u003cli\u003e例如：revert: 回滚feat: 增加用户注册功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Git学习"},{"content":"官方教程 Learn Next.js 服务端组件示例 创建一个名为 app/api/posts/route.ts 的文件，用于定义路由处理程序：\nimport { db } from \u0026#39;../../lib/db\u0026#39;; export async function GET(request: Request) { const posts = await db.post.findMany(); return new Response(JSON.stringify(posts), { status: 200 }); } 在页面组件中使用 fetch 和 getServerSideProps 获取数据并展示：\n// pages/posts/index.tsx import { useEffect, useState } from \u0026#39;react\u0026#39;; export async function getServerSideProps() { const response = await fetch(\u0026#39;/api/posts\u0026#39;); const data = await response.json(); return { props: { posts: data, }, }; } export default function PostsPage({ posts }: { posts: any[] }) { return ( \u0026lt;div\u0026gt; {posts.map((post) =\u0026gt; ( \u0026lt;div key={post.id}\u0026gt; \u0026lt;h2\u0026gt;{post.title}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{post.content}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ); } Should I use SWR or Server Actions? No exact answer - but here is what I do:\nFor pure mutations, I prefer Server Actions. For pulling data from the server-side as a result of user interactions, I use SWR. Ultimately, you should use what you feel more comfortable with as both approaches are valid.\n参考：\nhttps://makerkit.dev/how-to/next-supabase/api-routes-vs-server-actions https://stackoverflow.com/questions/77748391/nextjs-14-server-actions-vs-route-handlers 个人理解：nextjs 让前端有能力连接数据库，成为全干工程师。\n当在技术选型的时候，如果项目比较小，并且只是对数据库的CRUD等操作，使用nextjs + prisma就可以实现\n如果项目较为复杂，还是只使用nextjs的前端能力，后端的事情还是单独部署\n对于单纯使用nextjs的前端能力，如果需要初始化websockets，可以封装成hook 或者 在 lib 或 utils 目录下创建websockets客户端\n","permalink":"https://carlos19960601.github.io/posts/nextjs%E5%AD%A6%E4%B9%A0/","summary":"\u003ch3 id=\"官方教程\"\u003e官方教程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/learn/dashboard-app\"\u003eLearn Next.js\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"服务端组件示例\"\u003e服务端组件示例\u003c/h3\u003e\n\u003cp\u003e创建一个名为 app/api/posts/route.ts 的文件，用于定义路由处理程序：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimport\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003edb\u003c/span\u003e } \u003cspan style=\"color:#66d9ef\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;../../lib/db\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eexport\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eGET\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003erequest\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eRequest\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edb\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epost\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindMany\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eResponse\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eJSON\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003estringify\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e), { \u003cspan style=\"color:#a6e22e\"\u003estatus\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e200\u003c/span\u003e });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在页面组件中使用 \u003ccode\u003efetch\u003c/code\u003e 和 \u003ccode\u003egetServerSideProps\u003c/code\u003e 获取数据并展示：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// pages/posts/index.tsx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eimport\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003euseEffect\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003euseState\u003c/span\u003e } \u003cspan style=\"color:#66d9ef\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;react\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eexport\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egetServerSideProps() {\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresponse\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efetch\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;/api/posts\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresponse\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eprops\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003edata\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eexport\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edefault\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePostsPage\u003c/span\u003e({ \u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e }\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eany\u003c/span\u003e[] }) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      {\u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003epost\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e=\u0026gt;\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ekey\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003epost\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e}\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u0026lt;\u003cspan style=\"color:#f92672\"\u003eh2\u003c/span\u003e\u0026gt;{\u003cspan style=\"color:#a6e22e\"\u003epost\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003etitle\u003c/span\u003e}\u0026lt;/\u003cspan style=\"color:#f92672\"\u003eh2\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u0026lt;\u003cspan style=\"color:#f92672\"\u003ep\u003c/span\u003e\u0026gt;{\u003cspan style=\"color:#a6e22e\"\u003epost\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtent\u003c/span\u003e}\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ep\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      ))}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  );\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"should-i-use-swr-or-server-actions\"\u003eShould I use SWR or Server Actions?\u003c/h3\u003e\n\u003cp\u003eNo exact answer - but here is what I do:\u003c/p\u003e","title":"Nextjs学习"},{"content":"Twitter/X 博主@_georgemoller的分享 主要记录Twitter博主@_georgemoller分享的React技巧。对于我这种React小白很使用。于是搬运过来，并附上个人的一些理解。如有问题请邮箱本人，欢迎各位指正。\nSolve re-render issues with composition 个人理解：功能单一，利用组合模式减少耦合，带来不必要的重新渲染\nUtility Types For Enhanced Reusablity 个人理解：Typescript Pick的使用\nBad use case for useCallback useCallback 使用在复杂逻辑的组件，简单组件不会消耗造成性能问题时不必使用\nIntersection types to extends native props in a component Don\u0026rsquo;t listen for ref changes with useEffect 本人曾经这么干过\nuseEffect vs useLayoutEffect 个人理解：useLayoutEffect在DOM更新后，浏览器绘制前执行。useEffect在DOM更新后，浏览器绘制后执行。\nSeparation of Concerns in React React中的关注点分离 这是一个重要的软件设计原则，在React开发中也同样适用。它指的是将代码按照不同的功能或责任进行划分和组织，使每个部分专注于特定的任务。在React中，这通常体现为:\n将UI和逻辑分离 将状态管理与渲染逻辑分离 将可复用的逻辑抽离成自定义Hook 将大型组件拆分成更小的、功能单一的组件 遵循这一原则可以提高代码的可维护性、可读性和可重用性。\nEasy to read abstraction over array state 个人理解：对数组状态进行抽象，简化逻辑\nHow to import Server Components from Client Components 个人理解：服务端渲染框架中使用的小技巧\nAvoid Transforming Data in useEffect 个人理解：在useEffect中避免对数据进行转换，避免不必要的重新渲染\n原因：\n性能问题：在 useEffect 中转换数据可能导致不必要的重渲染。 代码复杂性：可能使组件逻辑变得难以理解和维护。 更好的做法：\n在渲染过程中直接转换数据。 使用 useMemo 缓存计算结果。 How and when to use flushSync Defer creation of non-primitive values if you are using them within a dependency array 个人理解: useEffect使用Tips\nAvoid premature optimization How to expose custom refs with useImperativeHandle hook Separate business logic from UI How to virtualize large lists Avoid difficult to read conditionals in React Using inferred types in React Avoid Provider Wrapping Hell useEffect cheatsheet 开发中的学习 useState vs useReducer 个人理解useReducer是useState的进阶版本，useState适用于一些简单状态的管理。如果是多个简单状态之前存在复杂的逻辑关联，推荐使用useReducer去处理。\n@uidotdev/usehooks 中 useThrottle 和 useDebunce的区别是什么？ 作用目的\nuseThrottle（节流）： 目的是限制函数在一定时间内的执行次数。它确保函数在指定的时间间隔内最多被执行一次。\n例如，在滚动事件处理中，当用户快速滚动页面时，使用节流可以避免频繁地执行某个昂贵的操作，如发送网络请求或进行大量的计算，从而提高性能。\nuseDebounce（防抖）： 主要用于在用户输入或触发某个事件后，等待一段时间，如果在这段时间内没有新的触发，则执行相应的函数。\n常见的应用场景是在搜索框输入时，当用户停止输入一段时间后才进行搜索请求，避免在用户输入过程中频繁发送请求。\n执行时机\nuseThrottle： 当触发事件开始时，函数会立即执行一次，然后在指定的时间间隔内，无论触发事件发生多少次，函数都不会再次执行。直到时间间隔结束后，下一次触发事件才能再次执行函数。\n例如，假设设置节流时间为 1 秒，当用户连续触发事件时，函数在第一秒内执行一次，之后的触发会被忽略，直到下一个 1 秒间隔开始。\nuseDebounce： 当触发事件发生后，函数不会立即执行，而是启动一个定时器。如果在定时器到期之前又有新的触发事件，那么定时器会被重置。只有在定时器到期且没有新的触发事件时，函数才会执行。\n比如，设置防抖时间为 500 毫秒，当用户输入内容后，500 毫秒内如果没有新的输入，函数就会执行；如果在这 500 毫秒内又有新的输入，定时器会重新开始计时。\n适用场景\nuseThrottle： 适用于需要持续响应但又不能过于频繁执行的场景，比如滚动事件、窗口大小调整事件等，以减少资源消耗和提高性能。\n例如，在地图应用中，当用户拖动地图时，可以使用节流来限制地图更新的频率，避免过度的计算和网络请求。\nuseDebounce： 非常适合处理用户输入、搜索框自动完成等场景，确保在用户停止操作一段时间后才执行相关操作，避免不必要的计算和网络请求。\n例如，在在线文档的自动保存功能中，可以使用防抖来避免频繁保存，而是在用户停止编辑一段时间后进行保存操作。\n使用 ElementRef 类型定义ref的类型 记住HTMLDivElement是比较困难的\nconst ref = useRef\u0026lt;HTMLDivElement\u0026gt;(null); 可以尝试\nconst ref = useRef\u0026lt;ElementRef\u0026lt;\u0026#34;div\u0026#34;\u0026gt;\u0026gt;(null); 从别人中的笔记学习 React常用的设计模式 组合模式 首先看一段代码，Tabs和TabItem是父子关系。\nTabs 负责展示和控制对应的 TabItem 。绑定切换 tab 回调方法 onChange。当 tab 切换的时候，执行回调。 TabItem 负责展示对应的 tab 项，向 Tabs 传递 props 相关信息。 \u0026lt;Tabs onChange={ (type)=\u0026gt; console.log(type) } \u0026gt; \u0026lt;TabItem name=\u0026#34;react\u0026#34; label=\u0026#34;react\u0026#34; \u0026gt;React\u0026lt;/TabItem\u0026gt; \u0026lt;TabItem name=\u0026#34;vue\u0026#34; label=\u0026#34;vue\u0026#34; \u0026gt;Vue\u0026lt;/TabItem\u0026gt; \u0026lt;TabItem name=\u0026#34;angular\u0026#34; label=\u0026#34;angular\u0026#34; \u0026gt;Angular\u0026lt;/TabItem\u0026gt; \u0026lt;/Tabs\u0026gt; 隐式混入 props\nfunction Item (props){ console.log(props) return \u0026lt;div\u0026gt; 名称： {props.name} \u0026lt;/div\u0026gt; } function Groups (props){ const newChilren = React.cloneElement(props.children, { author:\u0026#39;alien\u0026#39; }) return newChilren } 通过React.cloneElement，向子组件中混入父组件的props。\n控制渲染\nfunction Item (props){ return \u0026lt;div\u0026gt; 名称： {props.name} \u0026lt;/div\u0026gt; } /* Groups 组件 */ function Groups (props){ const newChildren = [] React.Children.forEach(props.children,(item)=\u0026gt;{ const { type ,props } = item || {} if(isValidElement(item) \u0026amp;\u0026amp; type === Item \u0026amp;\u0026amp; props.isShow ){ newChildren.push(item) } }) return newChildren } 通过遍历children，根据父组件的逻辑来控制子组件的渲染。\n内外层通信\nfunction Item (props){ return \u0026lt;div\u0026gt; 名称：{props.name} \u0026lt;button onClick={()=\u0026gt; props.callback(\u0026#39;let us learn React!\u0026#39;)} \u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } function Groups (props){ const handleCallback = (val) =\u0026gt; console.log(\u0026#39; children 内容：\u0026#39;,val ) return \u0026lt;div\u0026gt; {React.cloneElement( props.children , { callback:handleCallback } )} \u0026lt;/div\u0026gt; } 向内层组件传递回调函数 callback ，内层通过调用 callback 来实现两层组合模式的通信关系。\nrender props模式 render props 模式和组合模式类似。区别不同的是，用函数的形式代替 children。函数的参数，由容器组件提供，这样的好处，将容器组件的状态，提升到当前外层组件中，这个是一个巧妙之处，也是和组合模式相比最大的区别。\nexport default function App (){ const aProps = { name:\u0026#39;《React进阶实践指南》\u0026#39; } return \u0026lt;Container\u0026gt; {(cProps) =\u0026gt; \u0026lt;Children {...cProps} { ...aProps } /\u0026gt;} \u0026lt;/Container\u0026gt; } 参考资料:\n「React 进阶」 学好这些 React 设计模式，能让你的 React 项目飞起来 ","permalink":"https://carlos19960601.github.io/posts/react%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"twitterx-博主_georgemollerhttpsxcom_georgemoller的分享\"\u003eTwitter/X 博主\u003ca href=\"https://x.com/_georgemoller\"\u003e@_georgemoller\u003c/a\u003e的分享\u003c/h2\u003e\n\u003cp\u003e主要记录Twitter博主\u003ca href=\"https://x.com/_georgemoller\"\u003e@_georgemoller\u003c/a\u003e分享的React技巧。对于我这种React小白很使用。于是搬运过来，并附上个人的一些理解。如有问题请邮箱本人，欢迎各位指正。\u003c/p\u003e\n\u003ch3 id=\"solve-re-render-issues-with-composition\"\u003eSolve re-render issues with composition\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_1c2c3b.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e个人理解：功能单一，利用组合模式减少耦合，带来不必要的重新渲染\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"utility-types-for-enhanced-reusablity\"\u003eUtility Types For Enhanced Reusablity\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_9378eb.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e个人理解：Typescript Pick的使用\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"bad-use-case-for-usecallback\"\u003eBad use case for useCallback\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_ed1930.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003euseCallback 使用在复杂逻辑的组件，简单组件不会消耗造成性能问题时不必使用\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"intersection-types-to-extends-native-props-in-a-component\"\u003eIntersection types to extends native props in a component\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_29194f.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"dont-listen-for-ref-changes-with-useeffect\"\u003eDon\u0026rsquo;t listen for ref changes with useEffect\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_8216ce.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本人曾经这么干过\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"useeffect-vs-uselayouteffect\"\u003euseEffect vs useLayoutEffect\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_d587ed.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e个人理解：useLayoutEffect在DOM更新后，浏览器绘制前执行。useEffect在DOM更新后，浏览器绘制后执行。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"separation-of-concerns-in-react\"\u003eSeparation of Concerns in React\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/React%e7%ac%94%e8%ae%b0/georgemoller_e8833e.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eReact中的关注点分离\n这是一个重要的软件设计原则，在React开发中也同样适用。它指的是将代码按照不同的功能或责任进行划分和组织，使每个部分专注于特定的任务。在React中，这通常体现为:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将UI和逻辑分离\u003c/li\u003e\n\u003cli\u003e将状态管理与渲染逻辑分离\u003c/li\u003e\n\u003cli\u003e将可复用的逻辑抽离成自定义Hook\u003c/li\u003e\n\u003cli\u003e将大型组件拆分成更小的、功能单一的组件\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e遵循这一原则可以提高代码的可维护性、可读性和可重用性。\u003c/p\u003e","title":"React笔记"},{"content":"桌面客户端 tauri tauri 后端使用rust。\nclash-verge-rev: 基于Mihomo内核的翻墙客户端GUI rust system-proxy的实现 Electron Electron 后端使用node。\neveryone-can-use-english: 英语学习软件 项目结构清晰，可以参考学习 mihomo-party: Mihomo GUI 个人观点：tauri是webview+rust的实现，性能和打包的体积比较小，但是rust门槛高，tauri的生态可能比不上node。Electron是Chrome内核和NodeJS，入门门槛低，而且node的生态比较好。再不在乎包体积和性能的情况下，还是推荐Electron。\n移动客户端 Flutter pilipala: 第三方bilibili客户端 使用Get做状态管理 使用Hive做本地存储 封装了dio网络请求 基于media-kit实现视频播放 Cashew: An app created to help users manage a budget and purchases flutter_cloud_music: 还原网易云，flutter SDK版本较低，依赖包有些缺乏维护 Taskez: A Productivity Mobile Application UI kit built with Flutter E-commerce-Complete-Flutter-UI: 学习skleton Flclash: 基于ClashMeta的客户端。 cgo ffi Web前端 React eidos: 类似notion的软件 使用zustand做状态管理 能够了解到PWA、serivce-woker、web-worker等 jsoncrack.com: json可视化展示 c-shopping: 基于Next.js的全栈购物网站 使用 mongoose 操作数据库 学习 nextjs 的 Route Handlers 的使用 noodle: Rethinking Student Productivity 学习在nextjs中使用trpc novel: 基于Tiptap实现的编辑器 tiptap插件编写 后端 Golang mihomo: 翻墙软件，ClashMeta 能够学习到各种翻墙协议的内容 asynq: 基于Redis实现的分布式任务 redis lua脚本的使用 golang 多个sever的启动与停止的实现 galene: The Galène videoconference server 了解WebRTC相关的指示 badger: KV存储引擎 能够学习到LSM树的实现 Rust xh: 类似于curl的命令行请求工具 数据分析与机器学习 handson-ml3: Hands-on Machine Learning with Scikit-Learn, Keras and TensorFlow (3rd edition) 100-Days-Of-ML-Code ","permalink":"https://carlos19960601.github.io/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90/","summary":"\u003ch1 id=\"桌面客户端\"\u003e桌面客户端\u003c/h1\u003e\n\u003ch2 id=\"taurihttpstauriapp\"\u003e\u003ca href=\"https://tauri.app/\"\u003etauri\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003etauri 后端使用\u003ccode\u003erust\u003c/code\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/clash-verge-rev/clash-verge-rev\"\u003eclash-verge-rev\u003c/a\u003e: 基于Mihomo内核的翻墙客户端GUI\n\u003cul\u003e\n\u003cli\u003erust system-proxy的实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"electronhttpswwwelectronforgeio\"\u003e\u003ca href=\"https://www.electronforge.io/\"\u003eElectron\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eElectron 后端使用\u003ccode\u003enode\u003c/code\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ZuodaoTech/everyone-can-use-english\"\u003eeveryone-can-use-english\u003c/a\u003e: 英语学习软件\n\u003cul\u003e\n\u003cli\u003e项目结构清晰，可以参考学习\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/pompurin404/mihomo-party\"\u003emihomo-party\u003c/a\u003e: Mihomo GUI\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e个人观点：tauri是webview+rust的实现，性能和打包的体积比较小，但是rust门槛高，tauri的生态可能比不上node。Electron是Chrome内核和NodeJS，入门门槛低，而且node的生态比较好。再不在乎包体积和性能的情况下，还是推荐Electron。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"移动客户端\"\u003e移动客户端\u003c/h1\u003e\n\u003ch2 id=\"flutter\"\u003eFlutter\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/guozhigq/pilipala\"\u003epilipala\u003c/a\u003e: 第三方bilibili客户端\n\u003cul\u003e\n\u003cli\u003e使用Get做状态管理\u003c/li\u003e\n\u003cli\u003e使用Hive做本地存储\u003c/li\u003e\n\u003cli\u003e封装了dio网络请求\u003c/li\u003e\n\u003cli\u003e基于media-kit实现视频播放\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jameskokoska/Cashew\"\u003eCashew\u003c/a\u003e: An app created to help users manage a budget and purchases\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/AIYO77/flutter_cloud_music\"\u003eflutter_cloud_music\u003c/a\u003e: 还原网易云，flutter SDK版本较低，依赖包有些缺乏维护\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Davies-K/Taskez\"\u003eTaskez\u003c/a\u003e: A Productivity Mobile Application UI kit built with Flutter\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/abuanwar072/E-commerce-Complete-Flutter-UI\"\u003eE-commerce-Complete-Flutter-UI\u003c/a\u003e: 学习skleton\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/chen08209/FlClash\"\u003eFlclash\u003c/a\u003e: 基于ClashMeta的客户端。\n\u003cul\u003e\n\u003cli\u003ecgo\u003c/li\u003e\n\u003cli\u003effi\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"web前端\"\u003eWeb前端\u003c/h1\u003e\n\u003ch2 id=\"react\"\u003eReact\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/mayneyao/eidos\"\u003eeidos\u003c/a\u003e: 类似notion的软件\n\u003cul\u003e\n\u003cli\u003e使用zustand做状态管理\u003c/li\u003e\n\u003cli\u003e能够了解到PWA、serivce-woker、web-worker等\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/AykutSarac/jsoncrack.com\"\u003ejsoncrack.com\u003c/a\u003e: json可视化展示\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/huanghanzhilian/c-shopping\"\u003ec-shopping\u003c/a\u003e: 基于\u003ccode\u003eNext.js\u003c/code\u003e的全栈购物网站\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003emongoose\u003c/code\u003e 操作数据库\u003c/li\u003e\n\u003cli\u003e学习 nextjs 的 Route Handlers 的使用\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/noodle-run/noodle\"\u003enoodle\u003c/a\u003e: Rethinking Student Productivity\n\u003cul\u003e\n\u003cli\u003e学习在nextjs中使用trpc\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/steven-tey/novel\"\u003enovel\u003c/a\u003e: 基于Tiptap实现的编辑器\n\u003cul\u003e\n\u003cli\u003etiptap插件编写\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"后端\"\u003e后端\u003c/h1\u003e\n\u003ch2 id=\"golang\"\u003eGolang\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/MetaCubeX/mihomo\"\u003emihomo\u003c/a\u003e: 翻墙软件，ClashMeta\n\u003cul\u003e\n\u003cli\u003e能够学习到各种翻墙协议的内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/hibiken/asynq\"\u003easynq\u003c/a\u003e: 基于Redis实现的分布式任务\n\u003cul\u003e\n\u003cli\u003eredis lua脚本的使用\u003c/li\u003e\n\u003cli\u003egolang 多个sever的启动与停止的实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jech/galene\"\u003egalene\u003c/a\u003e: The Galène videoconference server\n\u003cul\u003e\n\u003cli\u003e了解WebRTC相关的指示\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/dgraph-io/badger\"\u003ebadger\u003c/a\u003e: KV存储引擎\n\u003cul\u003e\n\u003cli\u003e能够学习到LSM树的实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"rust\"\u003eRust\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ducaale/xh\"\u003exh\u003c/a\u003e: 类似于\u003ccode\u003ecurl\u003c/code\u003e的命令行请求工具\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"数据分析与机器学习\"\u003e数据分析与机器学习\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ageron/handson-ml3\"\u003ehandson-ml3\u003c/a\u003e: Hands-on Machine Learning with Scikit-Learn, Keras and TensorFlow (3rd edition)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/MLEveryday/100-Days-Of-ML-Code\"\u003e100-Days-Of-ML-Code\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"开源项目学习推荐"},{"content":"生命周期 rust自动推断变量的生命周期\nfn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { if x.len() \u0026gt; y.len() { x } else { y } } 但是上面这段代码，rust无法推断出变量的生命周期。所以需要显示的标注生命周期。\n生命周期标注并不会改变任何引用的实际作用域\n参考资料 通过例子学 Rust Rust 程序设计语言 Rust语言圣经( ","permalink":"https://carlos19960601.github.io/posts/%E5%AD%A6%E4%B9%A0rust/","summary":"\u003ch1 id=\"生命周期\"\u003e生命周期\u003c/h1\u003e\n\u003cp\u003erust自动推断变量的生命周期\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elongest\u003c/span\u003e(x: \u003cspan style=\"color:#66d9ef\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estr\u003c/span\u003e, y: \u003cspan style=\"color:#66d9ef\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estr\u003c/span\u003e) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estr\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e x.len() \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e y.len() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        x\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        y\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是上面这段代码，rust无法推断出变量的生命周期。所以需要显示的标注生命周期。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e生命周期标注并不会改变任何引用的实际作用域\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://rustwiki.org/zh-CN/rust-by-example/index.html\"\u003e通过例子学 Rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kaisery.github.io/trpl-zh-cn/title-page.html\"\u003eRust 程序设计语言\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://course.rs/about-book.html\"\u003eRust语言圣经(\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"学习rust"},{"content":"pipx是什么？ 可以参加pipx的介绍。\n作为一个python小白，看了几遍，搜索了多篇博客了解pipx是什么，仍然不懂是个啥。\n我在这仅说明一下我自己的理解。pipx相当于一个安装工具。python有自己的安装包的工具pip。那么pip和pipx有什么区别呢？\n如果直接pip安装包会安装在python目录下的site-packages下。由于这是个全局目录。如果在不同的项目里面，可能使用的各个包版本不同，可能会产生冲突。所以我们偏向使用一个干净的site-package。其实python提供了解决方案\u0026ndash;虚拟环境。pipx只是基于这个概念，让使用者更好的使用。\n注意 pipx 安装的是一些可执行的python应用。比如 poetry, jupyter等\n简单使用 安装pipx\nbrew install pipx pipx ensurepath 安装jupyter\n可以使用--python参数指定虚拟环境python版本。如果不指定，使用的是你电脑上安装的最新的python`版本。\npipx install notebook --python=python3.11 --force 执行后, jupyter就会被安装在 ~/.local/pipx/venvs/notebook/bin。可以看到在pipx的venvs目录下面。也就说pipx安装的每个应用都会有自己的虚拟环境。\n在写jupyter notebook的时候，我们可能需要numpy，panda等这些python库。所以我们需要将这些安装到notebook的虚拟环境中，才能使用\npipx inject notebook pandas numpy 问题记录 如果pipx inject的时候需要使用proxy。由于底层还是使用pip，所以需要通过PIP_*的环境变量传递proxy信息 export PIP_PROXY=http://127.0.0.1:7890 https_proxy=http://127.0.0.1:7890 ","permalink":"https://carlos19960601.github.io/posts/pipx%E4%BD%BF%E7%94%A8/","summary":"\u003ch1 id=\"pipx是什么\"\u003epipx是什么？\u003c/h1\u003e\n\u003cp\u003e可以参加\u003ca href=\"https://github.com/pypa/pipx\"\u003epipx\u003c/a\u003e的介绍。\u003c/p\u003e\n\u003cp\u003e作为一个python小白，看了几遍，搜索了多篇博客了解\u003ccode\u003epipx\u003c/code\u003e是什么，仍然不懂是个啥。\u003c/p\u003e\n\u003cp\u003e我在这仅说明一下我自己的理解。\u003ccode\u003epipx\u003c/code\u003e相当于一个安装工具。\u003ccode\u003epython\u003c/code\u003e有自己的安装包的工具\u003ccode\u003epip\u003c/code\u003e。那么\u003ccode\u003epip\u003c/code\u003e和\u003ccode\u003epipx\u003c/code\u003e有什么区别呢？\u003c/p\u003e\n\u003cp\u003e如果直接\u003ccode\u003epip\u003c/code\u003e安装包会安装在\u003ccode\u003epython\u003c/code\u003e目录下的\u003ccode\u003esite-packages\u003c/code\u003e下。由于这是个全局目录。如果在不同的项目里面，可能使用的各个包版本不同，可能会产生冲突。所以我们偏向使用一个干净的\u003ccode\u003esite-package\u003c/code\u003e。其实\u003ccode\u003epython\u003c/code\u003e提供了解决方案\u0026ndash;虚拟环境。\u003ccode\u003epipx\u003c/code\u003e只是基于这个概念，让使用者更好的使用。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意 pipx 安装的是一些可执行的python应用。比如 poetry, jupyter等\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"简单使用\"\u003e简单使用\u003c/h1\u003e\n\u003cp\u003e安装pipx\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-shells\" data-lang=\"shells\"\u003ebrew install pipx\npipx ensurepath\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e安装jupyter\u003c/p\u003e\n\u003cp\u003e可以使用\u003ccode\u003e--python\u003c/code\u003e参数指定虚拟环境python\u003ccode\u003e版本。如果不指定，使用的是你电脑上安装的最新的\u003c/code\u003epython`版本。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epipx install notebook --python\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003epython3.11 --force\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e执行后, jupyter就会被安装在 \u003ccode\u003e~/.local/pipx/venvs/notebook/bin\u003c/code\u003e。可以看到在\u003ccode\u003epipx\u003c/code\u003e的\u003ccode\u003evenvs\u003c/code\u003e目录下面。也就说\u003ccode\u003epipx\u003c/code\u003e安装的每个应用都会有自己的虚拟环境。\u003c/p\u003e\n\u003cp\u003e在写jupyter notebook的时候，我们可能需要\u003ccode\u003enumpy\u003c/code\u003e，\u003ccode\u003epanda\u003c/code\u003e等这些\u003ccode\u003epython\u003c/code\u003e库。所以我们需要将这些安装到notebook的虚拟环境中，才能使用\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-shells\" data-lang=\"shells\"\u003epipx inject notebook pandas numpy\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"问题记录\"\u003e问题记录\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e如果pipx inject的时候需要使用proxy。由于底层还是使用pip，所以需要通过PIP_*的环境变量传递proxy信息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexport PIP_PROXY\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ehttp://127.0.0.1:7890 https_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ehttp://127.0.0.1:7890\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"pipx使用"},{"content":"元字符 正则表达式主要依赖于元字符。\n元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：\n元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配\u0026gt;=0个重复的在*号之前的字符。 + 匹配\u0026gt;=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n \u0026lt;= num \u0026lt;= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. | 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ | ^ 从开始行开始匹配. $ 从末端开始匹配. 简写字符集 正则表达式提供一些常用的字符集简写。如下:\n简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 零宽度断言（前后预查） 先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。\n例如，我们希望从下面的输入字符串 $4.44 和 $10.88 中获得所有以 $ 字符开头的数字，我们将使用以下的正则表达式 (?\u0026lt;=\\$)[0-9\\.]*。意思是：获取所有包含 . 并且前面是 $ 的数字。\n零宽度断言如下：\n符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?\u0026lt;= 正后发断言-存在 ?\u0026lt;! 负后发断言-排除 标志 标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。\n标志 描述 i 忽略大小写。 g 全局搜索。 m 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 贪婪匹配与惰性匹配 (Greedy vs lazy matching) 正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。%\n","permalink":"https://carlos19960601.github.io/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"\u003ch1 id=\"元字符\"\u003e元字符\u003c/h1\u003e\n\u003cp\u003e正则表达式主要依赖于元字符。\u003c/p\u003e\n\u003cp\u003e元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e元字符\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e.\u003c/td\u003e\n          \u003ctd\u003e句号匹配任意单个字符除了换行符。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[ ]\u003c/td\u003e\n          \u003ctd\u003e字符种类。匹配方括号内的任意字符。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[^ ]\u003c/td\u003e\n          \u003ctd\u003e否定的字符种类。匹配除了方括号里的任意字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e*\u003c/td\u003e\n          \u003ctd\u003e匹配\u0026gt;=0个重复的在*号之前的字符。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e+\u003c/td\u003e\n          \u003ctd\u003e匹配\u0026gt;=1个重复的+号前的字符。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e?\u003c/td\u003e\n          \u003ctd\u003e标记?之前的字符为可选.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e{n,m}\u003c/td\u003e\n          \u003ctd\u003e匹配num个大括号之前的字符或字符集 (n \u0026lt;= num \u0026lt;= m).\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(xyz)\u003c/td\u003e\n          \u003ctd\u003e字符集，匹配与 xyz 完全相等的字符串.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e|\u003c/td\u003e\n          \u003ctd\u003e或运算符，匹配符号前或后的字符.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\\u003c/td\u003e\n          \u003ctd\u003e转义字符,用于匹配一些保留的字符 \u003c!-- raw HTML omitted --\u003e[ ] ( ) { } . * + ? ^ $ \\ |\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e^\u003c/td\u003e\n          \u003ctd\u003e从开始行开始匹配.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e$\u003c/td\u003e\n          \u003ctd\u003e从末端开始匹配.\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"简写字符集\"\u003e简写字符集\u003c/h1\u003e\n\u003cp\u003e正则表达式提供一些常用的字符集简写。如下:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e简写\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e.\u003c/td\u003e\n          \u003ctd\u003e除换行符外的所有字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\w\u003c/td\u003e\n          \u003ctd\u003e匹配所有字母数字，等同于 \u003ccode\u003e[a-zA-Z0-9_]\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\W\u003c/td\u003e\n          \u003ctd\u003e匹配所有非字母数字，即符号，等同于： \u003ccode\u003e[^\\w]\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\d\u003c/td\u003e\n          \u003ctd\u003e匹配数字： \u003ccode\u003e[0-9]\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\D\u003c/td\u003e\n          \u003ctd\u003e匹配非数字： \u003ccode\u003e[^\\d]\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\s\u003c/td\u003e\n          \u003ctd\u003e匹配所有空格字符，等同于： \u003ccode\u003e[\\t\\n\\f\\r\\p{Z}]\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\S\u003c/td\u003e\n          \u003ctd\u003e匹配所有非空格字符： \u003ccode\u003e[^\\s]\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\f\u003c/td\u003e\n          \u003ctd\u003e匹配一个换页符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\n\u003c/td\u003e\n          \u003ctd\u003e匹配一个换行符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\r\u003c/td\u003e\n          \u003ctd\u003e匹配一个回车符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\t\u003c/td\u003e\n          \u003ctd\u003e匹配一个制表符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\v\u003c/td\u003e\n          \u003ctd\u003e匹配一个垂直制表符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\p\u003c/td\u003e\n          \u003ctd\u003e匹配 CR/LF（等同于 \u003ccode\u003e\\r\\n\u003c/code\u003e），用来匹配 DOS 行终止符\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"零宽度断言前后预查\"\u003e零宽度断言（前后预查）\u003c/h1\u003e\n\u003cp\u003e先行断言和后发断言（合称 lookaround）都属于\u003cstrong\u003e非捕获组\u003c/strong\u003e（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。\u003c/p\u003e","title":"正则表达式"},{"content":"安装Docker 参考Install using the apt repository\n# Add Docker\u0026#39;s official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update 其中在这步中，即使设置了Proxy\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 好像并没有生效，我当时是直接下载gpg文件，然后手动copy到/etc/apt/keyrings/docker.asc\n当然也可以使用\nsudo curl -x http://127.0.0.1:7890 -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc 后续安装就很顺利了。\n关于Docker使用Proxy 参考Configure Docker to use a proxy server\n这里说明了2中Proxy。一种是Docker自身使用Proxy。一种是Docker Container容器使用Proxy。\n一般我们pull image需要使用Proxy应该配置Docker deamon /etc/docker/daemon.json\n{ \u0026#34;proxies\u0026#34;: { \u0026#34;http-proxy\u0026#34;: \u0026#34;http://127.0.0.1:7890\u0026#34;, \u0026#34;https-proxy\u0026#34;: \u0026#34;http://127.0.0.1:7890\u0026#34;, \u0026#34;no-proxy\u0026#34;: \u0026#34;127.0.0.0/8\u0026#34; } } 最后别忘了\nsudo systemctl restart docker 我犯错就是配置成~/.docker/config.json，导致容器中使用http-proxy请求127.0.0.1请求不同，容器之间通信失败。\n{ \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;http-proxy\u0026#34;: \u0026#34;http://127.0.0.1:7890\u0026#34;, \u0026#34;https-proxy\u0026#34;: \u0026#34;http://127.0.0.1:7890\u0026#34;, \u0026#34;no-proxy\u0026#34;: \u0026#34;127.0.0.0/8\u0026#34; } } } ","permalink":"https://carlos19960601.github.io/posts/docker%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","summary":"\u003ch1 id=\"安装docker\"\u003e安装Docker\u003c/h1\u003e\n\u003cp\u003e参考\u003ca href=\"https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository\"\u003eInstall using the apt repository\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Docker\u0026#39;s official GPG key:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt-get install ca-certificates curl\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo install -m \u003cspan style=\"color:#ae81ff\"\u003e0755\u003c/span\u003e -d /etc/apt/keyrings\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo chmod a+r /etc/apt/keyrings/docker.asc\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add the repository to Apt sources:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eecho \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;deb [arch=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003edpkg --print-architecture\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e  \u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003e. /etc/os-release \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e echo \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e$VERSION_CODENAME\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e stable\u0026#34;\u003c/span\u003e | \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中在这步中，即使设置了Proxy\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexport https_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ehttp://127.0.0.1:7890 http_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ehttp://127.0.0.1:7890 all_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003esocks5://127.0.0.1:7890\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e好像并没有生效，我当时是直接下载\u003ccode\u003egpg\u003c/code\u003e文件，然后手动copy到\u003ccode\u003e/etc/apt/keyrings/docker.asc\u003c/code\u003e\u003c/p\u003e","title":"Docker使用问题记录"},{"content":"最近在看 3Blue1Brown的Essence of linear algebra。预习一下大学知识。\n线性变换 线性变换矩阵可以看作是变换之后坐标系的 i, j 单位向量\n矩阵乘法 矩阵乘法可以是看作是从右到左进行多次变化。\n同样的3维就是对3维空间进行变换。\n行列式 行列式表示将面积缩放的大小\n点积 在大学课堂上，老师说点积是向量长度和另外一个向量上在该向量方向上投影的积。但是一直不明白为什么。\n其实可以把其中一个向量看成一种变换。从二维到一维的转换。\n参考资料 Essence of linear algebra ","permalink":"https://carlos19960601.github.io/posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","summary":"\u003cp\u003e最近在看 \u003ca href=\"https://www.youtube.com/@3blue1brown\"\u003e3Blue1Brown\u003c/a\u003e的\u003ca href=\"https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab\"\u003eEssence of linear algebra\u003c/a\u003e。预习一下大学知识。\u003c/p\u003e\n\u003ch1 id=\"线性变换\"\u003e线性变换\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e7%ba%bf%e6%80%a7%e4%bb%a3%e6%95%b0/Transform.png\" alt=\"Transform\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e线性变换矩阵可以看作是变换之后坐标系的 \u003cstrong\u003ei\u003c/strong\u003e, \u003cstrong\u003ej\u003c/strong\u003e 单位向量\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e7%ba%bf%e6%80%a7%e4%bb%a3%e6%95%b0/transform.gif\" alt=\"Transform\"  /\u003e\n\u003c/p\u003e\n\u003ch1 id=\"矩阵乘法\"\u003e矩阵乘法\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e7%ba%bf%e6%80%a7%e4%bb%a3%e6%95%b0/Matrix%20multiplication.png\" alt=\"Matrix multiplication\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e矩阵乘法可以是看作是从右到左进行多次变化。\u003c/p\u003e\n\u003cp\u003e同样的3维就是对3维空间进行变换。\u003c/p\u003e\n\u003ch1 id=\"行列式\"\u003e行列式\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e7%ba%bf%e6%80%a7%e4%bb%a3%e6%95%b0/%e8%a1%8c%e5%88%97%e5%bc%8f.png\" alt=\"行列式\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e行列式表示将面积缩放的大小\u003c/p\u003e\n\u003ch1 id=\"点积\"\u003e点积\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e7%ba%bf%e6%80%a7%e4%bb%a3%e6%95%b0/dot.gif\" alt=\"dot\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e在大学课堂上，老师说点积是向量长度和另外一个向量上在该向量方向上投影的积。但是一直不明白为什么。\u003c/p\u003e\n\u003cp\u003e其实可以把其中一个向量看成一种变换。从二维到一维的转换。\u003c/p\u003e\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab\"\u003eEssence of linear algebra\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"线性代数"},{"content":"Socks5协议 具体协议过程参考理解socks5协议的工作过程和协议细节。这篇文章主要是通过代码去理解socks5协议。\n实验条件介绍 命令行设置proxy\nexport https_proxy=socks5://127.0.0.1:7891 http_proxy=socks5://127.0.0.1:7891 之后通过curl发起http请求。\ncurl www.baidu.com 这时候，curl这个命令就会走socks协议，并封装socks协议数据发送给socks5://127.0.0.1:7891。\n协商阶段 根据参考资料，握手阶段-协商阶段发送的数据格式如下：\n+----+----------+----------+ |VER | NMETHODS | METHODS | +----+----------+----------+ | 1 | 1 | 1 to 255 | +----+----------+----------+ #上方的数字表示字节数，下面的表格同理，不再赘述 VER: 协议版本，socks5为0x05\nNMETHODS: 支持认证的方法数量\nMETHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:\nX’00’ NO AUTHENTICATION REQUIRED X’01’ GSSAPI X’02’ USERNAME/PASSWORD X’03’ to X’7F’ IANA ASSIGNED X’80’ to X’FE’ RESERVED FOR PRIVATE METHODS X’FF’ NO ACCEPTABLE METHODS 那么socks服务端接受到请求时，需要解析内容，选中一个METHOD返回给客户端，格式如下:\n+----+--------+ |VER | METHOD | +----+--------+ | 1 | 1 | +----+--------+ func ServerHandshake(rw net.Conn, authenticator auth.Authenticator) (addr Addr, command Command, user string, err error) { ... if _, err = io.ReadFull(rw, buf[:2]); err != nil { return } nmethods := buf[1] if _, err = io.ReadFull(rw, buf[:nmethods]); err != nil { return } // 返回信息,需要认证 if authenticator != nil { // 版本和认证方法 if _, err = rw.Write([]byte{5, 2}); err != nil { return } } ... } 上面代码逻辑就是处理这个过程。代码中固定返回的是X’02’ USERNAME/PASSWORD这种认证方式。\n认证阶段 认证阶段是一个可选的阶段，如果不需要认证，可以直接跳过。\n如果需要认证，客户端向socks5服务器发起一个认证请求，这里以0x02的认证方式举例:\n|VER | ULEN | UNAME | PLEN | PASSWD | +----+------+----------+------+----------+ | 1 | 1 | 1 to 255 | 1 | 1 to 255 | +----+------+----------+------+----------+ VER: 版本，**通常为`0x01`** ULEN: 用户名长度 UNAME: 对应用户名的字节数据 PLEN: 密码长度 PASSWD: 密码对应的数据 socks5服务器收到客户端的认证请求后，解析内容，验证信息是否合法，然后给客户端响应结果。响应格式如下:\n+----+--------+ |VER | STATUS | +----+--------+ | 1 | 1 | +----+--------+ 注意这里的VER并不少socks的版本\nfunc ServerHandshake(rw net.Conn, authenticator auth.Authenticator) (addr Addr, command Command, user string, err error) { ... // 返回信息,需要认证 if authenticator != nil { // 版本和认证方法 if _, err = rw.Write([]byte{5, 2}); err != nil { return } // 认证阶段 header := make([]byte, 2) if _, err = io.ReadFull(rw, header); err != nil { return } authBuf := make([]byte, MaxAuthLen) // 读取username userLen := int(header[1]) if userLen \u0026lt;= 0 { // 返回认证失败 rw.Write([]byte{1, 1}) err = ErrAuth return } if _, err = io.ReadFull(rw, authBuf[:userLen]); err != nil { return } user = string(authBuf[:userLen]) // 读取pass if _, err = rw.Read(header[:1]); err != nil { return } passLen := int(header[0]) if passLen \u0026lt;= 0 { // 返回认证失败 rw.Write([]byte{1, 1}) err = ErrAuth return } if _, err = io.ReadFull(rw, authBuf[:userLen]); err != nil { return } pass := string(authBuf[:userLen]) if ok := authenticator.Verify(user, pass); !ok { // 返回认证失败 rw.Write([]byte{1, 1}) err = ErrAuth return } // 返回认成功 if _, err = rw.Write([]byte{1, 0}); err != nil { return } } else { // 告诉客户端不需要验证 if _, err = rw.Write([]byte{5, 0}); err != nil { return } } return } ... 请求阶段 顺利通过协商阶段后，客户端向socks5服务器发起请求细节，格式如下:\n+----+-----+-------+------+----------+----------+ |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | +----+-----+-------+------+----------+----------+ | 1 | 1 | X\u0026#39;00\u0026#39; | 1 | Variable | 2 | +----+-----+-------+------+----------+----------+ VER 版本号，socks5的值为0x05 CMD 0x01表示CONNECT请求 0x02表示BIND请求 0x03表示UDP转发 RSV 保留字段，值为0x00 ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。 0x01表示IPv4地址，DST.ADDR为4个字节 0x03表示域名，DST.ADDR是一个可变长度的域名 0x04表示IPv6地址，DST.ADDR为16个字节长度 DST.ADDR 一个可变长度的值 DST.PORT 目标端口，固定2个字节 上面的值中，DST.ADDR是一个变长的数据，它的数据长度根据ATYP的类型决定。分为下面3种情况:\nX’01’ 一个4字节的ipv4地址 X’03’ 一个可变长度的域名，这种情况下DST.ADDR的第一个字节表示域名长度，剩下部分是域名内容。 X’04’ 一个16字节的ipv6地址 socks5服务器收到客户端的请求后，需要返回一个响应，结构如下\n+----+-----+-------+------+----------+----------+ |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | +----+-----+-------+------+----------+----------+ | 1 | 1 | X\u0026#39;00\u0026#39; | 1 | Variable | 2 | +----+-----+-------+------+----------+----------+ VER socks版本，这里为0x05 REP Relay field,内容取值如下 X’00’ succeeded X’01’ general SOCKS server failure X’02’ connection not allowed by ruleset X’03’ Network unreachable X’04’ Host unreachable X’05’ Connection refused X’06’ TTL expired X’07’ Command not supported X’08’ Address type not supported X’09’ to X’FF’ unassigned RSV 保留字段 ATYPE 同请求的ATYPE BND.ADDR 服务绑定的地址 BND.PORT 服务绑定的端口DST.PORT // 请求阶段 if _, err = io.ReadFull(rw, buf[:3]); err != nil { return } command = buf[1] addr, err = ReadAddr(rw, buf) if err != nil { return } switch command { case CmdConnect, CmdUDPAssociate: localAddr := ParseAddr(rw.LocalAddr().String()) if localAddr == nil { err = ErrAddressNotSupported } else { // 返回响应 _, err = rw.Write(bytes.Join([][]byte{{5, 0, 0}, localAddr}, []byte{})) } ... } func ReadAddr(r io.Reader, b []byte) (Addr, error) { _, err := io.ReadFull(r, b[:1]) if err != nil { return nil, err } switch b[0] { case AtypDomainName: _, err = io.ReadFull(r, b[1:2]) if err != nil { return nil, err } domainLength := uint16(b[1]) _, err = io.ReadFull(r, b[2:2+domainLength+2]) return b[:1+1+domainLength+2], err case AtypIPv4: _, err = io.ReadFull(r, b[1:1+net.IPv4len+2]) return b[:1+net.IPv4len+2], err case AtypIPv6: _, err = io.ReadFull(r, b[1:1+net.IPv6len+2]) return b[:1+net.IPv6len+2], err } return nil, ErrAddressNotSupported } Relay阶段 socks5服务器收到请求后，解析内容。如果是UDP请求，服务器直接转发; 如果是TCP请求，服务器向目标服务器建立TCP连接，后续负责把客户端的所有数据转发到目标服务。\nTrojan协议 连接Trojan服务端需要TLS握手，后续的流量就是TLS保护的了。\ntrojan客户端与trojan服务端之间使用自定义的协议，官方文档上已经有相应的说明：\n+-----------------------+---------+----------------+---------+----------+ | hex(SHA224(password)) | CRLF | Trojan Request | CRLF | Payload | +-----------------------+---------+----------------+---------+----------+ | 56 | X\u0026#39;0D0A\u0026#39; | Variable | X\u0026#39;0D0A\u0026#39; | Variable | +-----------------------+---------+----------------+---------+----------+ where Trojan Request is a SOCKS5-like request: +-----+------+----------+----------+ | CMD | ATYP | DST.ADDR | DST.PORT | +-----+------+----------+----------+ | 1 | 1 | Variable | 2 | +-----+------+----------+----------+ where: o CMD o CONNECT X\u0026#39;01\u0026#39; o UDP ASSOCIATE X\u0026#39;03\u0026#39; o ATYP address type of following address o IP V4 address: X\u0026#39;01\u0026#39; o DOMAINNAME: X\u0026#39;03\u0026#39; o IP V6 address: X\u0026#39;04\u0026#39; o DST.ADDR desired destination address o DST.PORT desired destination port in network octet order trojan客户端发起的数据包中，头部都是上面结构所示的那样：\n头部最开始是56字节的hash，这个hash是配置中设置的字符串密码（实现商量好的）计算出来的hash值。 hash之后跟CRLF换行符。 CRLF后是TrojanRequest的结构。 TrojanRequest后又是一个CRLF换行符。 CRLF之后便是真正的数据。 参考资料 理解socks5协议的工作过程和协议细节 SOCKS Protocol Version 5 socks4.protocol The Trojan Protocol 浅析trojan协议原理 HTTPS 的工作原理 ","permalink":"https://carlos19960601.github.io/posts/%E5%90%84%E7%A7%8D%E4%BD%A0%E6%87%82%E7%9A%84%E5%8D%8F%E8%AE%AE/","summary":"\u003ch1 id=\"socks5协议\"\u003eSocks5协议\u003c/h1\u003e\n\u003cp\u003e具体协议过程参考\u003ca href=\"https://wiyi.org/socks5-protocol-in-deep.html#25-%E5%8D%8F%E8%AE%AE%E7%BB%86%E8%8A%82\"\u003e理解socks5协议的工作过程和协议细节\u003c/a\u003e。这篇文章主要是通过代码去理解socks5协议。\u003c/p\u003e\n\u003ch2 id=\"实验条件介绍\"\u003e实验条件介绍\u003c/h2\u003e\n\u003cp\u003e命令行设置proxy\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexport https_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003esocks5://127.0.0.1:7891 http_proxy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003esocks5://127.0.0.1:7891\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e之后通过curl发起http请求。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecurl www.baidu.com\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这时候，curl这个命令就会走socks协议，并封装socks协议数据发送给\u003ccode\u003esocks5://127.0.0.1:7891\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"协商阶段\"\u003e协商阶段\u003c/h2\u003e\n\u003cp\u003e根据参考资料，握手阶段-协商阶段发送的数据格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e+----+----------+----------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e|VER | NMETHODS | METHODS  |\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e+----+----------+----------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e| 1  |    1     | 1 to 255 |\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e+----+----------+----------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e#上方的数字表示字节数，下面的表格同理，不再赘述\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eVER: 协议版本，socks5为0x05\u003c/p\u003e\n\u003cp\u003eNMETHODS: 支持认证的方法数量\u003c/p\u003e\n\u003cp\u003eMETHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eX’00’ NO AUTHENTICATION REQUIRED\u003c/li\u003e\n\u003cli\u003eX’01’ GSSAPI\u003c/li\u003e\n\u003cli\u003eX’02’ USERNAME/PASSWORD\u003c/li\u003e\n\u003cli\u003eX’03’ to X’7F’ IANA ASSIGNED\u003c/li\u003e\n\u003cli\u003eX’80’ to X’FE’ RESERVED FOR PRIVATE METHODS\u003c/li\u003e\n\u003cli\u003eX’FF’ NO ACCEPTABLE METHODS\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e那么socks服务端接受到请求时，需要解析内容，选中一个METHOD返回给客户端，格式如下:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e+----+--------+\n|VER | METHOD |\n+----+--------+\n| 1  |   1    |\n+----+--------+\n\u003c/code\u003e\u003c/pre\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eServerHandshake\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enet\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eConn\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eauthenticator\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eauth\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAuthenticator\u003c/span\u003e) (\u003cspan style=\"color:#a6e22e\"\u003eaddr\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAddr\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ecommand\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCommand\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003eio\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eReadFull\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ebuf\u003c/span\u003e[:\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e]); \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003enmethods\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebuf\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003eio\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eReadFull\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ebuf\u003c/span\u003e[:\u003cspan style=\"color:#a6e22e\"\u003enmethods\u003c/span\u003e]); \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e// 返回信息,需要认证\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eauthenticator\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 版本和认证方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eWrite\u003c/span\u003e([]\u003cspan style=\"color:#66d9ef\"\u003ebyte\u003c/span\u003e{\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e}); \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e上面代码逻辑就是处理这个过程。代码中固定返回的是\u003ccode\u003eX’02’ USERNAME/PASSWORD\u003c/code\u003e这种认证方式。\u003c/p\u003e","title":"各种你懂的协议"},{"content":"开发工具 科学上网\nClash.Verge\nApple M芯片：Clash.Verge_1.7.2_aarch64.dmg\nIntel芯片：Clash.Verge_1.7.2_x64.dmg\nClashX\nClashX.dmg ClashX Pro\nClashX Pro Homebrew\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 通过Homebrew安装的\nbrew install git go hugo git-lfs rust bruno sequel-ace node pnpm brew install --cask warp orbstack flutter losslesscut obsidian google-chrome vscode\nAndroid Studio\nDash 设计 Billfish AceMovi Video Editor Amadine Sip Pixelmator Pro 其他 Telegram DaisyDisk Permute 3 IINA brew install --cask iina Google Chrome ","permalink":"https://carlos19960601.github.io/posts/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/","summary":"\u003ch1 id=\"开发工具\"\u003e开发工具\u003c/h1\u003e\n\u003cp\u003e科学上网\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eClash.Verge\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eApple M芯片：\u003ca href=\"/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/Clash.Verge_1.7.2_aarch64.dmg\"\u003eClash.Verge_1.7.2_aarch64.dmg\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIntel芯片：\u003ca href=\"/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/Clash.Verge_1.7.2_x64.dmg\"\u003eClash.Verge_1.7.2_x64.dmg\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eClashX\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/ClashX.dmg\"\u003eClashX.dmg\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eClashX Pro\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/%E6%96%B0%E6%9C%BA%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/ClashXPro.dmg\"\u003eClashX Pro\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://brew.sh/\"\u003eHomebrew\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e/bin/bash -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003ecurl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e通过\u003ccode\u003eHomebrew\u003c/code\u003e安装的\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebrew install git go hugo git-lfs rust bruno sequel-ace node pnpm\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebrew install --cask warp orbstack flutter losslesscut obsidian google-chrome\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://code.visualstudio.com/\"\u003evscode\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.android.com/studio?hl=zh-cn\"\u003eAndroid Studio\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDash\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"设计\"\u003e设计\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBillfish\u003c/li\u003e\n\u003cli\u003eAceMovi Video Editor\u003c/li\u003e\n\u003cli\u003eAmadine\u003c/li\u003e\n\u003cli\u003eSip\u003c/li\u003e\n\u003cli\u003ePixelmator Pro\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"其他\"\u003e其他\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://telegram.org/\"\u003eTelegram\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDaisyDisk\u003c/li\u003e\n\u003cli\u003ePermute 3\u003c/li\u003e\n\u003cli\u003eIINA\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ebrew install --cask iina\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eGoogle Chrome\u003c/li\u003e\n\u003c/ul\u003e","title":"新机必备软件"},{"content":"基本语法 targets: prerequisites command command command 变量 声明变量\nNAME=ClashV BINDIR=bin 使用$()来引用变量\nPLATFORM_LIST = \\ darwin-amd64 \\ darwin-amd64-compatible \\ all-arch: $(PLATFORM_LIST) 自动变量 $@: 表示target\ndarwin-amd64: GOARCH=amd64 GOOS=darwin $(GOBUILD) -o $(BINDIR)/$(NAME)-$@ 条件判断 ifeq ($(BRANCH),Alpha) VERSION=alpha-$(shell git rev-parse --short HEAD) else ifeq ($(BRANCH),Beta) VERSION=beta-$(shell git rev-parse --short HEAD) else ifeq ($(BRANCH),) VERSION=$(shell git describe --tags) else VERSION=$(shell git rev-parse --short HEAD) endif 函数 shell BRANCH=$(shell git branch --show-current) 相关链接 Makefile Tutorial ","permalink":"https://carlos19960601.github.io/posts/%E6%80%8E%E4%B9%88%E5%86%99makefile/","summary":"\u003ch2 id=\"基本语法\"\u003e基本语法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-makefile\" data-lang=\"makefile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003etargets\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e prerequisites\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcommand\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcommand\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcommand\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"变量\"\u003e变量\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e声明变量\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-makefile\" data-lang=\"makefile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNAME\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eClashV\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBINDIR\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ebin\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e使用\u003ccode\u003e$()\u003c/code\u003e来引用变量\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-makefile\" data-lang=\"makefile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePLATFORM_LIST \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e\tdarwin-amd64 \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e\tdarwin-amd64-compatible \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eall-arch\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003ePLATFORM_LIST\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"自动变量\"\u003e自动变量\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e$@\u003c/code\u003e: 表示target\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-makefile\" data-lang=\"makefile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003edarwin-amd64\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tGOARCH\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eamd64 GOOS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003edarwin \u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eGOBUILD\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e -o \u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eBINDIR\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e/\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eNAME\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e-$@\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"条件判断\"\u003e条件判断\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-makefile\" data-lang=\"makefile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eifeq\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eBRANCH\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e,Alpha)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eVERSION\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ealpha-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eshell git rev-parse --short HEAD\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eifeq\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eBRANCH\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e,Beta)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eVERSION\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ebeta-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eshell git rev-parse --short HEAD\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eifeq\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eBRANCH\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e,)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eVERSION\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eshell git describe --tags\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eVERSION\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eshell git rev-parse --short HEAD\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003eendif\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"函数\"\u003e函数\u003c/h2\u003e\n\u003ch3 id=\"shell\"\u003eshell\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-makefile\" data-lang=\"makefile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBRANCH\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eshell git branch --show-current\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"相关链接\"\u003e相关链接\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://makefiletutorial.com/\"\u003eMakefile Tutorial\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"怎么写Makefile"},{"content":" react-rough-fiber: 渲染手绘风 SVG 的 React 渲染器，可以轻松把 SVG 转换成手绘风图片 ","permalink":"https://carlos19960601.github.io/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/","summary":"\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Bowen7/react-rough-fiber\"\u003ereact-rough-fiber\u003c/a\u003e: 渲染手绘风 SVG 的 React 渲染器，可以轻松把 SVG 转换成手绘风图片\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae%e6%8e%a8%e8%8d%90/react-rough-fiber.png\" alt=\"react-rough-fiber\"  /\u003e\n\u003c/p\u003e","title":"开源项目推荐【持续更新】"},{"content":" happyhues: 网站颜色搭配神器 cobalt: 视频下载 indiehackers: 独立开发导航站 openalternative: 查找平替软件 ","permalink":"https://carlos19960601.github.io/posts/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.happyhues.co/\"\u003ehappyhues\u003c/a\u003e: 网站颜色搭配神器\n\u003cimg loading=\"lazy\" src=\"/%e5%b7%a5%e5%85%b7%e6%8e%a8%e8%8d%90/happyhues.png\" alt=\"\"  /\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cobalt.tools/\"\u003ecobalt\u003c/a\u003e: 视频下载\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.indiehackers.site/\"\u003eindiehackers\u003c/a\u003e: 独立开发导航站\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://openalternative.co/\"\u003eopenalternative\u003c/a\u003e: 查找平替软件\u003c/li\u003e\n\u003c/ul\u003e","title":"工具推荐【持续更新】"},{"content":" Least Recently Used(LRU): 删除最旧的数据。基本假设是最近访问的数据可能很快会再次被需要。 Most Recently Used(MRU): 与LRU相反，删除最新的数据。常用于流处理或批处理平台，这些平台一旦使用数据就不太可能再次需要。 Least Frequently Used(LFU): 删除使用最少的数据。虽然它是一种比 LRU 更准确的方法，但它需要一种机制来记录数据访问的频率，这增加了复杂性。它通常与 LRU 等策略配合使用，以降低缓存过时数据的风险。 Time-To-Live (TTL)：数据在预设的时间段有效。常用在会话数据中。 Two-tiered caching两层缓存提供了一种更复杂的方法。可以在速度和成本之间取得平衡。在此设计中，数据被分为快速、昂贵的层（用于流行数据）和较慢、经济的层（用于较少访问的数据）。 上述五种策略是最流行的缓存方法。还有其他一些策略：\n先进先出（FIFO）：最旧的数据首先被删除。 随机替换（RR）：随机选择要删除的数据。 自适应替换缓存 (ARC)：使用自调整算法跟踪新近度和频率来确定首先删除哪些数据。 ","permalink":"https://carlos19960601.github.io/posts/%E7%BC%93%E5%AD%98%E9%A9%B1%E9%80%90%E7%AD%96%E7%95%A5/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e7%bc%93%e5%ad%98%e9%a9%b1%e9%80%90%e7%ad%96%e7%95%a5/Cache%20Eviction%20Strtegies.gif\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLeast Recently Used(LRU)\u003c/strong\u003e: 删除最旧的数据。基本假设是最近访问的数据可能很快会再次被需要。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMost Recently Used(MRU)\u003c/strong\u003e: 与\u003cstrong\u003eLRU\u003c/strong\u003e相反，删除最新的数据。常用于流处理或批处理平台，这些平台一旦使用数据就不太可能再次需要。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLeast Frequently Used(LFU)\u003c/strong\u003e: 删除使用最少的数据。虽然它是一种比 \u003cstrong\u003eLRU\u003c/strong\u003e 更准确的方法，但它需要一种机制来记录数据访问的频率，这增加了复杂性。它通常与 \u003cstrong\u003eLRU\u003c/strong\u003e 等策略配合使用，以降低缓存过时数据的风险。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTime-To-Live (TTL)\u003c/strong\u003e：数据在预设的时间段有效。常用在会话数据中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTwo-tiered caching\u003c/strong\u003e两层缓存提供了一种更复杂的方法。可以在速度和成本之间取得平衡。在此设计中，数据被分为快速、昂贵的层（用于流行数据）和较慢、经济的层（用于较少访问的数据）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上述五种策略是最流行的缓存方法。还有其他一些策略：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e先进先出（FIFO\u003c/strong\u003e）：最旧的数据首先被删除。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e随机替换（RR）\u003c/strong\u003e：随机选择要删除的数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e自适应替换缓存 (ARC)\u003c/strong\u003e：使用自调整算法跟踪新近度和频率来确定首先删除哪些数据。\u003c/li\u003e\n\u003c/ul\u003e","title":"缓存驱逐策略"},{"content":"先看这段代码\nimport ( \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync/atomic\u0026#34; ) func main() { var v atomic.Value var err error err = \u0026amp;http.ProtocolError{} v.Store(err) err = io.EOF v.Store(err) } 运行后会报错 panic: sync/atomic: store of inconsistently typed value into Value。\n原因是atomic.Value.Store需要类型是一致的。在这里err类型发生了变化，虽然他们都是error接口类型。具体参考Issues#22550\n怎么解决？包装一层就能运行了。\ntype tValue[T any] struct { value T } func main() { var v atomic.Value var err error err = \u0026amp;http.ProtocolError{} v.Store(tValue[error]{err}) err = io.EOF v.Store(tValue[error]{err}) } ","permalink":"https://carlos19960601.github.io/posts/atomic.value%E5%AD%98%E5%82%A8interface%E7%9A%84%E9%97%AE%E9%A2%98/","summary":"\u003cp\u003e先看这段代码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;io\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;net/http\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;sync/atomic\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eValue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ehttp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eProtocolError\u003c/span\u003e{}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eStore\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003eio\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eEOF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eStore\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e运行后会报错 \u003ccode\u003epanic: sync/atomic: store of inconsistently typed value into Value\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e原因是\u003ccode\u003eatomic.Value.Store\u003c/code\u003e需要类型是一致的。在这里\u003ccode\u003eerr\u003c/code\u003e类型发生了变化，虽然他们都是\u003ccode\u003eerror\u003c/code\u003e接口类型。具体参考\u003ca href=\"https://github.com/golang/go/issues/22550\"\u003eIssues#22550\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e怎么解决？包装一层就能运行了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etValue\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eany\u003c/span\u003e] \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eValue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ehttp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eProtocolError\u003c/span\u003e{}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eStore\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003etValue\u003c/span\u003e[\u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e]{\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003eio\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eEOF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eStore\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003etValue\u003c/span\u003e[\u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e]{\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"atomic.Value存储interface的问题"},{"content":"很早之前做的一次分享，下面是PPT内容\n","permalink":"https://carlos19960601.github.io/posts/mysql%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E4%BA%AB/","summary":"\u003cp\u003e很早之前做的一次分享，下面是PPT内容\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/01.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/02.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/03.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/04.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/05.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/06.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/07.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/08.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/09.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/10.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/11.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/12.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/13.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/14.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/15.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/16.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/17.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/18.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/19.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/20.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/21.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/22.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/23.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/24.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/25.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/26.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/27.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/28.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/29.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/30.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/31.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/32.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/33.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/34.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/MySQL%e5%ad%98%e5%82%a8%e4%b8%8e%e7%b4%a2%e5%bc%95%e5%8e%9f%e7%90%86/35.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"MySQL存储与索引原理分享"},{"content":"由于GC复杂，我也没有仔细研究过GC的源码，所以只能站在巨人的肩上学习，如果想了解GC的具体实现请移步文末的参考资料。本文只是记录我在阅读完大佬文章中自己的一些问题与思考，可能有一些不对的地方。欢迎大家一起讨论。\n清理阶段，新产生的对象被标记成白色，岂不是会被回收掉？ 在参考文章1留言中也有人提了这个问题\n我再将问题描述一下\n在标记完成的时候会STW，将状态切换成_GCoff，然后就会进入清理阶段，进入清理阶段的时候，已经结束标记阶段，所以这个时候就没有颜色的区分了(当然也可以说新产生的对象时白色的，因为GC开始的时候默认所有的对象都是白色)。\n那新产生的对象，在清理阶段会被回收吗？肯定是不会的，要不然早就崩了，为什么没有被回收呢\n我个人理解是这样的，清理阶段，当Goroutine申请新内存的时候就会触发清理，先进行清理再进行对象的分配，这样就没问题了。因为已经清理了，所以后续也不会清理这块内存了，新对象在清理后再分配也就不会有问题了。\n栈上的黑色对象指向了堆中的白色对象？ 在参考文章1留言中也有人提了这个问题，我就不再重新描述了\n我还是说下我的理解，首先栈分为3种\n还没没有扫描的栈 扫描中的栈 扫描过的栈 如果是扫描中的栈，Groutine是暂停的，也就是栈上的对象不会发生变化，就不再讨论\n如果是还没有扫描的栈，因为栈在最开始的时候都被标记成灰色，不管栈上的对象引用怎么变化，最后都会扫描栈，所以也不会有啥问题\n如果是扫描过的栈，如果发生栈上的对象引用的变化，由于已经扫描过了，不会再扫描，所以就会有问题。但事实上却没有问题，为什么？\n在参考资料golang 混合写屏障原理深入剖析，这篇文章给你梳理的明明白白！！！中说明这个问题的原因\n问题在图片中描述得比较清楚了，栈上的A想要指向堆中的C，有多种方式\nA.C = new(C) A.C = B.C A.C = A.X.C 第1种方式，直接在堆中初始化C，然后A.C指向过去；如果是这样，C就不会是白色的，因为现在正在标记阶段，新对象都是黑色的\n第2种方式，这种是不可能的，Goroutine1栈中能访问到Goroutine2栈中的对象根本就不可能\n第3种方法是A能访问到X，X引用了C，如果是这样，因为Goroutine1已经被扫描过了，A还能访问到X，说明X一定不是白色的，X引用了C，当扫描X的时候C一定不会被标记成白色\n综上所述，Goroutine1栈中的A想要指向堆中的白色对象是不可能。\n删除写屏障到底是把什么对象染成灰色 理解混合写屏障一定要先理解删除写屏障 很多人都能理解插入写屏障，插入写屏障的流程个人理解如下：\nSTW，扫描栈上的对象，标记成灰色 恢复运行，开始并发标记 STW，重新扫描栈，完成标记阶段 由于栈上的对象被当作根对象，栈上的对象发生变更的时候，需要触发插入写屏障，由于栈上的操作频繁，而且要实现栈上的插入写屏障很复杂。所以Golang并没有实现栈上的插入写屏障\n但此时可能会出现如下的情况，栈上的黑色对象会指向白色对象。于是需要在标记完成的时候对栈进行了重新扫描，这时需要STW，这个过程大概需要花费10ms~100ms\n删除写屏障\n删除写屏障也叫基于快照的写屏障方案，必须在起始时，STW 扫描整个栈（注意了，是所有的 goroutine 栈），保证所有堆上在用的对象都处于灰色保护下，保证的是弱三色不变式； 由于起始快照的原因，起始也是执行 STW，删除写屏障不适用于栈特别大的场景，栈越大，STW 扫描时间越长，对于现代服务器上的程序来说，栈地址空间都很大，所以删除写屏障都不适用，一般适用于很小的栈内存，比如嵌入式，物联网的一些程序； 并且删除写屏障会导致扫描进度（波面）的后退，所以扫描精度不如插入写屏障； 思考问题：我不整机暂停 STW 栈，而是一个栈一个栈的快照，这样也没有 STW 了，是否可以满足要求？（这个就是当前 golang 混合写屏障的时候做的哈，虽然没有 STW 了，但是扫描到某一个具体的栈的时候，还是要暂停这一个 goroutine 的）\n不行，纯粹的删除写屏障，起始必须整个栈打快照，要把所有的堆对象都处于灰色保护中才行。\n举例：如果没有把栈完全扫黑，那么可能出现丢数据，如下：\n初始状态：\nA 是 g1 栈的一个对象，g1栈已经扫描完了，并且 C 也是扫黑了的对象； B 是 g2 栈的对象，指向了 C 和 D，g2 完全还没扫描，B 是一个灰色对象，D 是白色对象； 步骤一：g2 进行赋值变更，把 C 指向 D 对象，这个时候黑色的 C 就指向了白色的 D（由于是删除屏障，这里是不会触发hook的）\n步骤二：把 B 指向 C 的引用删除，由于是栈对象操作，不会触发删除写屏障；\n步骤三：清理，因为 C 已经是黑色对象了，所以不会再扫描，所以 D 就会被错误的清理掉。\n解决办法有如下：\n方法一：栈上对象也 hook，所有对象赋值（插入，删除）都 hook（这个就不实际了）;\n所有的插入，删除如果都 hook ，那么一定都不会有问题，虽然本轮精度很差，但是下轮回收可以回收了。但是还是那句话，栈，寄存器的赋值 hook 是不现实的。\n方法二：起始快照整栈扫黑，使得整个堆上的在用对象都处于灰色保护；\n整栈扫黑，那么在用的堆上的对象是一定处于灰色堆对象的保护下的，之后配合堆对象删除写屏障就能保证在用对象不丢失。\n方法三：加入插入写屏障的逻辑，C 指向 D 的时候，把 D 置灰，这样扫描也没问题。这样就能去掉起始 STW 扫描，从而可以并发，一个一个栈扫描。\n细品下，这不就成了当前在用的混合写屏障了，所以我觉得正确的理解方式应该是：混合写屏障 = 删除写屏障 + 插入写屏障，必须先理解下删除写屏障，你才能理解混合写屏障。\n混合写屏障current stack is grey的 理解 在混合写屏障中许多文章都这么描述\nwritePointer(slot, ptr): shade(*slot) if current stack is grey: shade(ptr) *slot = ptr current stack is grey该怎么理解\nProposal中是这么描述的\nif the current goroutine\u0026rsquo;s stack has not yet been scanned, also shades the reference being installed.\n翻译过来就是当前栈还没有被被扫描的时候，需要使用插入写屏障\n首先看一下栈已经被扫描的情况\n正在被扫描/未被扫描的栈\n栈被扫描过的存在上面2种情况\n栈上以及相关联堆上的对象都已经被标记成黑色 栈上的是黑色，堆上部分对象还没有被标记成黑色 这2种情况下即使不使用插入写屏障也不会出现黑色对象指向白色对象的情况\n要想让黑色对象指向白色对象有2种途径\n当前栈中的白色对象（这种情况下就是上图所示，E对象在灰色D对象的保护下，最后还是会被扫描成黑色，所以不会有问题） 其他栈引用了当前栈的黑色对象，将该黑色对象指向了白色对象(这个属于栈未被扫描，会正在扫描的情况，后面说这种情况) 接下来是栈正在被扫描或者未被扫描的情况，如下图\n如果不开启插入写屏障就会出现黑色对象指向白色对象的情况，所以这种情况下需要开启插入写屏障\n参考资料 Go 语言垃圾收集器的实现原理\nGo语言GC实现原理及源码分析 - luozhiyun`s Blog\nProposal: Eliminate STW stack re-scanning\ngolang 垃圾回收 （一）概述篇\ngolang 垃圾回收（二）屏障技术\ngolang 垃圾回收（三）插入写屏障\ngolang 垃圾回收 - 删除写屏障\ngolang 混合写屏障原理深入剖析，这篇文章给你梳理的明明白白！！！\nGolang垃圾回收 屏障技术\n","permalink":"https://carlos19960601.github.io/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/","summary":"\u003cp\u003e由于GC复杂，我也没有仔细研究过GC的源码，所以只能站在巨人的肩上学习，如果想了解GC的具体实现请移步文末的参考资料。本文只是记录我在阅读完大佬文章中自己的一些问题与思考，可能有一些不对的地方。欢迎大家一起讨论。\u003c/p\u003e","title":"关于Golang GC问题的思考"},{"content":"这是在小团队里面的一次分享，以下是PPT内容\n","permalink":"https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/","summary":"\u003cp\u003e这是在小团队里面的一次分享，以下是PPT内容\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/01.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/02.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/03.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/04.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/05.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/06.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/07.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/08.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/10.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/11.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/12.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/13.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/14.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/15.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/16.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/17.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/18.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/19.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/20.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/21.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/22.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/23.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/24.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/timer%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e5%88%86%e4%ba%ab/25.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"Timer源码阅读分享"},{"content":"根据6.3 计时器中的描述，Golang Timer的设计经历了如下阶段：\nGo 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发； Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题 Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO 为什么会发生P和M的绑定和解绑) Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发 我使用的是Go 1.16的版本进行分析\ntimer包的使用 主要分为2类，一次性触发的timer和多次触发的ticker\nfunc TestTimer(t *testing.T) { timer := time.NewTimer(time.Second) // for tm := range timer.C { // t.Log(tm) // timer.Reset(time.Second) // } var ch chan int for { select { case tm := \u0026lt;-timer.C: t.Log(tm) timer.Reset(time.Second) case \u0026lt;-ch: } } } func TestAfter(t *testing.T) { var ch chan int select { case tm := \u0026lt;-time.After(time.Second): t.Log(tm) case \u0026lt;-ch: } } func TestAfterFunc(t *testing.T) { var ch chan int timer := time.AfterFunc(time.Second, func() { t.Log(\u0026#34;我执行了\u0026#34;) ch \u0026lt;- 0 }) defer timer.Stop() \u0026lt;-ch } func TestTicker(t *testing.T) { ticker := time.NewTicker(time.Second) var ch chan int for { select { case tm := \u0026lt;-ticker.C: t.Log(tm) case \u0026lt;-ch: } } } func NewTicker(d Duration) *Ticker { if d \u0026lt;= 0 { panic(errors.New(\u0026#34;non-positive interval for NewTicker\u0026#34;)) } // Give the channel a 1-element time buffer. // If the client falls behind while reading, we drop ticks // on the floor until the client catches up. c := make(chan Time, 1) t := \u0026amp;Ticker{ C: c, r: runtimeTimer{ when: when(d), period: int64(d), f: sendTime, arg: c, }, } startTimer(\u0026amp;t.r) return t } func TestTick(t *testing.T) { for tm := range time.Tick(time.Second) { t.Log(tm) } } 需要注意的是，在for循环中使用的时候需要考虑是否会造成timer的泄漏；具体的示例分析可以参考 Go 内存泄露之痛，这篇把 Go timer.After 问题根因讲透了！\n数据结构 func NewTimer(d Duration) *Timer { c := make(chan Time, 1) t := \u0026amp;Timer{ C: c, r: runtimeTimer{ when: when(d), f: sendTime, arg: c, }, } startTimer(\u0026amp;t.r) return t } 可以看到NewTimer和NewTicker都会初始化runtimeTimer，差别在于Ticker会比Timer多了period参数。最后调用startTimer将timer添加到底层的最小四叉堆中\nruntimeTimer和runtime/time.go#timer结构是保持一致的\ntype timer struct { // If this timer is on a heap, which P\u0026#39;s heap it is on. // puintptr rather than *p to match uintptr in the versions // of this struct defined in other packages. pp puintptr // 当前P的指针 // Timer wakes up at when, and then at when+period, ... (period \u0026gt; 0 only) // each time calling f(arg, now) in the timer goroutine, so f must be // a well-behaved function and not block. // // when must be positive on an active timer. when int64 // 当前计时器被唤醒的时间 period int64 // 两次被唤醒的间隔 f func(interface{}, uintptr) // 每当计时器被唤醒时都会调用的函数 arg interface{} // 计时器被唤醒时调用 f 传入的参数 seq uintptr // What to set the when field to in timerModifiedXX status. nextwhen int64 // 计时器处于 timerModifiedXX 状态时，用于设置 when 字段； // The status field holds one of the values below. status uint32 // 计时器的状态 } 添加timer 前面的startTimer方法其实是runtime/time.go中的startTimer方法，通过//go:linkname关联起来的\n// 把 t 添加到 timer 堆 // startTimer adds t to the timer heap. //go:linkname startTimer time.startTimer func startTimer(t *timer) { if raceenabled { racerelease(unsafe.Pointer(t)) } addtimer(t) } 继续调用addtimer方法\n// addtimer adds a timer to the current P. // This should only be called with a newly created timer. // That avoids the risk of changing the when field of a timer in some P\u0026#39;s heap, // which could cause the heap to become unsorted. func addtimer(t *timer) { // when must be positive. A negative value will cause runtimer to // overflow during its delta calculation and never expire other runtime // timers. Zero will cause checkTimers to fail to notice the timer. if t.when \u0026lt;= 0 { throw(\u0026#34;timer when must be positive\u0026#34;) } if t.period \u0026lt; 0 { throw(\u0026#34;timer period must be non-negative\u0026#34;) } if t.status != timerNoStatus { // 添加新的timer必须是timerNoStatus throw(\u0026#34;addtimer called with initialized timer\u0026#34;) } t.status = timerWaiting when := t.when pp := getg().m.p.ptr() lock(\u0026amp;pp.timersLock) cleantimers(pp) doaddtimer(pp, t) unlock(\u0026amp;pp.timersLock) wakeNetPoller(when) } addtimer首先对参数进行了校验，timer的初始化status必须是timerNoStatus(计时器尚未设置状态)，然后将timer的status切换成timerWaiting(等待计时器启动)\n然后调用cleantimers(pp)处理P中timers堆顶上已经取消(timerDeleted)或者时间发生改变(timerModifiedEarlier/timerModifiedLater的timer)，对timers进行清理\n// 清理堆顶部的timer，与adjusttimers方法类似，只是adjusttimers会遍历搜索的timers // 注意cleantimers清理的是堆顶部的timer，只要顶部是timerDeleted，timerModifiedEarlier/timerModifiedLater的timer都会处理 // 处理完后会调整堆，再处理堆顶部的timer，所以不只是处理1个timer， // 当堆前面的timer是timerDeleted，timerModifiedEarlier/timerModifiedLater状态的时候都会进行处理 // adjusttimers不管是什么状态的timer，都会便利处理一遍 // cleantimers会出现下面2种状态的变化，也就是清除已经删除的，移动timer0 // timerDeleted -\u0026gt; timerRemoving -\u0026gt; timerRemoved // timerModifiedEarlier/timerModifiedLater -\u0026gt; timerMoving -\u0026gt; timerWaiting func cleantimers(pp *p) { gp := getg() for { if len(pp.timers) == 0 { return } // This loop can theoretically run for a while, and because // it is holding timersLock it cannot be preempted. // If someone is trying to preempt us, just return. // We can clean the timers later. if gp.preemptStop { return } t := pp.timers[0] // 堆顶，when最小，最早发生的timer if t.pp.ptr() != pp { throw(\u0026#34;cleantimers: bad p\u0026#34;) } switch s := atomic.Load(\u0026amp;t.status); s { case timerDeleted: // timerDeleted --\u0026gt; timerRemoving --\u0026gt; 从堆中删除timer --\u0026gt; timerRemoved if !atomic.Cas(\u0026amp;t.status, s, timerRemoving) { continue } dodeltimer0(pp) if !atomic.Cas(\u0026amp;t.status, timerRemoving, timerRemoved) { badTimer() } atomic.Xadd(\u0026amp;pp.deletedTimers, -1) case timerModifiedEarlier, timerModifiedLater: // TODO 如果modTimer将非timer0的when改成了比timer0更先触发的时候是怎么处理的 // timerMoving --\u0026gt; 调整 timer 的时间 --\u0026gt; timerWaiting // 此时 timer 被调整为更早或更晚，将原先的 timer 进行删除，再重新添加 if !atomic.Cas(\u0026amp;t.status, s, timerMoving) { continue } // Now we can change the when field. t.when = t.nextwhen // Move t to the right position. // 删除原来的 dodeltimer0(pp) // 然后再重新添加 doaddtimer(pp, t) if s == timerModifiedEarlier { atomic.Xadd(\u0026amp;pp.adjustTimers, -1) // 如果t0之前是timerModifiedEarlier，因为已经调整了t0，所以需要将adjustTimers减1 } if !atomic.Cas(\u0026amp;t.status, timerMoving, timerWaiting) { badTimer() } default: // Head of timers does not need adjustment. return } } } cleantimers(pp *p)方法会循环处理堆顶部是timerDeleted，timerModifiedEarlier/timerModifiedLater的timer\n如果是timerDeleted，说明timer已经取消了，从timers堆中删除，重新调整timers堆 如果是timerModifiedEarlier/timerModifiedLater，说明timer的时间发生改变，修改timer的when字段，删除之前的timer，重新添加新的timer cleantimers(pp *p)方法只是对p中的timers堆做了一些清理调整的工作，真正添加是doaddtimer方法\n// doaddtimer adds t to the current P\u0026#39;s heap. // The caller must have locked the timers for pp. func doaddtimer(pp *p, t *timer) { // Timers依赖network poller，确保netpoll经初始化了 // Timers rely on the network poller, so make sure the poller // has started. if netpollInited == 0 { netpollGenericInit() } if t.pp != 0 { // 创建timer时没有绑定p，如果p存在的话属于异常情况 throw(\u0026#34;doaddtimer: P already set in timer\u0026#34;) } t.pp.set(pp) // timer绑定到当前P的堆上 i := len(pp.timers) pp.timers = append(pp.timers, t) siftupTimer(pp.timers, i) // 调整4叉堆 if t == pp.timers[0] { // 如果新加入的timer是当前p中最新触发的，将t.when保存到pp.timer0When atomic.Store64(\u0026amp;pp.timer0When, uint64(t.when)) } atomic.Xadd(\u0026amp;pp.numTimers, 1) } doaddtimer方法中判断了netpoll是否初始化了，如果没有对其进行初始化，这里我还没有理解timer和netpoll之间的关系，作为todo，后续再补充\n后面就是p的timer之间的绑定，添加到四叉堆，然后平衡四叉堆，这里就不细说了\ndoaddtimer方法返回后，回到addtimer方法会调用wakeNetPoller方法\n// wakeNetPoller wakes up the thread sleeping in the network poller if it isn\u0026#39;t // going to wake up before the when argument; or it wakes an idle P to service // timers and the network poller if there isn\u0026#39;t one already. func wakeNetPoller(when int64) { if atomic.Load64(\u0026amp;sched.lastpoll) == 0 { // In findrunnable we ensure that when polling the pollUntil // field is either zero or the time to which the current // poll is expected to run. This can have a spurious wakeup // but should never miss a wakeup. pollerPollUntil := int64(atomic.Load64(\u0026amp;sched.pollUntil)) if pollerPollUntil == 0 || pollerPollUntil \u0026gt; when { // 网络轮询器poll \u0026gt; timer的触发时间，立即唤醒netpoll netpollBreak() } } else { // There are no threads in the network poller, try to get // one there so it can handle new timers. if GOOS != \u0026#34;plan9\u0026#34; { // Temporary workaround - see issue #42303. wakep() } } } // netpollBreak interrupts a kevent. func netpollBreak() { if atomic.Cas(\u0026amp;netpollWakeSig, 0, 1) { for { var b byte n := write(netpollBreakWr, unsafe.Pointer(\u0026amp;b), 1) if n == 1 || n == -_EAGAIN { break } if n == -_EINTR { continue } println(\u0026#34;runtime: netpollBreak write failed with\u0026#34;, -n) throw(\u0026#34;runtime: netpollBreak write failed\u0026#34;) } } } wakeNetPoller方法其实就是向netpoll初始化的全局epfd文件描述符写入了数据（epfd和golang netpoll有关，想了解netpoll的请自行了解）。主要目的是为了唤醒netpoll\n停止timer 可以通过Ticker#Stop和Timer#Stop停止timer\n// Stop prevents the Timer from firing. // It returns true if the call stops the timer, false if the timer has already // expired or been stopped. // Stop does not close the channel, to prevent a read from the channel succeeding // incorrectly. // // To ensure the channel is empty after a call to Stop, check the // return value and drain the channel. // For example, assuming the program has not received from t.C already: // // if !t.Stop() { // \u0026lt;-t.C // } // // This cannot be done concurrent to other receives from the Timer\u0026#39;s // channel or other calls to the Timer\u0026#39;s Stop method. // // For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer // has already expired and the function f has been started in its own goroutine; // Stop does not wait for f to complete before returning. // If the caller needs to know whether f is completed, it must coordinate // with f explicitly. func (t *Timer) Stop() bool { if t.r.f == nil { panic(\u0026#34;time: Stop called on uninitialized Timer\u0026#34;) } return stopTimer(\u0026amp;t.r) } // Stop turns off a ticker. After Stop, no more ticks will be sent. // Stop does not close the channel, to prevent a concurrent goroutine // reading from the channel from seeing an erroneous \u0026#34;tick\u0026#34;. func (t *Ticker) Stop() { stopTimer(\u0026amp;t.r) } 最后都是调用runtime.stopTimer方法；通过//go:linkname进行关联\n// stopTimer stops a timer. // It reports whether t was stopped before being run. //go:linkname stopTimer time.stopTimer func stopTimer(t *timer) bool { return deltimer(t) } // 返回的是这个timer在执行前被移除的，已经执行过了就返回false，还没有执行就返回true // deltimer deletes the timer t. It may be on some other P, so we can\u0026#39;t // actually remove it from the timers heap. We can only mark it as deleted. // It will be removed in due course by the P whose heap it is on. // Reports whether the timer was removed before it was run. func deltimer(t *timer) bool { for { switch s := atomic.Load(\u0026amp;t.status); s { case timerWaiting, timerModifiedLater: // timer还没启动或修改为更晚的时间 // Prevent preemption while the timer is in timerModifying. // This could lead to a self-deadlock. See #38070. mp := acquirem() // timerWaiting/timerModifiedLater --\u0026gt; timerModifying --\u0026gt; timerDeleted if atomic.Cas(\u0026amp;t.status, s, timerModifying) { // TODO 为什么要先切换为timerModifying // Must fetch t.pp before changing status, // as cleantimers in another goroutine // can clear t.pp of a timerDeleted timer. tpp := t.pp.ptr() if !atomic.Cas(\u0026amp;t.status, timerModifying, timerDeleted) { // 置为timerDeleted状态 badTimer() } releasem(mp) atomic.Xadd(\u0026amp;tpp.deletedTimers, 1) // Timer was not yet run. return true } else { // 修改为timerModifying失败，说明t的状态已经不再是timerWaiting, timerModifiedLater了 releasem(mp) // 下一次再来处理 } case timerModifiedEarlier: // Prevent preemption while the timer is in timerModifying. // This could lead to a self-deadlock. See #38070. mp := acquirem() // timerModifiedEarlier --\u0026gt; timerModifying --\u0026gt; timerDeleted if atomic.Cas(\u0026amp;t.status, s, timerModifying) { // Must fetch t.pp before setting status // to timerDeleted. tpp := t.pp.ptr() atomic.Xadd(\u0026amp;tpp.adjustTimers, -1) // timerModifiedEarlier的timer被stop了，所以需要将adjustTimers-1 if !atomic.Cas(\u0026amp;t.status, timerModifying, timerDeleted) { badTimer() } releasem(mp) atomic.Xadd(\u0026amp;tpp.deletedTimers, 1) // Timer was not yet run. return true } else { releasem(mp) // 下一次再来处理 } case timerDeleted, timerRemoving, timerRemoved: // Timer was already run. // Timer 已经运行 return false case timerRunning, timerMoving: // 正在执行或被移动了，等待完成，下一次再来处理 // The timer is being run or moved, by a different P. // Wait for it to complete. osyield() case timerNoStatus: // Removing timer that was never added or // has already been run. Also see issue 21874. return false case timerModifying: // 同时调用了deltimer，modtimer；等待其他调用完成，下一次再来处理 // Simultaneous calls to deltimer and modtimer. // Wait for the other call to complete. osyield() default: badTimer() } } } 从deltimer方法中可以看出，timer会发生如下的状态变化\ntimerWaiting, timerModifiedLater → timerModifying → timerDeleted\n如果要停止的timer状态是timerWaiting, timerModifiedLater，说明timer还没有执行，将状态切换成timerModifying改变中，最后将状态切换成timerDeleted\ntimerModifiedEarlier → timerModifying \u0026ndash;\u0026gt; timerDeleted\n如果要停止的timer状态是timerModifiedEarlier，说明timer的时间被改变过，比如reset过，将状态切换成timerModifying改变中，最后将状态切换成timerDeleted\ntimerDeleted, timerRemoving, timerRemoved → 什么都不做\ntimerRunning, timerMoving → 等待操作完成\ntimerNoStatus → 直接返回\ntimerModifying → 等待操作完成\n我在这里有2个问题\n为什么timer状态变化的时候需要需要先改为timerModifying然后再修改成最后的状态？\n答：首先声明这个只是我个人的理解可能会存在错误；在timer的status状态常量这有这么一段注释\n// We don\u0026#39;t permit calling addtimer/deltimer/modtimer/resettimer simultaneously, // but adjusttimers and runtimer can be called at the same time as any of those. 为了保证addtimer/deltimer/modtimer/resettimer不能被同时调用，所以需要timerModifying这个状态\ndeltimer并没有从 四叉堆中删除timer，只是将timer的状态切换成timerDeleted，这个是为什么？\n这个在deltimer的注释上已经说明了\n// deltimer deletes the timer t. It may be on some other P, so we can\u0026#39;t // actually remove it from the timers heap. We can only mark it as deleted. // It will be removed in due course by the P whose heap it is on. deltimer删除的timer可能在其他P上，以为调度循环的 时候不仅会从其他P上偷G，还会偷timer，所以只是对timer进行标记，在timer所在的P中，通过 cleantimers/adjusttimers等方法来真正从堆中删除\n其他timer的方法 分析了2个timer的方法后，就不再逐个看其他的方法了，大概都差不多，都是对timers堆中的timer状态进行修改，timers的调整等\n修改timer // modtimer modifies an existing timer. // This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset. // Reports whether the timer was modified before it was run. func modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) bool { if when \u0026lt;= 0 { throw(\u0026#34;timer when must be positive\u0026#34;) } if period \u0026lt; 0 { throw(\u0026#34;timer period must be non-negative\u0026#34;) } status := uint32(timerNoStatus) wasRemoved := false var pending bool var mp *m loop: for { switch status = atomic.Load(\u0026amp;t.status); status { case timerWaiting, timerModifiedEarlier, timerModifiedLater: // Prevent preemption while the timer is in timerModifying. // This could lead to a self-deadlock. See #38070. mp = acquirem() // timerWaiting, timerModifiedEarlier, timerModifiedLater --\u0026gt; timerModifying if atomic.Cas(\u0026amp;t.status, status, timerModifying) { pending = true // timer not yet run break loop } releasem(mp) case timerNoStatus, timerRemoved: // Prevent preemption while the timer is in timerModifying. // This could lead to a self-deadlock. See #38070. mp = acquirem() // Timer was already run and t is no longer in a heap. // Act like addtimer. // timerNoStatus, timerRemoved --\u0026gt; timerModifying if atomic.Cas(\u0026amp;t.status, status, timerModifying) { wasRemoved = true pending = false // timer already run or stopped break loop } releasem(mp) case timerDeleted: // Prevent preemption while the timer is in timerModifying. // This could lead to a self-deadlock. See #38070. mp = acquirem() // timerDeleted --\u0026gt; timerModifying if atomic.Cas(\u0026amp;t.status, status, timerModifying) { atomic.Xadd(\u0026amp;t.pp.ptr().deletedTimers, -1) pending = false // timer already stopped break loop } releasem(mp) case timerRunning, timerRemoving, timerMoving: // The timer is being run or moved, by a different P. // Wait for it to complete. osyield() // 等待状态改变 case timerModifying: // Multiple simultaneous calls to modtimer. // Wait for the other call to complete. osyield() // 等待状态改变 default: badTimer() } } t.period = period t.f = f t.arg = arg t.seq = seq if wasRemoved { t.when = when pp := getg().m.p.ptr() lock(\u0026amp;pp.timersLock) doaddtimer(pp, t) unlock(\u0026amp;pp.timersLock) if !atomic.Cas(\u0026amp;t.status, timerModifying, timerWaiting) { badTimer() } releasem(mp) wakeNetPoller(when) } else { // The timer is in some other P\u0026#39;s heap, so we can\u0026#39;t change // the when field. If we did, the other P\u0026#39;s heap would // be out of order. So we put the new when value in the // nextwhen field, and let the other P set the when field // when it is prepared to resort the heap. t.nextwhen = when newStatus := uint32(timerModifiedLater) if when \u0026lt; t.when { newStatus = timerModifiedEarlier } tpp := t.pp.ptr() // Update the adjustTimers field. Subtract one if we // are removing a timerModifiedEarlier, add one if we // are adding a timerModifiedEarlier. adjust := int32(0) if status == timerModifiedEarlier { adjust-- } if newStatus == timerModifiedEarlier { adjust++ updateTimerModifiedEarliest(tpp, when) } if adjust != 0 { atomic.Xadd(\u0026amp;tpp.adjustTimers, adjust) } // Set the new status of the timer. if !atomic.Cas(\u0026amp;t.status, timerModifying, newStatus) { badTimer() } releasem(mp) // If the new status is earlier, wake up the poller. if newStatus == timerModifiedEarlier { wakeNetPoller(when) } } return pending } 调整timer // 与cleantimers类似，只是 cleantimers 只处理队列头部的timer // adjusttimers looks through the timers in the current P\u0026#39;s heap for // any timers that have been modified to run earlier, and puts them in // the correct place in the heap. While looking for those timers, // it also moves timers that have been modified to run later, // and removes deleted timers. The caller must have locked the timers for pp. func adjusttimers(pp *p, now int64) { if atomic.Load(\u0026amp;pp.adjustTimers) == 0 { if verifyTimers { verifyTimerHeap(pp) } // There are no timers to adjust, so it is safe to clear // timerModifiedEarliest. Do so in case it is stale. // Everything will work if we don\u0026#39;t do this, // but clearing here may save future calls to adjusttimers. atomic.Store64(\u0026amp;pp.timerModifiedEarliest, 0) return } // If we haven\u0026#39;t yet reached the time of the first timerModifiedEarlier // timer, don\u0026#39;t do anything. This speeds up programs that adjust // a lot of timers back and forth if the timers rarely expire. // We\u0026#39;ll postpone looking through all the adjusted timers until // one would actually expire. if first := atomic.Load64(\u0026amp;pp.timerModifiedEarliest); first != 0 { if int64(first) \u0026gt; now { if verifyTimers { verifyTimerHeap(pp) } return } // We are going to clear all timerModifiedEarlier timers. atomic.Store64(\u0026amp;pp.timerModifiedEarliest, 0) } var moved []*timer loop: for i := 0; i \u0026lt; len(pp.timers); i++ { t := pp.timers[i] if t.pp.ptr() != pp { throw(\u0026#34;adjusttimers: bad p\u0026#34;) } switch s := atomic.Load(\u0026amp;t.status); s { case timerDeleted: if atomic.Cas(\u0026amp;t.status, s, timerRemoving) { dodeltimer(pp, i) if !atomic.Cas(\u0026amp;t.status, timerRemoving, timerRemoved) { badTimer() } atomic.Xadd(\u0026amp;pp.deletedTimers, -1) // Look at this heap position again. i-- } case timerModifiedEarlier, timerModifiedLater: if atomic.Cas(\u0026amp;t.status, s, timerMoving) { // Now we can change the when field. t.when = t.nextwhen // Take t off the heap, and hold onto it. // We don\u0026#39;t add it back yet because the // heap manipulation could cause our // loop to skip some other timer. dodeltimer(pp, i) moved = append(moved, t) if s == timerModifiedEarlier { if n := atomic.Xadd(\u0026amp;pp.adjustTimers, -1); int32(n) \u0026lt;= 0 { break loop } } // Look at this heap position again. i-- } case timerNoStatus, timerRunning, timerRemoving, timerRemoved, timerMoving: badTimer() case timerWaiting: // OK, nothing to do. case timerModifying: // Check again after modification is complete. osyield() i-- default: badTimer() } } if len(moved) \u0026gt; 0 { addAdjustedTimers(pp, moved) } if verifyTimers { verifyTimerHeap(pp) } } 运行timer // runtimer 检查timers四叉堆顶部的timer // runtimer examines the first timer in timers. If it is ready based on now, // it runs the timer and removes or updates it. // Returns 0 if it ran a timer, -1 if there are no more timers, or the time // when the first timer should run. // The caller must have locked the timers for pp. // If a timer is run, this will temporarily unlock the timers. //go:systemstack func runtimer(pp *p, now int64) int64 { for { t := pp.timers[0] if t.pp.ptr() != pp { throw(\u0026#34;runtimer: bad p\u0026#34;) } switch s := atomic.Load(\u0026amp;t.status); s { case timerWaiting: if t.when \u0026gt; now { // 还没到时间执行 // Not ready to run. return t.when } // 该执行这个timer了 if !atomic.Cas(\u0026amp;t.status, s, timerRunning) { continue } // Note that runOneTimer may temporarily unlock // pp.timersLock. runOneTimer(pp, t, now) return 0 case timerDeleted: // 删除已经执行了的timer if !atomic.Cas(\u0026amp;t.status, s, timerRemoving) { continue } dodeltimer0(pp) if !atomic.Cas(\u0026amp;t.status, timerRemoving, timerRemoved) { badTimer() } atomic.Xadd(\u0026amp;pp.deletedTimers, -1) if len(pp.timers) == 0 { return -1 } case timerModifiedEarlier, timerModifiedLater: // 调整timerModifiedEarlier, timerModifiedLater timer的时间 if !atomic.Cas(\u0026amp;t.status, s, timerMoving) { continue } t.when = t.nextwhen dodeltimer0(pp) doaddtimer(pp, t) if s == timerModifiedEarlier { atomic.Xadd(\u0026amp;pp.adjustTimers, -1) } if !atomic.Cas(\u0026amp;t.status, timerMoving, timerWaiting) { badTimer() } case timerModifying: // Wait for modification to complete. osyield() // 等到其他操作结束 case timerNoStatus, timerRemoved: // Should not see a new or inactive timer on the heap. badTimer() case timerRunning, timerRemoving, timerMoving: // These should only be set when timers are locked, // and we didn\u0026#39;t do it. badTimer() default: badTimer() } } } 触发timer 前面介绍的都是将 timer加入到 堆中，从堆中删除这些，那么timer时间到了，是怎么触发的呢？\n触发timer一定会执行前面所说的runtimer方法，可以发现runtimer是在checkTimers方法中被调用的\n// checkTimers runs any timers for the P that are ready. // If now is not 0 it is the current time. // It returns the current time or 0 if it is not known, // and the time when the next timer should run or 0 if there is no next timer, // and reports whether it ran any timers. // If the time when the next timer should run is not 0, // it is always larger than the returned time. // We pass now in and out to avoid extra calls of nanotime. //go:yeswritebarrierrec func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { // If it\u0026#39;s not yet time for the first timer, or the first adjusted // timer, then there is nothing to do. next := int64(atomic.Load64(\u0026amp;pp.timer0When)) nextAdj := int64(atomic.Load64(\u0026amp;pp.timerModifiedEarliest)) if next == 0 || (nextAdj != 0 \u0026amp;\u0026amp; nextAdj \u0026lt; next) { next = nextAdj } if next == 0 { // 没有timer需要执行和调整 // No timers to run or adjust. return now, 0, false } if now == 0 { now = nanotime() } if now \u0026lt; next { // 最快的 timer还没到 执行的时间 // Next timer is not ready to run, but keep going // if we would clear deleted timers. // This corresponds to the condition below where // we decide whether to call clearDeletedTimers. if pp != getg().m.p.ptr() || int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026lt;= int(atomic.Load(\u0026amp;pp.numTimers)/4) { return now, next, false } } lock(\u0026amp;pp.timersLock) if len(pp.timers) \u0026gt; 0 { adjusttimers(pp, now) // 删除已经执行的timer，调整timerModifiedEarlier 和 timerModifiedLater 的计时器的时间 for len(pp.timers) \u0026gt; 0 { // 执行所有到期的timer // Note that runtimer may temporarily unlock // pp.timersLock. if tw := runtimer(pp, now); tw != 0 { if tw \u0026gt; 0 { pollUntil = tw } break } ran = true } } // If this is the local P, and there are a lot of deleted timers, // clear them out. We only do this for the local P to reduce // lock contention on timersLock. // 当前 Goroutine 的处理器和传入的处理器相同,并且处理器中删除的计时器是堆中计时器的 1/4 以上， if pp == getg().m.p.ptr() \u0026amp;\u0026amp; int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026gt; len(pp.timers)/4 { clearDeletedTimers(pp) } unlock(\u0026amp;pp.timersLock) return now, pollUntil, ran } 而checkTimers在findrunnable和schedule中被调用，而这2个方法都是runtime调度会执行的方法（PS：runtime调度也是一个很重要的知识点，有兴趣的可以自行了解）\n除了runtime调度时会执行timer外，系统监控sysmon也会执行timer，其实这里我没有理解，所以这里直接用draveness大佬文章中的说明\n系统监控函数 runtime.sysmon 也可能会触发函数的计时器，下面的代码片段中省略了大量与计时器无关的代码：\nfunc sysmon() { ... for { ... now := nanotime() next, _ := timeSleepUntil() ... lastpoll := int64(atomic.Load64(\u0026amp;sched.lastpoll)) if netpollinited() \u0026amp;\u0026amp; lastpoll != 0 \u0026amp;\u0026amp; lastpoll+10*1000*1000 \u0026lt; now { atomic.Cas64(\u0026amp;sched.lastpoll, uint64(lastpoll), uint64(now)) list := netpoll(0) if !list.empty() { incidlelocked(-1) injectglist(\u0026amp;list) incidlelocked(1) } } if next \u0026lt; now { startm(nil, false) } ... } 调用 [runtime.timeSleepUntil](https://draveness.me/golang/tree/runtime.timeSleepUntil) 获取计时器的到期时间以及持有该计时器的堆； 如果超过 10ms 的时间没有轮询，调用 [runtime.netpoll](https://draveness.me/golang/tree/runtime.netpoll) 轮询网络； 如果当前有应该运行的计时器没有执行，可能存在无法被抢占的处理器，这时我们应该启动新的线程处理计时器； 在上述过程中 [runtime.timeSleepUntil](https://draveness.me/golang/tree/runtime.timeSleepUntil) 会遍历运行时的全部处理器并查找下一个需要执行的计时器。\n遗留问题 最后是我还存在的问题\nsysmon中为什么会触发timer\naddtimer方法中调用了wakeNetPoller(when)方法唤醒netpoll，但是netpoll()方法中对netpollBreakRd的处理并没有发现与timer有啥关系\n// netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // delay \u0026lt; 0: blocks indefinitely // delay == 0: does not block, just polls // delay \u0026gt; 0: block for up to that many nanoseconds // delay \u0026lt; 0 无限block等待 // delay == 0 不会block // delay block 最多delay时间 // runtime.netpoll 返回的 Goroutine 列表都会被 runtime.injectglist 注入到处理器或者全局的运行队列上。 // 因为系统监控 Goroutine 直接运行在线程上，所以它获取的 Goroutine 列表会直接加入全局的运行队列， // 其他 Goroutine 获取的列表都会加入 Goroutine 所在处理器的运行队列上。 func netpoll(delay int64) gList { if epfd == -1 { // 没有epfd 相当于netpoll没有初始化 return gList{} } var waitms int32 if delay \u0026lt; 0 { waitms = -1 } else if delay == 0 { waitms = 0 } else if delay \u0026lt; 1e6 { waitms = 1 } else if delay \u0026lt; 1e15 { waitms = int32(delay / 1e6) } else { // An arbitrary cap on how long to wait for a timer. // 1e9 ms == ~11.5 days. waitms = 1e9 } var events [128]epollevent retry: // 等待文件描述符转换成可读或者可写 n := epollwait(epfd, \u0026amp;events[0], int32(len(events)), waitms) if n \u0026lt; 0 { // 如果返回了负值，可能会返回空的 Goroutine 列表或者重新调用 epollwait 陷入等待： if n != -_EINTR { println(\u0026#34;runtime: epollwait on fd\u0026#34;, epfd, \u0026#34;failed with\u0026#34;, -n) throw(\u0026#34;runtime: netpoll failed\u0026#34;) } // If a timed sleep was interrupted, just return to // recalculate how long we should sleep now. if waitms \u0026gt; 0 { return gList{} } goto retry } // 当 epollwait 系统调用返回的值大于 0 时，意味着被监控的文件描述符出现了待处理的事件 var toRun gList for i := int32(0); i \u0026lt; n; i++ { ev := \u0026amp;events[i] if ev.events == 0 { continue } // runtime.netpollBreak 触发的事件 if *(**uintptr)(unsafe.Pointer(\u0026amp;ev.data)) == \u0026amp;netpollBreakRd { if ev.events != _EPOLLIN { println(\u0026#34;runtime: netpoll: break fd ready for\u0026#34;, ev.events) throw(\u0026#34;runtime: netpoll: break fd ready for something unexpected\u0026#34;) } if delay != 0 { // netpollBreak could be picked up by a // nonblocking poll. Only read the byte // if blocking. var tmp [16]byte read(int32(netpollBreakRd), noescape(unsafe.Pointer(\u0026amp;tmp[0])), int32(len(tmp))) atomic.Store(\u0026amp;netpollWakeSig, 0) } continue } // 另一种是其他文件描述符的正常读写事件 var mode int32 if ev.events\u0026amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 { mode += \u0026#39;r\u0026#39; } if ev.events\u0026amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 { mode += \u0026#39;w\u0026#39; } if mode != 0 { pd := *(**pollDesc)(unsafe.Pointer(\u0026amp;ev.data)) pd.everr = false if ev.events == _EPOLLERR { pd.everr = true } netpollready(\u0026amp;toRun, pd, mode) } } return toRun } draveness大佬文章的评论中也有人提到这个疑问，但是还是未能理解，我也加入 了讨论，期待后续的解答\n参考资料 6.3 计时器 Go中定时器实现原理及源码解析 难以驾驭的 Go timer，一文带你参透计时器的奥秘 go1.14基于netpoll优化timer定时器实现原理 https://www.youtube.com/watch?v=XJx0eTP-y9I ","permalink":"https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","summary":"\u003cp\u003e根据\u003ca href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/\"\u003e6.3 计时器\u003c/a\u003e中的描述，Golang Timer的设计经历了如下阶段：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGo 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；\u003c/li\u003e\n\u003cli\u003eGo 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；\u003c/li\u003e\n\u003cli\u003eGo 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGo 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题\u003c/li\u003e\n\u003cli\u003eGo 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO  为什么会发生P和M的绑定和解绑)\u003c/li\u003e\n\u003cli\u003eGo 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我使用的是Go 1.16的版本进行分析\u003c/p\u003e","title":"Timer源码阅读"},{"content":"线程池是什么？ 线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。\n线程池的作用 在面向对象的编程过程中，创建对象和销毁对象是非常消耗时间和资源的。因此想要最小化这种消耗的一种思想就是『池化资源』。线程池就是这样的一种思想。我们通过重用线程池中的资源来减少创建和销毁线程所需要耗费的时间和资源。\n线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用；另一个作用是可根据系统情况调整执行的线程数量，防止消耗过多内存。另外，通过线程池，能有效的控制线程的最大并发数，提高系统资源利用率，同时避免过多的资源竞争，避免堵塞。\n线程池的优点总结如下几个方面：\n线程复用 控制最大并发数 管理线程 线程池的组成 一般的线程池主要分为以下4个组成部分：\n线程池管理器：用于创建并管理线程池 工作线程：线程池中的线程 任务接口：每个任务必须实现的接口，用于工作线程调度其运行 任务队列：用于存放待处理的任务，提供一种缓冲机制 线程池的常见应用场景 许多服务器应用常常需要处理大量而短小的请求（例如，Web 服务器，数据库服务器等等），通常它们收到的请求数量很大，一个简单的模型是，当服务器收到来自远程的请求时，为每一个请求开启一个线程，在请求完毕之后再对线程进行销毁。这样处理带来的问题是，创建和销毁线程所消耗的时间往往比任务本身所需消耗的资源要大得多。那么应该怎么办呢？\n线程池为线程生命周期开销问题和资源不足问题提供了解决方案。我们可以通过线程池做到线程复用，不需要频繁的创建和销毁线程，让线程池中的线程一直存在于线程池中，然后线程从任务队列中取得任务来执行。而且这样做的另一个好处有，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。\nJava线程池的简介 Java中提供了实现线程池的框架Executor，并且提供了许多种类的线程池，接下来的文章中将会做详细介绍。\nJava线程池框架 Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask这几个类。\nExecutor：所有线程池的接口，只有一个方法 Executors：Executor 的工厂类，提供了创建各种不同线程池的方法，返回的线程池都实现了ExecutorService 接口 ThreadPoolExecutor：线程池的具体实现类，一般所有的线程池都是基于这个类实现的 其中ThreadPoolExecutor的构造方法如下：\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } 其中：\ncorePoolSize：线程池的核心线程数 maximumPoolSize：线程池中允许的最大线程数 keepAliveTime：空闲线程结束的超时时间 unit：是一个枚举，它表示的是 keepAliveTime 的单位 workQueue：工作队列，用于任务的存放 Java线程池的工作过程 Java线程池的工作过程如下：\n线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 当调用 execute() 方法添加一个任务时，线程池会做如下判断： 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。 当一个线程完成任务时，它会从队列中取下一个任务来执行。 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 常见的Java线程池 生成线程池使用的是Executors的工厂方法，以下是常见的 Java 线程池：\nSingleThreadExecutor SingleThreadExecutor是单个线程的线程池，即线程池中每次只有一个线程在运行，单线程串行执行任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\npublic static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } FixedThreadPool FixedThreadPool是固定数量的线程池，只有核心线程，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列，直到前面的任务完成才继续执行。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\npublic static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } CachedThreadPool CachedThreadPool是可缓存线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。其中，SynchronousQueue是一个是缓冲区为1的阻塞队列。\npublic static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue\u0026lt;Runnable\u0026gt;()); } ScheduledThreadPool ScheduledThreadPool是核心线程池固定，大小无限制的线程池，支持定时和周期性的执行线程。创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。\npublic ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } Java 线程池的创建和使用 我们可以通过Executors的工厂方法来创建一个线程池。但是我们该如何让线程池执行任务呢？\n线程池最常用的提交任务的方法有两种：\nexecute： ExecutorService.execute(Runnable runable)； submit： FutureTask task = ExecutorService.submit(Runnable runnable); FutureTask\u0026lt;T\u0026gt; task = ExecutorService.submit(Runnable runnable,T Result); FutureTask\u0026lt;T\u0026gt; task = ExecutorService.submit(Callable\u0026lt;T\u0026gt; callable); 可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到结果。submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。\n下面的示例代码演示了如何创建一个线程池，并且使用它管理线程：\npublic class MyThread extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName() + \u0026#34; is running.\u0026#34;); } } public class TestSingleThreadExecutor { public static void main(String[] args) { //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); //创建实现了Runnable接口对象 Thread tt1 = new MyThread(); Thread tt2 = new MyThread(); Thread tt3 = new MyThread(); Thread tt4 = new MyThread(); Thread tt5 = new MyThread(); //将线程放入池中并执行 pool.execute(tt1); pool.execute(tt2); pool.execute(tt3); pool.execute(tt4); pool.execute(tt5); //关闭 pool.shutdown(); } } 运行结果：\npool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. Java线程池原理 这篇文章会分别从这三个方面，结合具体的代码实现来剖析 Java 线程池的原理以及它的具体实现。\n线程复用 我们知道线程池的一个作用是创建和销毁线程的次数，每个工作线程可以多次使用。这个功能就是线程复用。想要了解 Java 线程池是如何进行线程复用的，我们首先需要了解线程的生命周期。\n线程生命周期 下图描述了线程完整的生命周期：\n在一个线程完整的生命周期中，它可能经历五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、终止（Zombie）。\n在 Java中，Thread 通过new来新建一个线程，这个过程是是初始化一些线程信息，如线程名、id、线程所属group等，可以认为只是个普通的对象。调用Thread的start()后Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true，之后如果再次调用start()方法就会有异常。\n处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于 JVM 里线程调度器的调度。当线程获取CPU后，run()方法会被调用。不要自己去调用Thread的run()方法。之后根据CPU的调度，线程就会在就绪—运行—阻塞间切换，直到run()方法结束或其他方式停止线程，进入终止状态。\n因此，如果要实现线程的复用，我们必须要保证线程池中的线程保持存活状态（就绪、运行、阻塞）。接下来，我们就来看看ThreadPoolExecutor是如何实现线程复用的。\nWorker 类 ThreadPoolExecutor主要是通过一个类来控制线程复用的：Worker 类。\n我们来看一下简化后的 Worker 类代码：\nprivate final class Worker implements Runnable { final Thread thread; Runnable firstTask; Worker(Runnable firstTask) { this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } public void run() { runWorker(this); } final void runWorker(Worker w) { Runnable task = w.firstTask; w.firstTask = null; while (task != null || (task = getTask()) != null){ task.run(); } } …… } 从代码中，我们可以看到 Worker 实现了 Runnable 接口，并且它还有一个 Thread成员变量 thread，这个 thread 就是要开启运行的线程。我们看到 Worker 的构造方法中传递了一个 Runnable 参数，同时它把自己作为参数传入 newThread()，这样的话，当 Thread 的start()方法得到调用时，执行的其实是 Worker 的run()方法，即runWorker()方法。\nrunWorker()方法之中有一个 while 循环，使用 getTask()来获取任务，并执行。接下来，我们将会看到getTask()是如何获取到 Runnable 对象的。\ngetTask() 我们来看一下简化后的getTask()代码：\nprivate Runnable getTask() { if(一些特殊情况) { return null; } Runnable r = workQueue.take(); return r; } 我们可以看到任务是从 workQueue中获取的，这个 workQueue 就是我们初始化 ThreadPoolExecutor 时存放任务的 BlockingQueue队列，这个队列里的存放的都是将要执行的 Runnable任务。因为 BlockingQueue 是个阻塞队列，BlockingQueue.take()返回的是空，则进入等待状态直到 BlockingQueue 有新的对象被加入时唤醒阻塞的线程。所以一般情况下，Thread的run()方法不会结束，而是不断执行workQueue里的Runnable任务，这就达到了线程复用的目的了。\n控制最大并发数 我们现在已经知道了 Java 线程池是如何做到线程复用的了，但是Runnable 是什么时候被放入 workQueue 队列中的呢，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？从上面的分析中我们可以看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？它又是如何做到控制最大并发数的呢？\nexecute() 通过查看 execute()就能解答上述的一些问题，同样是简化后的代码：\npublic void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); // 当前线程数 \u0026lt; corePoolSize if (workerCountOf(c) \u0026lt; corePoolSize) { // 直接启动新的线程。 if (addWorker(command, true)) return; c = ctl.get(); } // 活动线程数 \u0026gt;= corePoolSize // runState为RUNNING \u0026amp;\u0026amp; 队列未满 if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { int recheck = ctl.get(); // 再次检验是否为RUNNING状态 // 非RUNNING状态 则从workQueue中移除任务并拒绝 if (!isRunning(recheck) \u0026amp;\u0026amp; remove(command)) reject(command); // 采用线程池指定的策略拒绝任务 // 两种情况： // 1.非RUNNING状态拒绝新的任务 // 2.队列满了启动新的线程失败（workCount \u0026gt; maximumPoolSize） } else if (!addWorker(command, false)) reject(command); } addWorker() 我们再来看一下addWorker()的简化代码：\nprivate boolean addWorker(Runnable firstTask, boolean core) { int wc = workerCountOf(c); if (wc \u0026gt;= (core ? corePoolSize : maximumPoolSize)) { return false; } w = new Worker(firstTask); final Thread t = w.thread; t.start(); } 根据上面的代码，线程池工作过程中是如何添加任务的就很清晰了：\n如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException 如果通过addWorker()成功创建新的线程，则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以可以根据corePoolSize和maximumPoolSize来控制最大并发数。\n过程如下图所示：\n管理线程 上边的文章已经讲了，通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程，而线程的管理过程已经穿插在其中了，也很好理解。\n在 ThreadPoolExecutor 有个AtomicInteger变量 ctl，这一个变量保存了两个内容：\n所有线程的数量 每个线程所处的状态 其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); //得到线程的状态 private static int runStateOf(int c) { return c \u0026amp; ~CAPACITY; } //得到Worker的的数量 private static int workerCountOf(int c) { return c \u0026amp; CAPACITY; } // 判断线程是否在运行 private static boolean isRunning(int c) { return c \u0026lt; SHUTDOWN; } 这里主要通过shutdown和shutdownNow()来分析线程池的关闭过程。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：\nRUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务； SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务； STOP状态：不再接受新任务，不处理队列中的任务 shutdown()这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务人会被执行；shutdownNow()方法将runState置为STOP。和shutdown()方法的区别是，这个方法会终止所有的线程，所以队列中的任务也不会被执行了。\nJava线程池框架源码分析 前面的文章中已经给出了Java线程池框架中几个重要类的关系图:\n现在我们基于这张图来逐步分析。\nExecutor public interface Executor { void execute(Runnable command); } 这个接口表示向线程池中提交一个任务。\nExecutorService public interface ExecutorService extends Executor { void shutdown(); List\u0026lt;Runnable\u0026gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Callable\u0026lt;T\u0026gt; task); \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Runnable task, T result); Future\u0026lt;?\u0026gt; submit(Runnable task); \u0026lt;T\u0026gt; List\u0026lt;Future\u0026lt;T\u0026gt;\u0026gt; invokeAll(Collection\u0026lt;? extends Callable\u0026lt;T\u0026gt;\u0026gt; tasks) throws InterruptedException; \u0026lt;T\u0026gt; List\u0026lt;Future\u0026lt;T\u0026gt;\u0026gt; invokeAll(Collection\u0026lt;? extends Callable\u0026lt;T\u0026gt;\u0026gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; \u0026lt;T\u0026gt; T invokeAny(Collection\u0026lt;? extends Callable\u0026lt;T\u0026gt;\u0026gt; tasks) throws InterruptedException, ExecutionException; \u0026lt;T\u0026gt; T invokeAny(Collection\u0026lt;? extends Callable\u0026lt;T\u0026gt;\u0026gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } 可以看到 ExecutorService 扩展了 Executor 接口，在 Executor 基础上提供了更多的提交任务的方式和管理线程池的一些方法。\nAbstractExecutorService public abstract class AbstractExecutorService implements ExecutorService { } ThreadPoolExecutor ThreadPoolExecutor 是线程池框架的关键类. 首先来看一下 ThreadPoolExecutor 中几个重要的属性.\npublic class ThreadPoolExecutor extends AbstractExecutorService { /** * 整个线程池的状态控制类 ctl, 是一个 AtomicInteger ，封装了下面2个部分: * workerCount 表示有效的线程数 * runState 表示线程池当前状态，是running, shutdown还是其他状态 * * runState表示了线程池的整个整个生命周期，可以取以下值: * RUNNING: 接受新的task，处理队列中的task * SHUTDOWN: 不接受新的 task 但会处理队列中的 task * STOP: 不接受新的 task, 不处理队列中的 task, 中断正在执行的 task * TIDYING: 所有 task 执行结束, workerCount 是 0, 线程过渡到TIDYING会调用 terminated()钩子方法 * TERMINATED: terminated()执行完成 * * 状态转换关系: * * RUNNING -\u0026gt; SHUTDOWN(调用shutdown()) * On invocation of shutdown(), perhaps implicitly in finalize() * (RUNNING or SHUTDOWN) -\u0026gt; STOP(调用shutdownNow()) * On invocation of shutdownNow() * SHUTDOWN -\u0026gt; TIDYING(queue和pool均empty) * When both queue and pool are empty * TIDYING -\u0026gt; TERMINATED(调用terminated()) * When the terminated() hook method has completed */ private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); /** * task 的队列 */ private final BlockingQueue\u0026lt;Runnable\u0026gt; workQueue; /** * worker 线程的 Set, 只有持有 mainlock 时才能访问 */ private final ReentrantLock mainLock = new ReentrantLock(); private final HashSet\u0026lt;Worker\u0026gt; workers = new HashSet\u0026lt;Worker\u0026gt;(); private final Condition termination = mainLock.newCondition(); private int largestPoolSize; private long completedTaskCount; private volatile ThreadFactory threadFactory; private volatile RejectedExecutionHandler handler; /** * idle 线程waiting for work的超时时间 */ private volatile long keepAliveTime; /** * 如果是 false,core threads将会保持 alive 即使处于 idel 状态 * 如果是 true,core threads会keepAliveTime作为超时时间 wait for work */ private volatile boolean allowCoreThreadTimeOut; private volatile int corePoolSize; private volatile int maximumPoolSize; private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); } workerCount, runState 使用一个 AtomicInteger 进行了封装, runState用 int 的高3位标书,低位表示 workerCount, 所以我们能看到 ThreadPoolExecutor 中和 ctl 相关的常量和解析方法.\nprivate static final int COUNT_BITS = Integer.SIZE - 3; private static final int CAPACITY = (1 \u0026lt;\u0026lt; COUNT_BITS) - 1; // runState is stored in the high-order bits private static final int RUNNING = -1 \u0026lt;\u0026lt; COUNT_BITS; private static final int SHUTDOWN = 0 \u0026lt;\u0026lt; COUNT_BITS; private static final int STOP = 1 \u0026lt;\u0026lt; COUNT_BITS; private static final int TIDYING = 2 \u0026lt;\u0026lt; COUNT_BITS; private static final int TERMINATED = 3 \u0026lt;\u0026lt; COUNT_BITS; // Packing and unpacking ctl private static int runStateOf(int c) { return c \u0026amp; ~CAPACITY; } private static int workerCountOf(int c) { return c \u0026amp; CAPACITY; } private static int ctlOf(int rs, int wc) { return rs | wc; } ThreadPoolExecutor 最主要的构造函数,设置上面说的重要属性.\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize \u0026lt; 0 || maximumPoolSize \u0026lt;= 0 || maximumPoolSize \u0026lt; corePoolSize || keepAliveTime \u0026lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 现在来看一下 execute() 方法, execute()方法有3个处理步骤:\n线程数小于 corePoolSize 时,则试图创建一个新的 worker 线程 如果上面一步失败了，则试图将任务添加到阻塞队列中，并且要再一次判断需要不需要回滚队列，或者说创建线程 如果上面两步都失败了，则会试图强行创建一个线程来执行这个任务，如果还是失败，扔掉这个任务 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); // 1.判断有效线程数是否小于核心线程数 if (workerCountOf(c) \u0026lt; corePoolSize) { //创建新线程 if (addWorker(command, true)) return; c = ctl.get(); } // 2.分开来看，首先判断当前的池子是否是处于 running 状态 // 因为只有 running 状态才可以接收新任务 // 接下来判断能否成功添加到队列中，如果队列满了或者其他情况则会跳到下一步 if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { int recheck = ctl.get(); // 再次检查池子的状态，如果进入了非 running 状态，回滚队列，扔掉这个任务 if (! isRunning(recheck) \u0026amp;\u0026amp; remove(command)) reject(command); //如果处于 running 状态则检查当前的有效线程，如果没有则创建一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 3.前两步失败了，就强行创建线程，成功会返回true，如果失败扔掉这个任务 else if (!addWorker(command, false)) reject(command); } 解释一下第二步，为什么要recheck\n当这个任务被添加到了阻塞队列前，池子处于 RUNNING 状态，但如果在添加到队列成功后，池子进入了 SHUTDOWN 状态或者其他状态，这时候是不应该再接收新的任务的，所以需要把这个任务从队列中移除，并且 reject\n同样，在没有添加到队列前，可能有一个有效线程，但添加完任务后，这个线程闲置超时或者因为异常被干掉了，这时候需要创建一个新的线程来执行任务\n为了更直观的理解一个任务的执行过程，可以参考下面这张图\naddWorker() 前一步把 execute 的流程捋了一遍，里面多次出现了 addWorker() 方法，前文说到这是个创建线程的方法，来看看 addWorker 做了些什么，这个方法代码比较长，我们拆开来一点一点看.\n第一部分 — 判断各种基础异常 private boolean addWorker(Runnable firstTask, boolean core) { retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. // 检查线程池状态，队列状态，以及 firstask ，拆开来看 // 这段代码看起来异常的蛋疼,转换一下逻辑即 // rs\u0026gt;= SHUTDOWN \u0026amp;\u0026amp; (rs != SHUTDOWN || firstTask != null ||workQueue.isEmpty()) // 总结起来就是 当前处于非 Running 状态,并且这三种情况 // 1. 不是处于 SHUTDOWN 状态，不能再创建线程 // 2. 有新的任务 (因为不能再接收新的任务) // 3. 阻塞队列中已经没有任务 (不需要再创建线程) if (rs \u0026gt;= SHUTDOWN \u0026amp;\u0026amp; ! (rs == SHUTDOWN \u0026amp;\u0026amp; firstTask == null \u0026amp;\u0026amp; ! workQueue.isEmpty())) return false; for (;;) { //当前有效线程数目 int wc = workerCountOf(c); // 根据传入的参数确定以核心线程数还是最大线程数作为判断条件 if (wc \u0026gt;= CAPACITY || wc \u0026gt;= (core ? corePoolSize : maximumPoolSize)) // 大于容量 或者指定的线程数，不允许创建 return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } } 第二部分 — 试图创建线程 创建一个Worker\nboolean workerStarted = false; //标记 worker 开启状态 boolean workerAdded = false; //标记 worker 添加状态 Worker w = null; try { w = new Worker(firstTask); //将这个任务作为 worker 的第一个任务传入 final Thread t = w.thread; //通过 worker 获取到一个线程 if (t != null) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); // running状态，或者 shutdown 状态但是没有新的任务 if (rs \u0026lt; SHUTDOWN || (rs == SHUTDOWN \u0026amp;\u0026amp; firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将这个 worker 添加到线程池中 workers.add(w); int s = workers.size(); if (s \u0026gt; largestPoolSize) largestPoolSize = s; // 标记worker添加成功 workerAdded = true; } } finally { mainLock.unlock(); } // 如果 worker 创建成功，开启线程 if (workerAdded) { t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; 上面代码从逻辑层面来看不算难懂，到这里一个任务到达后，ThreadPoolExecutor 的处理就结束了，那么任务又是怎么被添加到阻塞队列中，线程是如何从队列中取出任务，上文中的 Worker 又是什么东西？\n一个一个来，先来看看 Worker 到底是什么.\nWorker Worker 是 ThreadPoolExecutor 的一个内部类，实现了 Runnable 接口，继承自 AbstractQueuedSynchronizer,这又是个什么鬼？？? 这个就是经常见到的 AQS 的全称,这个暂时还没有研究.~~~~\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable { final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; } 简单来说，Worker实现了 lock 和 unLock 方法来标示当前线程的状态是否为闲置\n// Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. public void lock() { acquire(1); } public boolean tryLock() { return tryAcquire(1); } public void unlock() { release(1); } public boolean isLocked() { return isHeldExclusively(); } 上一节创建线程成功后调用 t.start() 而这个线程又是 Worker 的成员变量\nWorker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } 可以看到这里将 Worker 作为 Runnable 参数创建了一个新的线程，我们知道 Thread 接收一个 Runnable 对象后 start 运行的是 Runnable 的 run 方法，Worker 的 run 方法调用了 runWorker ,这个方法里面就是取出任务执行的逻辑\npublic void run() { runWorker(this); } final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; // 获取到 worker 的第一个任务 w.firstTask = null; w.unlock(); // 标记为闲置，还没有开始任务 允许打断 boolean completedAbruptly = true; // 异常退出标记 try { // 循环取出任务，如果第一个任务不为空，或者从队列中拿到了任务 // 只要这两个条件满足，会一直循环，直到没有任务，正常退出，或者异常退出 while (task != null || (task = getTask()) != null) { w.lock();// 该线程标记为非闲置 // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt // 翻译注释：1.如果线程池STOPPING状态，需要中断线程 // 2.Thread.interrupted()是一个native方法，返回当前线程是否有被等待中断的请求 // 3.第二个条件成立时，检查线程池状态，如果为STOP，并且没有被中断，则中断线程 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() \u0026amp;\u0026amp; runStateAtLeast(ctl.get(), STOP))) \u0026amp;\u0026amp; !wt.isInterrupted()) wt.interrupt(); // 执行任务 try { beforeExecute(wt, task);// 执行前 Throwable thrown = null; try { task.run(); // 执行任务 } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); // 执行结束 } } finally { task = null; // 将 worker 的任务置空 w.completedTasks++; w.unlock(); // 释放锁，进入闲置状态 } }// 循环结束 completedAbruptly = false; // 标记为正常退出 } finally { // 干掉 worker processWorkerExit(w, completedAbruptly); } } 这里弄清楚了一件事情，进入循环准备执行任务时，worker 加锁标记为非闲置，任务执行完毕或者出现异常，worker 释放锁，进入闲置状态。\n也就是当一个 worker 执行任务前或者执行完任务，到取出下一个任务期间，都是闲置状态可以被打断\n上面取出任务调用了 getTask() ，诶～为什么有一个死循环，别着急，慢慢看来。上面的代码可以知道如果 getTask 返回任务则执行，如果返回为 null 则 worker 需要被回收\nprivate Runnable getTask() { // 标记取任务是否超时 boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. // 如果线程池状态为 STOP 或者 SHUTDOWN 并且队列已经为空，回收 wroker if (rs \u0026gt;= SHUTDOWN \u0026amp;\u0026amp; (rs \u0026gt;= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } //获取当前有效线程数 int wc = workerCountOf(c); // Are workers subject to culling? // timed 用来标记当前的 worker 是否设置超时时间， // 还记得获取线程池的时候 可以设置核心线程超时时间 //1.允许核心线程超时回收(即所有线程) 2.当前有效线程超过核心线程数(需要回收) // 如果timed == false 则该worker不会被回收，如果没有取到任务 会一直阻塞 boolean timed = allowCoreThreadTimeOut || wc \u0026gt; corePoolSize; // 回收线程条件 // 1. 有效线程数已经大于了线程池的最大线程数或者设置了超时回收并且已经超时 // 2. 有效线程数大于1或者队列任务已经为空 // 只有当上面1和2 同时满足时 则试图回收线程 if ((wc \u0026gt; maximumPoolSize || (timed \u0026amp;\u0026amp; timedOut)) \u0026amp;\u0026amp; (wc \u0026gt; 1 || workQueue.isEmpty())) { // 如果减少workercount成功 直接回收 if (compareAndDecrementWorkerCount(c)) return null; // 否则重走循环，从第一个判断条件处回收 continue; } // 取任务 try { // 根据是否设置超时回收来选择不同的取任务的方式 // poll 方法取任务会有超时时间，超过时间则返回null // take 方法没有超时时间，阻塞式方法 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); // 如果任务不为空返回任务 if (r != null) return r; // 否则标记超时 进入下一次循环等待回收 timedOut = true; } catch (InterruptedException retry) { // 如果出现异常，试图重试 timedOut = false; } } } getTask() 方法逻辑也捋得差不多了，这里又出现了两个新的方法，workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 和 workQueue.take() ，这两个都是阻塞队列的方法，来看看它们又各自是怎么实现的\nLinkedBlockingQueue — 阻塞队列 ThreadPoolExecutor 使用的是链表结构的阻塞队列，实现了 BlockingQueue 接口，而 BlockingQueue 则是继承自 Queue 接口，再上层就是 Collection 接口。\n因为本篇笔记主要是分析 ThreadPoolExecutor 的原理，所以不会详细介绍 LinkedBlockingQueue 中的其它代码，主要介绍这里所用的方法，首先来看一下上文所提到的 take()\npublic E take() throws InterruptedException { E x; // 任务 int c = -1; // 取出任务后的剩余任务数量 final AtomicInteger count = this.count; // 当前任务数量 final ReentrantLock takeLock = this.takeLock; // 加锁防止并发 takeLock.lockInterruptibly(); try { // 如果队列数量为空，则一直循环，阻塞线程 while (count.get() == 0) { notEmpty.await(); } // 取出任务 x = dequeue(); // 任务数量减一 c = count.getAndDecrement(); if (c \u0026gt; 1) notEmpty.signal();// 标记队列非空 } finally { takeLock.unlock(); // 释放锁 } if (c == capacity) signalNotFull();//标记队列已满 return x;// 返回任务 } 上面的代码可以知道 take 方法会一直阻塞直到队列有新的任务为止\n接下来是 poll 方法，可以看到几乎与 take 方法相同，唯一的区别是在阻塞的循环代码块里面加了时间判断，如果超时则直接返回为空，不会一直阻塞下去\npublic E poll(long timeout, TimeUnit unit) throws InterruptedException { E x = null; // 存放的任务 int c = -1; long nanos = unit.toNanos(timeout); // 超时时间 final AtomicInteger count = this.count; // 队列中的数量 final ReentrantLock takeLock = this.takeLock; // 加锁防止并发 takeLock.lockInterruptibly(); try { // 如果队列为空，则不断的循环 while (count.get() == 0) { // 如果当倒计时小于0 即超时时间到 则返回空 if (nanos \u0026lt;= 0) return null; // 让线程等待 nanos = notEmpty.awaitNanos(nanos); } x = dequeue(); // 取出一个任务 c = count.getAndDecrement(); // 取出后的队列数量 if (c \u0026gt; 1) notEmpty.signal(); // 标记非空 } finally { takeLock.unlock(); // 释放锁 } if (c == capacity) signalNotFull(); // 标记队列已满 return x; // 返回任务 } 线程池的回收及终止 前一节分析了任务的执行流程及原理，也留下了一个问题，worker 是如何被回收的呢？线程池该如何管理呢？回到上一节的 runWorker() 方法中，还记得最后调用了一个方法\nprocessWorkerExit(w, completedAbruptly); 这个方法传入了两个参数，第一个是当前的 Woker ,第二个是标记异常退出的标识\n首先判断是否为异常退出，如果是异常退出的话需要手动调整线程数量，如果是正常回收的，getTask 方法里面已经手动调整过了，不记得的小伙伴可以看看前文的代码，找找 decrementWorkerCount(),\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) { if (completedAbruptly) // If abrupt, then workerCount wasn\u0026#39;t adjusted decrementWorkerCount(); // 加锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); // 记录线程池完成的任务总数，从 workers 中移除该 worker try { completedTaskCount += w.completedTasks; workers.remove(w); } finally { mainLock.unlock(); } tryTerminate(); // 尝试关闭池子 int c = ctl.get(); // 以下的代码是判断需不需要给线程池创建一个新的线程 // 如果线程池的状态是 RUNNING 或者 SHUTDOWN 进一步判断需不需要创建 if (runStateLessThan(c, STOP)) { // 如果为异常退出直接创建，如果不是异常退出进入判断 if (!completedAbruptly) { // 获取线程池应该存在的最小线程数 如果设置了超时 则是0，否则是核心线程数 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 如果 min 是0 但是队列又不为空，则 min 应该是1 if (min == 0 \u0026amp;\u0026amp; ! workQueue.isEmpty()) min = 1; //如果当前池中的有效线程数大于等于最小线程数 则不需要创建 if (workerCountOf(c) \u0026gt;= min) return; // replacement not needed } // 创建线程 addWorker(null, false); } } 上面的代码中调用了 tryTerminate() 方法，这个方法是用于终止线程池的，又是一个 for 循环，从代码结构来看是异常情况的重试机制。还是老方法，慢慢来看总共做了几件事情\nfinal void tryTerminate() { for (;;) { int c = ctl.get(); // 如果处于这三种情况不需要关闭线程池 // 1. Running 状态 // 2. SHUTDOWN 状态并且任务队列不为空，不能终止 // 3. TIDYING 或者 TERMINATE 状态，说明已经在关闭了 不需要重复关闭 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN \u0026amp;\u0026amp; ! workQueue.isEmpty())) return; // 进入到关闭线程池的代码，如果线程池中还有线程，则需要打断线程 if (workerCountOf(c) != 0) { // Eligible to terminate 可以关闭池子 // 打断闲置线程，只打断一个 interruptIdleWorkers(ONLY_ONE); return; // 如果有两个以上怎么办？只打断一个？ // 这里只打断一个是因为 worker 回收的时候都会进入到该方法中来，可以回去再看看 // runWorker方法最后的代码 } // 线程已经回收完毕，准备关闭线程池 final ReentrantLock mainLock = this.mainLock; mainLock.lock();// 加锁 try { // 将状态改变为 TIDYING 并且即将调用 terminated if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { try { terminated(); // 终止线程池 } finally { ctl.set(ctlOf(TERMINATED, 0)); // 改变状态 termination.signalAll(); } return; } } finally { mainLock.unlock(); // 如果终止失败会重试 } // else retry on failed CAS } } 尝试终止线程池的代码分析完了，好像就结束了～但作为好奇宝宝，我们是不是应该看看如何打断闲置线程，以及 terminated 中做了什么呢？来吧，继续装逼\n先来看打断线程\nprivate void interruptIdleWorkers(boolean onlyOne) { final ReentrantLock mainLock = this.mainLock; mainLock.lock();//加锁～ try { // 遍历线程池中的 wroker for (Worker w : workers) { Thread t = w.thread; // 如果线程没有被中断，并且能够获取到 worker的锁(说明是闲置线程) if (!t.isInterrupted() \u0026amp;\u0026amp; w.tryLock()) { try { t.interrupt();// 中断线程 } catch (SecurityException ignore) { } finally { w.unlock(); } } // 只中断一个 worker 跳出循环，否则会将所有的闲置线程都中断 if (onlyOne) break; } } finally { mainLock.unlock();// 释放锁 } 有同学开始装逼了，说我们是好奇宝宝，t.interrupt() 方法也应该看，嗯～没错，但这里是调用了 native 方法，会 c 的可以去看看装逼，我就算了～\n好了，再来看看 terminate, 是不是很坑爹？ terminated 里面神！马！也！没！干！。。。淡定，其实这个方法类似于 Activity 的生命周期方法，允许你在被终止时做一些事情，默认的线程池没有什么要做的事情，当然什么也没写啦～\n/** * Method invoked when the Executor has terminated. Default * implementation does nothing. Note: To properly nest multiple * overridings, subclasses should generally invoke * {@code super.terminated} within this method. */ protected void terminated() { } 异常处理 还记得前面讲到，出现各种异常情况，添加队列失败等等，只是笼统的说了一句扔掉，当然代码实现不可能是简单一句扔掉就完了。回到 execute() 方法中找到 reject() 任务，看看究竟是怎么处理的\nfinal void reject(Runnable command) { handler.rejectedExecution(command, this); } 还记得在创建线程池的时候，初始化了一个 handler — RejectedExecutionHandler\n这是一个接口，只有一个方法,接收两个参数\nvoid rejectedExecution(Runnable r, ThreadPoolExecutor executor); 既然是一个接口，那么肯定有他的实现类，我们先不急着看所有实现类，先来看看这里的 handler 可能是什么，记得在使用 Executors 获取线程池调用构造方法的时候并没有传入 handler 参数，那么 ThreadPoolExecutor 应该会有一个默认的 handler\nprivate static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); public static class AbortPolicy implements RejectedExecutionHandler { public AbortPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(\u0026#34;Task \u0026#34; + r.toString() + \u0026#34; rejected from \u0026#34; + e.toString()); } } 默认 handler 是 AbortPolicy ,这个类实现了 rejectedExecution() 方法，抛了一个 Runtime 异常，也就是说当任务添加失败，就会抛出异常。这个类在 AsyncTask 引发了一场血案～所以在 API19 以后修改了 AsyncTask 的部分代码逻辑，这里就不细说啦.\n实际上，在 ThreadPoolExecutor 中除了 AbortPolicy 外还实现了三种不同类型的 handler\nCallerRunsPolicy — 在 线程池没有 shutdown 的前提下，会直接在执行 execute 方法的线程里执行这个任务 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } DiscardPolicy — 啥也不干，默默地丢掉任务～不信你看 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { } DiscardOldestPolicy — 丢弃掉队列中未执行的，最老的任务，也就是任务队列排头的任务，然后再试图在执行一次 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } } ","permalink":"https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/","summary":"\u003ch4 id=\"线程池是什么\"\u003e线程池是什么？\u003c/h4\u003e\n\u003cp\u003e线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。\u003c/p\u003e","title":"Java线程池"},{"content":"前言 之前学习JVM垃圾回收时，主要是过了一遍垃圾收集算法，比如复制算法，标记-清除算法，标记-整理算法，在此基础上可以增加分代，每代采取不同的回收算法，以提高整体的分配和回收效率。然后过了一遍JVM中的垃圾收集器，比如Serial、Parallel Scavenge、Parallel New、CMS、G1等。\n自认为垃圾收集就是根据GC Root标记所有可达的对象，然后把所有没有标记的对象清除就ok了。是不是很简单。事实上垃圾收集也就是这么一回事，但是很多时候说起来简单，做起来却会出现很多问题。这篇文章就是记录我对CMS垃圾收集器的一些疑问并学习的过程。\n首先看一下CMS的整体流程(具体每个流程的详情就自行了解吧)\n如何进行标记？ 最近在看Golang的GC算法实现，里面用到了三色标记法，但是在我的知识库中对三色标记法有这个概念，是的，我只知道这个概念，不知道三色标记法是怎么一个流程，也不知道三色标记法在GC中怎么与运行的。于是就开始了我的探险之旅。\n在搜索了一下三色标记法（具体可以看一下文末参考文档中三色标记法与读写屏障了解详情）后，发现现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，CMS垃圾收集器也不例外。\nGC Root有哪些？ 我们知道怎么进行标记了，但最初标记的时候需要一些根据才行啊，这些根据就是我们收的GC Root。GC Root有哪些？网上有很多的答案，我的理解就是\n当前活跃调用栈中的指向对象的引用 一些不会发生改变的数据所指向的引用 这里我使用的是引用，而不是对象，因为R大是这样说的（具体的问题见参考文档java的gc为什么要分代？）\n所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。 例如说，这些引用可能包括：\n所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。 VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。 JNI handles，包括global handles和local handles （看情况）所有当前被加载的Java类 （看情况）Java类的引用类型静态变量 （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型） （看情况）String常量池（StringTable）里的引用 注意，是一组必须活跃的引用，不是对象。\n现在知道了GC Root，但是我们都知道有分代的概念，新生代的gc和老年的代的gc回收的区域是不一样，那么这里的GC Root是不是应该不一样呢？肯定是不一样的。\n首先看一下新生代的GC\n新生代的区域一般都比较小，而且对象的存活率都比较低，所以按照前面说的GC Root在新生代的区域扫描就行了。但是会有一个问题？老年代存在引用新生代对象的可能啊？如果只扫描新生代的区域，会漏掉被老年代引用的对象，这些对象就会被清除掉，这是不允许的。\n如果这样的话，那是不是扫描一下老年代的对象，看是否引用新生代的对象是不是就ok了？嗯这么做肯定是ok的，但是老年代一般很大，而且存活的对象很多，会导致扫描占用很长的时间。那这个问题如何解？JVM是如何避免Minor GC时扫描全堆的？\n经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：\n卡表的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。\n所以新年代GC的GC Root包含2部分\n新生代中满足GC Root定义的对象 卡表中老年代引用新生代的对象 老年代的GC\n前面我们说了新生代的gc，我们以同样的思路来看看老年代的gc，老年代的GC Root如何来标记呢？只扫描老年代可以吗？当然是不行的，因为新生代中也可能存在老年代对象的引用，好在新生代并不大，所以老年代GC的时候还需要扫描一遍新生代。\n所以老年代GC的GC Root包含2部分\n老生代中满足GC Root定义的对象，如图节点1； 标记年轻代中活着的对象引用到的老年代的对象（指的是年轻代中还存活的引用类型对象，引用指向老年代中的对象）如图节点2、3； 并发标记的好坏? 标记作为垃圾回收的第一步，现在知道如何进行标记，接下来就是遍历这些对象，将所有未标记的对象清理就完成GC了。\n然而事实上并没有这么简单，如果标记的时候是STW的，那就是这么简单，但是如果标记过程都STW会造成暂停时间过长，给人的感觉就是系统一卡一卡的。\n于是就把标记的过程改成并发的进行，也就是CMS中并发标记的过程，然而这就是一切复杂问题的源头。虽然并发标记提升了标记的效率，但是因此却引发了一系列的问题。\n因为并发标记时，gc线程和用户线程是并行的，所以在这个过程中会出现下面的情况(需要了解三色标记法与读写屏障)：\n新生代晋升到老年代 黑色对象取消对灰色对象的引用(浮动垃圾) 黑色对象新增对白色对象的引用(漏标) 其实在三色标记法与读写屏障文中已经给出了解决方法\u0026ndash;添加读写屏障\n写屏障 + SATB 写屏障 + 增量更新 读屏障（Load Barrier） 在CMS并发标记阶段，使用 写屏障 + 增量更新 的方法，将上面出现的情况标记为dirty，这样最后再遍历处理一下Dirty集合中的对象就ok了\n重新标记阶段为什么还要扫描新生代？ 因为存在跨代引用，但是前面说过这种情况，通过读写屏障的方式标记这些为dirty，只需要扫描老年代和dirty集合就行了啊？哎，看来我还是太年轻，如果只扫描老年代和dirty集合会漏掉一部分，会是哪部分呢？老年代和dirty集合还没有覆盖完吗？\n是的，老年代和dirty集合的确没有覆盖完。我们来分析一下。老年代中经过初始标记和并发标记后，只有黑色对象和白色对象了，黑色的就是要留下的，白色的就是要被清除的。黑色对象是怎么来的？根据GC Root找到的，所以只要并发标记过程中，GC Root不发生变化，黑色对象就没有问题(不会漏标)，如果在并发标记过程中GC Root发生了变化呢？\n当并发标记过程中GC Root增加了，并且这个GC Root还引用了老年代中的对象，此时如果只扫描老年代和dirty集合就会漏标。因此重新标记阶段仍然需要扫描新生代。\n预处理阶段都干了啥？ 预处理阶段其实有2部分：\n预清理阶段 可终止的预处理 这个阶段的目的都是为了减轻后面的重新标记的压力，提前做一点重新标记阶段的工作。一般CMS的GC耗时80%都在remark阶段，所以预处理阶段也是为了减少remark阶段的STW时间。\n重新标记阶段需要做以下工作：\n遍历新生代对象，重新标记 根据GC Roots，重新标记 遍历老年代的Dirty Card，重新标记（这里的Dirty Card大部分已经在clean阶段处理过） 遍历新生代对象时，可能很多对象已经是不可达了，但是还是需要扫描。遍历Dirty Card做处理。\n这2部分其实就是预处理阶段帮助重新标记减轻压力的地方\n预清理阶段和可终止的预处理都会扫描Dirty Card做处理 可终止的预处理，尽量进行一次ygc，让不可达的对象被回收掉，remark阶段遍历新生代的对象成本小一点 具体这个阶段的详情见参考文档图解CMS垃圾回收机制，你值得拥有\n参考文档\n三色标记法与读写屏障 图解CMS垃圾回收机制，你值得拥有 java的gc为什么要分代？ ","permalink":"https://carlos19960601.github.io/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","summary":"\u003ch3 id=\"前言\"\u003e前言\u003c/h3\u003e\n\u003cp\u003e之前学习JVM垃圾回收时，主要是过了一遍垃圾收集算法，比如复制算法，标记-清除算法，标记-整理算法，在此基础上可以增加分代，每代采取不同的回收算法，以提高整体的分配和回收效率。然后过了一遍JVM中的垃圾收集器，比如Serial、Parallel Scavenge、Parallel New、CMS、G1等。\u003c/p\u003e\n\u003cp\u003e自认为垃圾收集就是根据GC Root标记所有可达的对象，然后把所有没有标记的对象清除就ok了。是不是很简单。事实上垃圾收集也就是这么一回事，但是很多时候说起来简单，做起来却会出现很多问题。这篇文章就是记录我对CMS垃圾收集器的一些疑问并学习的过程。\u003c/p\u003e\n\u003cp\u003e首先看一下CMS的整体流程(具体每个流程的详情就自行了解吧)\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e5%86%8d%e5%9b%9e%e9%a6%96CMS%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/CMS%e6%b5%81%e7%a8%8b.png\" alt=\"CMS流程\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"如何进行标记\"\u003e如何进行标记？\u003c/h3\u003e\n\u003cp\u003e最近在看Golang的GC算法实现，里面用到了三色标记法，但是在我的知识库中对三色标记法有这个概念，是的，我只知道这个概念，不知道三色标记法是怎么一个流程，也不知道三色标记法在GC中怎么与运行的。于是就开始了我的探险之旅。\u003c/p\u003e\n\u003cp\u003e在搜索了一下三色标记法（具体可以看一下文末参考文档中\u003ca href=\"https://www.jianshu.com/p/12544c0ad5c1\"\u003e三色标记法与读写屏障\u003c/a\u003e了解详情）后，发现现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，CMS垃圾收集器也不例外。\u003c/p\u003e\n\u003ch3 id=\"gc-root有哪些\"\u003eGC Root有哪些？\u003c/h3\u003e\n\u003cp\u003e我们知道怎么进行标记了，但最初标记的时候需要一些根据才行啊，这些根据就是我们收的GC Root。GC Root有哪些？网上有很多的答案，我的理解就是\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当前活跃调用栈中的指向对象的引用\u003c/li\u003e\n\u003cli\u003e一些不会发生改变的数据所指向的引用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里我使用的是引用，而不是对象，因为R大是这样说的（具体的问题见参考文档\u003ca href=\"https://www.zhihu.com/question/53613423/answer/135743258\"\u003ejava的gc为什么要分代？\u003c/a\u003e）\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e所谓“GC roots”，或者说tracing GC的“根集合”，就是\u003cstrong\u003e一组必须活跃的引用\u003c/strong\u003e。\n例如说，这些引用可能包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。\u003c/li\u003e\n\u003cli\u003eVM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。\u003c/li\u003e\n\u003cli\u003eJNI handles，包括global handles和local handles\u003c/li\u003e\n\u003cli\u003e（看情况）所有当前被加载的Java类\u003c/li\u003e\n\u003cli\u003e（看情况）Java类的引用类型静态变量\u003c/li\u003e\n\u003cli\u003e（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）\u003c/li\u003e\n\u003cli\u003e（看情况）String常量池（StringTable）里的引用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意，是一组必须活跃的\u003cstrong\u003e引用\u003c/strong\u003e，不是对象。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e现在知道了GC Root，但是我们都知道有分代的概念，新生代的gc和老年的代的gc回收的区域是不一样，那么这里的GC Root是不是应该不一样呢？肯定是不一样的。\u003c/p\u003e\n\u003cp\u003e首先看一下\u003cstrong\u003e新生代的GC\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e新生代的区域一般都比较小，而且对象的存活率都比较低，所以按照前面说的GC Root在新生代的区域扫描就行了。但是会有一个问题？老年代存在引用新生代对象的可能啊？如果只扫描新生代的区域，会漏掉被老年代引用的对象，这些对象就会被清除掉，这是不允许的。\u003c/p\u003e\n\u003cp\u003e如果这样的话，那是不是扫描一下老年代的对象，看是否引用新生代的对象是不是就ok了？嗯这么做肯定是ok的，但是老年代一般很大，而且存活的对象很多，会导致扫描占用很长的时间。那这个问题如何解？JVM是如何避免Minor GC时扫描全堆的？\u003c/p\u003e\n\u003cp\u003e经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e5%86%8d%e5%9b%9e%e9%a6%96CMS%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/CardTable.png\" alt=\"CardTable\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e卡表\u003c/strong\u003e的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。\u003c/p\u003e\n\u003cp\u003e所以新年代GC的GC Root包含2部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e新生代中满足GC Root定义的对象\u003c/li\u003e\n\u003cli\u003e卡表中老年代引用新生代的对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e老年代的GC\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e前面我们说了新生代的gc，我们以同样的思路来看看老年代的gc，老年代的GC Root如何来标记呢？只扫描老年代可以吗？当然是不行的，因为新生代中也可能存在老年代对象的引用，好在新生代并不大，所以老年代GC的时候还需要扫描一遍新生代。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/%e5%86%8d%e5%9b%9e%e9%a6%96CMS%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/%e6%96%b0%e7%94%9f%e4%bb%a3GC%e7%9a%84Root.png\" alt=\"新生代GC的Root\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e所以老年代GC的GC Root包含2部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e老生代中满足GC Root定义的对象，如图节点1；\u003c/li\u003e\n\u003cli\u003e标记年轻代中活着的对象引用到的老年代的对象（指的是年轻代中还存活的引用类型对象，引用指向老年代中的对象）如图节点2、3；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"并发标记的好坏\"\u003e并发标记的好坏?\u003c/h3\u003e\n\u003cp\u003e标记作为垃圾回收的第一步，现在知道如何进行标记，接下来就是遍历这些对象，将所有未标记的对象清理就完成GC了。\u003c/p\u003e\n\u003cp\u003e然而事实上并没有这么简单，如果标记的时候是STW的，那就是这么简单，但是如果标记过程都STW会造成暂停时间过长，给人的感觉就是系统一卡一卡的。\u003c/p\u003e\n\u003cp\u003e于是就把标记的过程改成并发的进行，也就是CMS中并发标记的过程，然而这就是一切复杂问题的源头。虽然并发标记提升了标记的效率，但是因此却引发了一系列的问题。\u003c/p\u003e\n\u003cp\u003e因为并发标记时，gc线程和用户线程是并行的，所以在这个过程中会出现下面的情况(需要了解\u003ca href=\"https://www.jianshu.com/p/12544c0ad5c1\"\u003e三色标记法与读写屏障\u003c/a\u003e)：\u003c/p\u003e","title":"再回首CMS垃圾回收"}]