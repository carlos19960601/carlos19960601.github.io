<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Golang on Carlos的废话集</title>
    <link>https://carlos19960601.github.io/tags/golang/</link>
    <description>Recent content in Golang on Carlos的废话集</description>
    <generator>Hugo -- 0.128.0</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 27 Jul 2021 23:45:51 +0800</lastBuildDate>
    <atom:link href="https://carlos19960601.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于Golang GC问题的思考</title>
      <link>https://carlos19960601.github.io/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Tue, 27 Jul 2021 23:45:51 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%85%B3%E4%BA%8Egolang-gc%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;由于GC复杂，我也没有仔细研究过GC的源码，所以只能站在巨人的肩上学习，如果想了解GC的具体实现请移步文末的参考资料。本文只是记录我在阅读完大佬文章中自己的一些问题与思考，可能有一些不对的地方。欢迎大家一起讨论。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Timer源码阅读分享</title>
      <link>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</link>
      <pubDate>Sat, 10 Jul 2021 01:09:15 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</guid>
      <description>这是在小团队里面的一次分享，以下是PPT内容</description>
    </item>
    <item>
      <title>Timer源码阅读</title>
      <link>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 22 Apr 2021 22:50:29 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/timer%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;根据&lt;a href=&#34;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/&#34;&gt;6.3 计时器&lt;/a&gt;中的描述，Golang Timer的设计经历了如下阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；&lt;/li&gt;
&lt;li&gt;Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；&lt;/li&gt;
&lt;li&gt;Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Go 1.9 版本之前由于使用全局的四叉堆，在多核情况下会出现锁竞争导致性能问题&lt;/li&gt;
&lt;li&gt;Go 1.10 ~ 1.13使用了64个四叉堆，有每个P来维护对应的四叉堆，相当于将锁的粒度减小，但是当timer在未到时间和到时间需要执行进行切换的时候，会发生P和M的绑定和解绑，尤其是当timer触发时间间隔比较小的情况下，会导致CPU占用过高，M/P切换的开销增加(TODO  为什么会发生P和M的绑定和解绑)&lt;/li&gt;
&lt;li&gt;Go 1.14 版本后每个P管理计时器四叉堆，由网络轮询器和调度器进行触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用的是Go 1.16的版本进行分析&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
