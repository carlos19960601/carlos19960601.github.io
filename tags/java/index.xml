<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on Carlos的废话集</title>
    <link>https://carlos19960601.github.io/tags/java/</link>
    <description>Recent content in Java on Carlos的废话集</description>
    <generator>Hugo -- 0.134.0</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 16 Dec 2020 12:55:05 +0800</lastBuildDate>
    <atom:link href="https://carlos19960601.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java线程池</title>
      <link>https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Wed, 16 Dec 2020 12:55:05 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>&lt;h4 id=&#34;线程池是什么&#34;&gt;线程池是什么？&lt;/h4&gt;
&lt;p&gt;线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>再回首CMS垃圾回收</title>
      <link>https://carlos19960601.github.io/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Fri, 27 Nov 2020 21:50:29 +0800</pubDate>
      <guid>https://carlos19960601.github.io/posts/%E5%86%8D%E5%9B%9E%E9%A6%96cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;之前学习JVM垃圾回收时，主要是过了一遍垃圾收集算法，比如复制算法，标记-清除算法，标记-整理算法，在此基础上可以增加分代，每代采取不同的回收算法，以提高整体的分配和回收效率。然后过了一遍JVM中的垃圾收集器，比如Serial、Parallel Scavenge、Parallel New、CMS、G1等。&lt;/p&gt;
&lt;p&gt;自认为垃圾收集就是根据GC Root标记所有可达的对象，然后把所有没有标记的对象清除就ok了。是不是很简单。事实上垃圾收集也就是这么一回事，但是很多时候说起来简单，做起来却会出现很多问题。这篇文章就是记录我对CMS垃圾收集器的一些疑问并学习的过程。&lt;/p&gt;
&lt;p&gt;首先看一下CMS的整体流程(具体每个流程的详情就自行了解吧)&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://carlos19960601.github.io/%e5%86%8d%e5%9b%9e%e9%a6%96CMS%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/CMS%e6%b5%81%e7%a8%8b.png&#34; alt=&#34;CMS流程&#34;  /&gt;
&lt;/p&gt;
&lt;h3 id=&#34;如何进行标记&#34;&gt;如何进行标记？&lt;/h3&gt;
&lt;p&gt;最近在看Golang的GC算法实现，里面用到了三色标记法，但是在我的知识库中对三色标记法有这个概念，是的，我只知道这个概念，不知道三色标记法是怎么一个流程，也不知道三色标记法在GC中怎么与运行的。于是就开始了我的探险之旅。&lt;/p&gt;
&lt;p&gt;在搜索了一下三色标记法（具体可以看一下文末参考文档中&lt;a href=&#34;https://www.jianshu.com/p/12544c0ad5c1&#34;&gt;三色标记法与读写屏障&lt;/a&gt;了解详情）后，发现现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，CMS垃圾收集器也不例外。&lt;/p&gt;
&lt;h3 id=&#34;gc-root有哪些&#34;&gt;GC Root有哪些？&lt;/h3&gt;
&lt;p&gt;我们知道怎么进行标记了，但最初标记的时候需要一些根据才行啊，这些根据就是我们收的GC Root。GC Root有哪些？网上有很多的答案，我的理解就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前活跃调用栈中的指向对象的引用&lt;/li&gt;
&lt;li&gt;一些不会发生改变的数据所指向的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我使用的是引用，而不是对象，因为R大是这样说的（具体的问题见参考文档&lt;a href=&#34;https://www.zhihu.com/question/53613423/answer/135743258&#34;&gt;java的gc为什么要分代？&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓“GC roots”，或者说tracing GC的“根集合”，就是&lt;strong&gt;一组必须活跃的引用&lt;/strong&gt;。
例如说，这些引用可能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。&lt;/li&gt;
&lt;li&gt;VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。&lt;/li&gt;
&lt;li&gt;JNI handles，包括global handles和local handles&lt;/li&gt;
&lt;li&gt;（看情况）所有当前被加载的Java类&lt;/li&gt;
&lt;li&gt;（看情况）Java类的引用类型静态变量&lt;/li&gt;
&lt;li&gt;（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）&lt;/li&gt;
&lt;li&gt;（看情况）String常量池（StringTable）里的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，是一组必须活跃的&lt;strong&gt;引用&lt;/strong&gt;，不是对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在知道了GC Root，但是我们都知道有分代的概念，新生代的gc和老年的代的gc回收的区域是不一样，那么这里的GC Root是不是应该不一样呢？肯定是不一样的。&lt;/p&gt;
&lt;p&gt;首先看一下&lt;strong&gt;新生代的GC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新生代的区域一般都比较小，而且对象的存活率都比较低，所以按照前面说的GC Root在新生代的区域扫描就行了。但是会有一个问题？老年代存在引用新生代对象的可能啊？如果只扫描新生代的区域，会漏掉被老年代引用的对象，这些对象就会被清除掉，这是不允许的。&lt;/p&gt;
&lt;p&gt;如果这样的话，那是不是扫描一下老年代的对象，看是否引用新生代的对象是不是就ok了？嗯这么做肯定是ok的，但是老年代一般很大，而且存活的对象很多，会导致扫描占用很长的时间。那这个问题如何解？JVM是如何避免Minor GC时扫描全堆的？&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
